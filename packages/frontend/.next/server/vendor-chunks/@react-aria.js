/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-aria";
exports.ids = ["vendor-chunks/@react-aria"];
exports.modules = {

/***/ "(ssr)/../../node_modules/@react-aria/focus/node_modules/clsx/dist/clsx.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@react-aria/focus/node_modules/clsx/dist/clsx.js ***!
  \***************************************************************************/
/***/ ((module) => {

eval("function e(r){var o,t,f=\"\";if(\"string\"==typeof r||\"number\"==typeof r)f+=r;else if(\"object\"==typeof r)if(Array.isArray(r))for(o=0;o<r.length;o++)r[o]&&(t=e(r[o]))&&(f&&(f+=\" \"),f+=t);else for(o in r)r[o]&&(f&&(f+=\" \"),f+=o);return f}function r(){for(var r,o,t=0,f=\"\";t<arguments.length;)(r=arguments[t++])&&(o=e(r))&&(f&&(f+=\" \"),f+=o);return f}module.exports=r,module.exports.clsx=r;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL2ZvY3VzL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLGFBQWEsK0NBQStDLHVEQUF1RCxXQUFXLDBDQUEwQyx5Q0FBeUMsU0FBUyxhQUFhLHFCQUFxQixtQkFBbUIsa0RBQWtELFNBQVMsaUJBQWlCLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AcmVhY3QtYXJpYS9mb2N1cy9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3guanM/ZGJiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBlKHIpe3ZhciBvLHQsZj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiByfHxcIm51bWJlclwiPT10eXBlb2YgcilmKz1yO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIHIpaWYoQXJyYXkuaXNBcnJheShyKSlmb3Iobz0wO288ci5sZW5ndGg7bysrKXJbb10mJih0PWUocltvXSkpJiYoZiYmKGYrPVwiIFwiKSxmKz10KTtlbHNlIGZvcihvIGluIHIpcltvXSYmKGYmJihmKz1cIiBcIiksZis9byk7cmV0dXJuIGZ9ZnVuY3Rpb24gcigpe2Zvcih2YXIgcixvLHQ9MCxmPVwiXCI7dDxhcmd1bWVudHMubGVuZ3RoOykocj1hcmd1bWVudHNbdCsrXSkmJihvPWUocikpJiYoZiYmKGYrPVwiIFwiKSxmKz1vKTtyZXR1cm4gZn1tb2R1bGUuZXhwb3J0cz1yLG1vZHVsZS5leHBvcnRzLmNsc3g9cjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@react-aria/focus/node_modules/clsx/dist/clsx.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@react-aria/utils/node_modules/clsx/dist/clsx.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@react-aria/utils/node_modules/clsx/dist/clsx.js ***!
  \***************************************************************************/
/***/ ((module) => {

eval("function e(r){var o,t,f=\"\";if(\"string\"==typeof r||\"number\"==typeof r)f+=r;else if(\"object\"==typeof r)if(Array.isArray(r))for(o=0;o<r.length;o++)r[o]&&(t=e(r[o]))&&(f&&(f+=\" \"),f+=t);else for(o in r)r[o]&&(f&&(f+=\" \"),f+=o);return f}function r(){for(var r,o,t=0,f=\"\";t<arguments.length;)(r=arguments[t++])&&(o=e(r))&&(f&&(f+=\" \"),f+=o);return f}module.exports=r,module.exports.clsx=r;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL3V0aWxzL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLGFBQWEsK0NBQStDLHVEQUF1RCxXQUFXLDBDQUEwQyx5Q0FBeUMsU0FBUyxhQUFhLHFCQUFxQixtQkFBbUIsa0RBQWtELFNBQVMsaUJBQWlCLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AcmVhY3QtYXJpYS91dGlscy9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3guanM/Y2U0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBlKHIpe3ZhciBvLHQsZj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiByfHxcIm51bWJlclwiPT10eXBlb2YgcilmKz1yO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIHIpaWYoQXJyYXkuaXNBcnJheShyKSlmb3Iobz0wO288ci5sZW5ndGg7bysrKXJbb10mJih0PWUocltvXSkpJiYoZiYmKGYrPVwiIFwiKSxmKz10KTtlbHNlIGZvcihvIGluIHIpcltvXSYmKGYmJihmKz1cIiBcIiksZis9byk7cmV0dXJuIGZ9ZnVuY3Rpb24gcigpe2Zvcih2YXIgcixvLHQ9MCxmPVwiXCI7dDxhcmd1bWVudHMubGVuZ3RoOykocj1hcmd1bWVudHNbdCsrXSkmJihvPWUocikpJiYoZiYmKGYrPVwiIFwiKSxmKz1vKTtyZXR1cm4gZn1tb2R1bGUuZXhwb3J0cz1yLG1vZHVsZS5leHBvcnRzLmNsc3g9cjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@react-aria/utils/node_modules/clsx/dist/clsx.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@react-aria/focus/dist/import.mjs":
/*!************************************************************!*\
  !*** ../../node_modules/@react-aria/focus/dist/import.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FocusRing: () => (/* binding */ $907718708eab68af$export$1a38b4ad7f578e1d),\n/* harmony export */   FocusScope: () => (/* binding */ $9bf71ea28793e738$export$20e40289641fbbb6),\n/* harmony export */   FocusableProvider: () => (/* binding */ $e6afbd83fe6ebbd2$export$13f3202a3e5ddd5),\n/* harmony export */   createFocusManager: () => (/* binding */ $9bf71ea28793e738$export$c5251b9e124bf29),\n/* harmony export */   focusSafely: () => (/* binding */ $6a99195332edec8b$export$80f3e147d781571c),\n/* harmony export */   getFocusableTreeWalker: () => (/* binding */ $9bf71ea28793e738$export$2d6ec8fc375ceafa),\n/* harmony export */   isElementInChildOfActiveScope: () => (/* binding */ $9bf71ea28793e738$export$1258395f99bf9cbf),\n/* harmony export */   useFocusManager: () => (/* binding */ $9bf71ea28793e738$export$10c5169755ce7bd7),\n/* harmony export */   useFocusRing: () => (/* binding */ $f7dceffc5ad7768b$export$4e328f61c538687f),\n/* harmony export */   useFocusable: () => (/* binding */ $e6afbd83fe6ebbd2$export$4c014de7c8940b4c),\n/* harmony export */   useHasTabbableChild: () => (/* binding */ $83013635b024ae3d$export$eac1895992b9f3d6)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/../../node_modules/@react-aria/utils/dist/import.mjs\");\n/* harmony import */ var _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/interactions */ \"(ssr)/../../node_modules/@react-aria/interactions/dist/import.mjs\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(ssr)/../../node_modules/@react-aria/focus/node_modules/clsx/dist/clsx.js\");\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nfunction $6a99195332edec8b$export$80f3e147d781571c(element) {\n    // If the user is interacting with a virtual cursor, e.g. screen reader, then\n    // wait until after any animated transitions that are currently occurring on\n    // the page before shifting focus. This avoids issues with VoiceOver on iOS\n    // causing the page to scroll when moving focus if the element is transitioning\n    // from off the screen.\n    if ((0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__.getInteractionModality)() === \"virtual\") {\n        let lastFocusedElement = document.activeElement;\n        (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.runAfterTransition)(()=>{\n            // If focus did not move and the element is still in the document, focus it.\n            if (document.activeElement === lastFocusedElement && document.contains(element)) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.focusWithoutScrolling)(element);\n        });\n    } else (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.focusWithoutScrolling)(element);\n}\n\n\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $645f2e67b85a24c9$var$isStyleVisible(element) {\n    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;\n    let { display: display, visibility: visibility } = element.style;\n    let isVisible = display !== \"none\" && visibility !== \"hidden\" && visibility !== \"collapse\";\n    if (isVisible) {\n        const { getComputedStyle: getComputedStyle } = element.ownerDocument.defaultView;\n        let { display: computedDisplay, visibility: computedVisibility } = getComputedStyle(element);\n        isVisible = computedDisplay !== \"none\" && computedVisibility !== \"hidden\" && computedVisibility !== \"collapse\";\n    }\n    return isVisible;\n}\nfunction $645f2e67b85a24c9$var$isAttributeVisible(element, childElement) {\n    return !element.hasAttribute(\"hidden\") && (element.nodeName === \"DETAILS\" && childElement && childElement.nodeName !== \"SUMMARY\" ? element.hasAttribute(\"open\") : true);\n}\nfunction $645f2e67b85a24c9$export$e989c0fffaa6b27a(element, childElement) {\n    return element.nodeName !== \"#comment\" && $645f2e67b85a24c9$var$isStyleVisible(element) && $645f2e67b85a24c9$var$isAttributeVisible(element, childElement) && (!element.parentElement || $645f2e67b85a24c9$export$e989c0fffaa6b27a(element.parentElement, element));\n}\n\n\n\n\nconst $9bf71ea28793e738$var$FocusContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext(null);\nlet $9bf71ea28793e738$var$activeScope = null;\nfunction $9bf71ea28793e738$export$20e40289641fbbb6(props) {\n    let { children: children, contain: contain, restoreFocus: restoreFocus, autoFocus: autoFocus } = props;\n    let startRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let endRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let scopeRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    let { parentNode: parentNode } = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($9bf71ea28793e738$var$FocusContext) || {};\n    // Create a tree node here so we can add children to it even before it is added to the tree.\n    let node = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new $9bf71ea28793e738$var$TreeNode({\n            scopeRef: scopeRef\n        }), [\n        scopeRef\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),\n        // use the active scope as the parent instead of the parent from context. Layout effects run bottom\n        // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope\n        // that is being added should get the activeScope as its parent.\n        let parent = parentNode || $9bf71ea28793e738$export$d06fae2ee68b101e.root;\n        if ($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $9bf71ea28793e738$var$activeScope && !$9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, parent.scopeRef)) {\n            let activeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n            if (activeNode) parent = activeNode;\n        }\n        // Add the node to the parent, and to the tree.\n        parent.addChild(node);\n        $9bf71ea28793e738$export$d06fae2ee68b101e.addNode(node);\n    }, [\n        node,\n        parentNode\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        let node = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n        if (node) node.contain = !!contain;\n    }, [\n        contain\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        var _startRef_current;\n        // Find all rendered nodes between the sentinels and add them to the scope.\n        let node = (_startRef_current = startRef.current) === null || _startRef_current === void 0 ? void 0 : _startRef_current.nextSibling;\n        let nodes = [];\n        while(node && node !== endRef.current){\n            nodes.push(node);\n            node = node.nextSibling;\n        }\n        scopeRef.current = nodes;\n    }, [\n        children\n    ]);\n    $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);\n    $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain);\n    $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain);\n    $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus);\n    // This needs to be an effect so that activeScope is updated after the FocusScope tree is complete.\n    // It cannot be a useLayoutEffect because the parent of this node hasn't been attached in the tree yet.\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let activeElement = document.activeElement;\n        let scope = null;\n        if ($9bf71ea28793e738$var$isElementInScope(activeElement, scopeRef.current)) {\n            // We need to traverse the focusScope tree and find the bottom most scope that\n            // contains the active element and set that as the activeScope.\n            for (let node of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse())if (node.scopeRef && $9bf71ea28793e738$var$isElementInScope(activeElement, node.scopeRef.current)) scope = node;\n            if (scope === $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef)) $9bf71ea28793e738$var$activeScope = scope.scopeRef;\n        }\n    }, [\n        scopeRef\n    ]);\n    // This layout effect cleanup is so that the tree node is removed synchronously with react before the RAF\n    // in useRestoreFocus cleanup runs.\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        return ()=>{\n            var _focusScopeTree_getTreeNode_parent, _focusScopeTree_getTreeNode;\n            var _focusScopeTree_getTreeNode_parent_scopeRef;\n            // Scope may have been re-parented.\n            let parentScope = (_focusScopeTree_getTreeNode_parent_scopeRef = (_focusScopeTree_getTreeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : (_focusScopeTree_getTreeNode_parent = _focusScopeTree_getTreeNode.parent) === null || _focusScopeTree_getTreeNode_parent === void 0 ? void 0 : _focusScopeTree_getTreeNode_parent.scopeRef) !== null && _focusScopeTree_getTreeNode_parent_scopeRef !== void 0 ? _focusScopeTree_getTreeNode_parent_scopeRef : null;\n            if ((scopeRef === $9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope(scopeRef, $9bf71ea28793e738$var$activeScope)) && (!parentScope || $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parentScope))) $9bf71ea28793e738$var$activeScope = parentScope;\n            $9bf71ea28793e738$export$d06fae2ee68b101e.removeTreeNode(scopeRef);\n        };\n    }, [\n        scopeRef\n    ]);\n    let focusManager = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$9bf71ea28793e738$var$createFocusManagerForScope(scopeRef), []);\n    let value = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            focusManager: focusManager,\n            parentNode: node\n        }), [\n        node,\n        focusManager\n    ]);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($9bf71ea28793e738$var$FocusContext.Provider, {\n        value: value\n    }, /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement(\"span\", {\n        \"data-focus-scope-start\": true,\n        hidden: true,\n        ref: startRef\n    }), children, /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement(\"span\", {\n        \"data-focus-scope-end\": true,\n        hidden: true,\n        ref: endRef\n    }));\n}\nfunction $9bf71ea28793e738$export$10c5169755ce7bd7() {\n    var _useContext;\n    return (_useContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($9bf71ea28793e738$var$FocusContext)) === null || _useContext === void 0 ? void 0 : _useContext.focusManager;\n}\nfunction $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef) {\n    return {\n        focusNext (opts = {}) {\n            let scope = scopeRef.current;\n            let { from: from, tabbable: tabbable, wrap: wrap, accept: accept } = opts;\n            let node = from || document.activeElement;\n            let sentinel = scope[0].previousElementSibling;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node, scope) ? node : sentinel;\n            let nextNode = walker.nextNode();\n            if (!nextNode && wrap) {\n                walker.currentNode = sentinel;\n                nextNode = walker.nextNode();\n            }\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusPrevious (opts = {}) {\n            let scope = scopeRef.current;\n            let { from: from, tabbable: tabbable, wrap: wrap, accept: accept } = opts;\n            let node = from || document.activeElement;\n            let sentinel = scope[scope.length - 1].nextElementSibling;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node, scope) ? node : sentinel;\n            let previousNode = walker.previousNode();\n            if (!previousNode && wrap) {\n                walker.currentNode = sentinel;\n                previousNode = walker.previousNode();\n            }\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode;\n        },\n        focusFirst (opts = {}) {\n            let scope = scopeRef.current;\n            let { tabbable: tabbable, accept: accept } = opts;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = scope[0].previousElementSibling;\n            let nextNode = walker.nextNode();\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusLast (opts = {}) {\n            let scope = scopeRef.current;\n            let { tabbable: tabbable, accept: accept } = opts;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = scope[scope.length - 1].nextElementSibling;\n            let previousNode = walker.previousNode();\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode;\n        }\n    };\n}\nconst $9bf71ea28793e738$var$focusableElements = [\n    \"input:not([disabled]):not([type=hidden])\",\n    \"select:not([disabled])\",\n    \"textarea:not([disabled])\",\n    \"button:not([disabled])\",\n    \"a[href]\",\n    \"area[href]\",\n    \"summary\",\n    \"iframe\",\n    \"object\",\n    \"embed\",\n    \"audio[controls]\",\n    \"video[controls]\",\n    \"[contenteditable]\"\n];\nconst $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(\":not([hidden]),\") + \",[tabindex]:not([disabled]):not([hidden])\";\n$9bf71ea28793e738$var$focusableElements.push('[tabindex]:not([tabindex=\"-1\"]):not([disabled])');\nconst $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(':not([hidden]):not([tabindex=\"-1\"]),');\nfunction $9bf71ea28793e738$var$getScopeRoot(scope) {\n    return scope[0].parentElement;\n}\nfunction $9bf71ea28793e738$var$shouldContainFocus(scopeRef) {\n    let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n    while(scope && scope.scopeRef !== scopeRef){\n        if (scope.contain) return false;\n        scope = scope.parent;\n    }\n    return true;\n}\nfunction $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain) {\n    let focusedNode = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    let raf = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        let scope = scopeRef.current;\n        if (!contain) {\n            // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment\n            if (raf.current) {\n                cancelAnimationFrame(raf.current);\n                raf.current = undefined;\n            }\n            return;\n        }\n        // Handle the Tab key to contain focus within the scope\n        let onKeyDown = (e)=>{\n            if (e.key !== \"Tab\" || e.altKey || e.ctrlKey || e.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef)) return;\n            let focusedElement = document.activeElement;\n            let scope = scopeRef.current;\n            if (!scope || !$9bf71ea28793e738$var$isElementInScope(focusedElement, scope)) return;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: true\n            }, scope);\n            if (!focusedElement) return;\n            walker.currentNode = focusedElement;\n            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            if (!nextElement) {\n                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;\n                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            }\n            e.preventDefault();\n            if (nextElement) $9bf71ea28793e738$var$focusElement(nextElement, true);\n        };\n        let onFocus = (e)=>{\n            // If focusing an element in a child scope of the currently active scope, the child becomes active.\n            // Moving out of the active scope to an ancestor is not allowed.\n            if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(e.target, scopeRef.current)) {\n                $9bf71ea28793e738$var$activeScope = scopeRef;\n                focusedNode.current = e.target;\n            } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(e.target, scopeRef)) {\n                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),\n                // restore focus to the previously focused node or the first tabbable element in the active scope.\n                if (focusedNode.current) focusedNode.current.focus();\n                else if ($9bf71ea28793e738$var$activeScope && $9bf71ea28793e738$var$activeScope.current) $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);\n            } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef)) focusedNode.current = e.target;\n        };\n        let onBlur = (e)=>{\n            // Firefox doesn't shift focus back to the Dialog properly without this\n            if (raf.current) cancelAnimationFrame(raf.current);\n            raf.current = requestAnimationFrame(()=>{\n                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe\n                if (document.activeElement && $9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(document.activeElement, scopeRef)) {\n                    $9bf71ea28793e738$var$activeScope = scopeRef;\n                    if (document.body.contains(e.target)) {\n                        var _focusedNode_current;\n                        focusedNode.current = e.target;\n                        (_focusedNode_current = focusedNode.current) === null || _focusedNode_current === void 0 ? void 0 : _focusedNode_current.focus();\n                    } else if ($9bf71ea28793e738$var$activeScope.current) $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);\n                }\n            });\n        };\n        document.addEventListener(\"keydown\", onKeyDown, false);\n        document.addEventListener(\"focusin\", onFocus, false);\n        scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.addEventListener(\"focusin\", onFocus, false));\n        scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.addEventListener(\"focusout\", onBlur, false));\n        return ()=>{\n            document.removeEventListener(\"keydown\", onKeyDown, false);\n            document.removeEventListener(\"focusin\", onFocus, false);\n            scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.removeEventListener(\"focusin\", onFocus, false));\n            scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.removeEventListener(\"focusout\", onBlur, false));\n        };\n    }, [\n        scopeRef,\n        contain\n    ]);\n    // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur\n    // eslint-disable-next-line arrow-body-style\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        return ()=>{\n            if (raf.current) cancelAnimationFrame(raf.current);\n        };\n    }, [\n        raf\n    ]);\n}\nfunction $9bf71ea28793e738$var$isElementInAnyScope(element) {\n    return $9bf71ea28793e738$var$isElementInChildScope(element);\n}\nfunction $9bf71ea28793e738$var$isElementInScope(element, scope) {\n    if (!element) return false;\n    if (!scope) return false;\n    return scope.some((node)=>node.contains(element));\n}\nfunction $9bf71ea28793e738$var$isElementInChildScope(element, scope = null) {\n    // If the element is within a top layer element (e.g. toasts), always allow moving focus there.\n    if (element instanceof Element && element.closest(\"[data-react-aria-top-layer]\")) return true;\n    // node.contains in isElementInScope covers child scopes that are also DOM children,\n    // but does not cover child scopes in portals.\n    for (let { scopeRef: s } of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope))){\n        if (s && $9bf71ea28793e738$var$isElementInScope(element, s.current)) return true;\n    }\n    return false;\n}\nfunction $9bf71ea28793e738$export$1258395f99bf9cbf(element) {\n    return $9bf71ea28793e738$var$isElementInChildScope(element, $9bf71ea28793e738$var$activeScope);\n}\nfunction $9bf71ea28793e738$var$isAncestorScope(ancestor, scope) {\n    var _focusScopeTree_getTreeNode;\n    let parent = (_focusScopeTree_getTreeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;\n    while(parent){\n        if (parent.scopeRef === ancestor) return true;\n        parent = parent.parent;\n    }\n    return false;\n}\nfunction $9bf71ea28793e738$var$focusElement(element, scroll = false) {\n    if (element != null && !scroll) try {\n        (0, $6a99195332edec8b$export$80f3e147d781571c)(element);\n    } catch (err) {\n    // ignore\n    }\n    else if (element != null) try {\n        element.focus();\n    } catch (err) {\n    // ignore\n    }\n}\nfunction $9bf71ea28793e738$var$focusFirstInScope(scope, tabbable = true) {\n    let sentinel = scope[0].previousElementSibling;\n    let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n    let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n        tabbable: tabbable\n    }, scope);\n    walker.currentNode = sentinel;\n    let nextNode = walker.nextNode();\n    // If the scope does not contain a tabbable element, use the first focusable element.\n    if (tabbable && !nextNode) {\n        scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n        walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n            tabbable: false\n        }, scope);\n        walker.currentNode = sentinel;\n        nextNode = walker.nextNode();\n    }\n    $9bf71ea28793e738$var$focusElement(nextNode);\n}\nfunction $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus) {\n    const autoFocusRef = (0, react__WEBPACK_IMPORTED_MODULE_0__).useRef(autoFocus);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (autoFocusRef.current) {\n            $9bf71ea28793e738$var$activeScope = scopeRef;\n            if (!$9bf71ea28793e738$var$isElementInScope(document.activeElement, $9bf71ea28793e738$var$activeScope.current) && scopeRef.current) $9bf71ea28793e738$var$focusFirstInScope(scopeRef.current);\n        }\n        autoFocusRef.current = false;\n    }, [\n        scopeRef\n    ]);\n}\nfunction $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restore, contain) {\n    // tracks the active scope, in case restore and contain are both false.\n    // if either are true, this is tracked in useRestoreFocus or useFocusContainment.\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        if (restore || contain) return;\n        let scope = scopeRef.current;\n        let onFocus = (e)=>{\n            let target = e.target;\n            if ($9bf71ea28793e738$var$isElementInScope(target, scopeRef.current)) $9bf71ea28793e738$var$activeScope = scopeRef;\n            else if (!$9bf71ea28793e738$var$isElementInAnyScope(target)) $9bf71ea28793e738$var$activeScope = null;\n        };\n        document.addEventListener(\"focusin\", onFocus, false);\n        scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.addEventListener(\"focusin\", onFocus, false));\n        return ()=>{\n            document.removeEventListener(\"focusin\", onFocus, false);\n            scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.removeEventListener(\"focusin\", onFocus, false));\n        };\n    }, [\n        scopeRef,\n        restore,\n        contain\n    ]);\n}\nfunction $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef) {\n    let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n    while(scope && scope.scopeRef !== scopeRef){\n        if (scope.nodeToRestore) return false;\n        scope = scope.parent;\n    }\n    return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;\n}\nfunction $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain) {\n    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.\n    const nodeToRestoreRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(typeof document !== \"undefined\" ? document.activeElement : null);\n    // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus\n    // restoring-non-containing scopes should only care if they become active so they can perform the restore\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        let scope = scopeRef.current;\n        if (!restoreFocus || contain) return;\n        let onFocus = ()=>{\n            // If focusing an element in a child scope of the currently active scope, the child becomes active.\n            // Moving out of the active scope to an ancestor is not allowed.\n            if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(document.activeElement, scopeRef.current)) $9bf71ea28793e738$var$activeScope = scopeRef;\n        };\n        document.addEventListener(\"focusin\", onFocus, false);\n        scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.addEventListener(\"focusin\", onFocus, false));\n        return ()=>{\n            document.removeEventListener(\"focusin\", onFocus, false);\n            scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.removeEventListener(\"focusin\", onFocus, false));\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        scopeRef,\n        contain\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        if (!restoreFocus) return;\n        // Handle the Tab key so that tabbing out of the scope goes to the next element\n        // after the node that had focus when the scope mounted. This is important when\n        // using portals for overlays, so that focus goes to the expected element when\n        // tabbing out of the overlay.\n        let onKeyDown = (e)=>{\n            if (e.key !== \"Tab\" || e.altKey || e.ctrlKey || e.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef)) return;\n            let focusedElement = document.activeElement;\n            if (!$9bf71ea28793e738$var$isElementInScope(focusedElement, scopeRef.current)) return;\n            let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n            if (!treeNode) return;\n            let nodeToRestore = treeNode.nodeToRestore;\n            // Create a DOM tree walker that matches all tabbable elements\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(document.body, {\n                tabbable: true\n            });\n            // Find the next tabbable element after the currently focused element\n            walker.currentNode = focusedElement;\n            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            if (!nodeToRestore || !document.body.contains(nodeToRestore) || nodeToRestore === document.body) {\n                nodeToRestore = undefined;\n                treeNode.nodeToRestore = undefined;\n            }\n            // If there is no next element, or it is outside the current scope, move focus to the\n            // next element after the node to restore to instead.\n            if ((!nextElement || !$9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {\n                walker.currentNode = nodeToRestore;\n                // Skip over elements within the scope, in case the scope immediately follows the node to restore.\n                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n                while ($9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current));\n                e.preventDefault();\n                e.stopPropagation();\n                if (nextElement) $9bf71ea28793e738$var$focusElement(nextElement, true);\n                else // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)\n                // then move focus to the body.\n                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)\n                if (!$9bf71ea28793e738$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();\n                else $9bf71ea28793e738$var$focusElement(nodeToRestore, true);\n            }\n        };\n        if (!contain) document.addEventListener(\"keydown\", onKeyDown, true);\n        return ()=>{\n            if (!contain) document.removeEventListener(\"keydown\", onKeyDown, true);\n        };\n    }, [\n        scopeRef,\n        restoreFocus,\n        contain\n    ]);\n    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        if (!restoreFocus) return;\n        let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n        if (!treeNode) return;\n        var _nodeToRestoreRef_current;\n        treeNode.nodeToRestore = (_nodeToRestoreRef_current = nodeToRestoreRef.current) !== null && _nodeToRestoreRef_current !== void 0 ? _nodeToRestoreRef_current : undefined;\n        return ()=>{\n            let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n            if (!treeNode) return;\n            let nodeToRestore = treeNode.nodeToRestore;\n            // if we already lost focus to the body and this was the active scope, then we should attempt to restore\n            if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps\n            ($9bf71ea28793e738$var$isElementInScope(document.activeElement, scopeRef.current) || document.activeElement === document.body && $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef))) {\n                // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it\n                let clonedTree = $9bf71ea28793e738$export$d06fae2ee68b101e.clone();\n                requestAnimationFrame(()=>{\n                    // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere\n                    if (document.activeElement === document.body) {\n                        // look up the tree starting with our scope to find a nodeToRestore still in the DOM\n                        let treeNode = clonedTree.getTreeNode(scopeRef);\n                        while(treeNode){\n                            if (treeNode.nodeToRestore && document.body.contains(treeNode.nodeToRestore)) {\n                                $9bf71ea28793e738$var$focusElement(treeNode.nodeToRestore);\n                                return;\n                            }\n                            treeNode = treeNode.parent;\n                        }\n                        // If no nodeToRestore was found, focus the first element in the nearest\n                        // ancestor scope that is still in the tree.\n                        treeNode = clonedTree.getTreeNode(scopeRef);\n                        while(treeNode){\n                            if (treeNode.scopeRef && treeNode.scopeRef.current && $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {\n                                $9bf71ea28793e738$var$focusFirstInScope(treeNode.scopeRef.current, true);\n                                return;\n                            }\n                            treeNode = treeNode.parent;\n                        }\n                    }\n                });\n            }\n        };\n    }, [\n        scopeRef,\n        restoreFocus\n    ]);\n}\nfunction $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, opts, scope) {\n    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR : $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR;\n    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {\n        acceptNode (node) {\n            var _opts_from;\n            // Skip nodes inside the starting node.\n            if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node)) return NodeFilter.FILTER_REJECT;\n            if (node.matches(selector) && (0, $645f2e67b85a24c9$export$e989c0fffaa6b27a)(node) && (!scope || $9bf71ea28793e738$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;\n            return NodeFilter.FILTER_SKIP;\n        }\n    });\n    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;\n    return walker;\n}\nfunction $9bf71ea28793e738$export$c5251b9e124bf29(ref, defaultOptions = {}) {\n    return {\n        focusNext (opts = {}) {\n            let root = ref.current;\n            if (!root) return null;\n            let { from: from, tabbable: tabbable = defaultOptions.tabbable, wrap: wrap = defaultOptions.wrap, accept: accept = defaultOptions.accept } = opts;\n            let node = from || document.activeElement;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            if (root.contains(node)) walker.currentNode = node;\n            let nextNode = walker.nextNode();\n            if (!nextNode && wrap) {\n                walker.currentNode = root;\n                nextNode = walker.nextNode();\n            }\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusPrevious (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return null;\n            let { from: from, tabbable: tabbable = defaultOptions.tabbable, wrap: wrap = defaultOptions.wrap, accept: accept = defaultOptions.accept } = opts;\n            let node = from || document.activeElement;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            if (root.contains(node)) walker.currentNode = node;\n            else {\n                let next = $9bf71ea28793e738$var$last(walker);\n                if (next) $9bf71ea28793e738$var$focusElement(next, true);\n                return next !== null && next !== void 0 ? next : null;\n            }\n            let previousNode = walker.previousNode();\n            if (!previousNode && wrap) {\n                walker.currentNode = root;\n                let lastNode = $9bf71ea28793e738$var$last(walker);\n                if (!lastNode) // couldn't wrap\n                return null;\n                previousNode = lastNode;\n            }\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode !== null && previousNode !== void 0 ? previousNode : null;\n        },\n        focusFirst (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return null;\n            let { tabbable: tabbable = defaultOptions.tabbable, accept: accept = defaultOptions.accept } = opts;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            let nextNode = walker.nextNode();\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusLast (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return null;\n            let { tabbable: tabbable = defaultOptions.tabbable, accept: accept = defaultOptions.accept } = opts;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            let next = $9bf71ea28793e738$var$last(walker);\n            if (next) $9bf71ea28793e738$var$focusElement(next, true);\n            return next !== null && next !== void 0 ? next : null;\n        }\n    };\n}\nfunction $9bf71ea28793e738$var$last(walker) {\n    let next = undefined;\n    let last;\n    do {\n        last = walker.lastChild();\n        if (last) next = last;\n    }while (last);\n    return next;\n}\nclass $9bf71ea28793e738$var$Tree {\n    get size() {\n        return this.fastMap.size;\n    }\n    getTreeNode(data) {\n        return this.fastMap.get(data);\n    }\n    addTreeNode(scopeRef, parent, nodeToRestore) {\n        let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);\n        if (!parentNode) return;\n        let node = new $9bf71ea28793e738$var$TreeNode({\n            scopeRef: scopeRef\n        });\n        parentNode.addChild(node);\n        node.parent = parentNode;\n        this.fastMap.set(scopeRef, node);\n        if (nodeToRestore) node.nodeToRestore = nodeToRestore;\n    }\n    addNode(node) {\n        this.fastMap.set(node.scopeRef, node);\n    }\n    removeTreeNode(scopeRef) {\n        // never remove the root\n        if (scopeRef === null) return;\n        let node = this.fastMap.get(scopeRef);\n        if (!node) return;\n        let parentNode = node.parent;\n        // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing\n        // if we are, then replace the siblings restore with the restore from the scope we're removing\n        for (let current of this.traverse())if (current !== node && node.nodeToRestore && current.nodeToRestore && node.scopeRef && node.scopeRef.current && $9bf71ea28793e738$var$isElementInScope(current.nodeToRestore, node.scopeRef.current)) current.nodeToRestore = node.nodeToRestore;\n        let children = node.children;\n        if (parentNode) {\n            parentNode.removeChild(node);\n            if (children.size > 0) children.forEach((child)=>parentNode && parentNode.addChild(child));\n        }\n        this.fastMap.delete(node.scopeRef);\n    }\n    // Pre Order Depth First\n    *traverse(node = this.root) {\n        if (node.scopeRef != null) yield node;\n        if (node.children.size > 0) for (let child of node.children)yield* this.traverse(child);\n    }\n    clone() {\n        var _node_parent;\n        let newTree = new $9bf71ea28793e738$var$Tree();\n        var _node_parent_scopeRef;\n        for (let node of this.traverse())newTree.addTreeNode(node.scopeRef, (_node_parent_scopeRef = (_node_parent = node.parent) === null || _node_parent === void 0 ? void 0 : _node_parent.scopeRef) !== null && _node_parent_scopeRef !== void 0 ? _node_parent_scopeRef : null, node.nodeToRestore);\n        return newTree;\n    }\n    constructor(){\n        this.fastMap = new Map();\n        this.root = new $9bf71ea28793e738$var$TreeNode({\n            scopeRef: null\n        });\n        this.fastMap.set(null, this.root);\n    }\n}\nclass $9bf71ea28793e738$var$TreeNode {\n    addChild(node) {\n        this.children.add(node);\n        node.parent = this;\n    }\n    removeChild(node) {\n        this.children.delete(node);\n        node.parent = undefined;\n    }\n    constructor(props){\n        this.children = new Set();\n        this.contain = false;\n        this.scopeRef = props.scopeRef;\n    }\n}\nlet $9bf71ea28793e738$export$d06fae2ee68b101e = new $9bf71ea28793e738$var$Tree();\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\n\nfunction $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {\n    let { autoFocus: autoFocus = false, isTextInput: isTextInput, within: within } = props;\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isFocused: false,\n        isFocusVisible: autoFocus || (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__.isFocusVisible)()\n    });\n    let [isFocused, setFocused] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isFocusVisibleState, setFocusVisible] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>state.current.isFocused && state.current.isFocusVisible);\n    let updateState = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);\n    let onFocusChange = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((isFocused)=>{\n        state.current.isFocused = isFocused;\n        setFocused(isFocused);\n        updateState();\n    }, [\n        updateState\n    ]);\n    (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__.useFocusVisibleListener)((isFocusVisible)=>{\n        state.current.isFocusVisible = isFocusVisible;\n        updateState();\n    }, [], {\n        isTextInput: isTextInput\n    });\n    let { focusProps: focusProps } = (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__.useFocus)({\n        isDisabled: within,\n        onFocusChange: onFocusChange\n    });\n    let { focusWithinProps: focusWithinProps } = (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__.useFocusWithin)({\n        isDisabled: !within,\n        onFocusWithinChange: onFocusChange\n    });\n    return {\n        isFocused: isFocused,\n        isFocusVisible: isFocusVisibleState,\n        focusProps: within ? focusWithinProps : focusProps\n    };\n}\n\n\nfunction $907718708eab68af$export$1a38b4ad7f578e1d(props) {\n    let { children: children, focusClass: focusClass, focusRingClass: focusRingClass } = props;\n    let { isFocused: isFocused, isFocusVisible: isFocusVisible, focusProps: focusProps } = (0, $f7dceffc5ad7768b$export$4e328f61c538687f)(props);\n    let child = (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.only(children);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).cloneElement(child, (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.mergeProps)(child.props, {\n        ...focusProps,\n        className: (0, clsx__WEBPACK_IMPORTED_MODULE_1__)({\n            [focusClass || \"\"]: isFocused,\n            [focusRingClass || \"\"]: isFocusVisible\n        })\n    }));\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\nlet $e6afbd83fe6ebbd2$var$FocusableContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext(null);\nfunction $e6afbd83fe6ebbd2$var$useFocusableContext(ref) {\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($e6afbd83fe6ebbd2$var$FocusableContext) || {};\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useSyncRef)(context, ref);\n    // eslint-disable-next-line\n    let { ref: _, ...otherProps } = context;\n    return otherProps;\n}\n/**\n * Provides DOM props to the nearest focusable child.\n */ function $e6afbd83fe6ebbd2$var$FocusableProvider(props, ref) {\n    let { children: children, ...otherProps } = props;\n    let objRef = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useObjectRef)(ref);\n    let context = {\n        ...otherProps,\n        ref: objRef\n    };\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($e6afbd83fe6ebbd2$var$FocusableContext.Provider, {\n        value: context\n    }, children);\n}\nlet $e6afbd83fe6ebbd2$export$13f3202a3e5ddd5 = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).forwardRef($e6afbd83fe6ebbd2$var$FocusableProvider);\nfunction $e6afbd83fe6ebbd2$export$4c014de7c8940b4c(props, domRef) {\n    let { focusProps: focusProps } = (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__.useFocus)(props);\n    let { keyboardProps: keyboardProps } = (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__.useKeyboard)(props);\n    let interactions = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.mergeProps)(focusProps, keyboardProps);\n    let domProps = $e6afbd83fe6ebbd2$var$useFocusableContext(domRef);\n    let interactionProps = props.isDisabled ? {} : domProps;\n    let autoFocusRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(props.autoFocus);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (autoFocusRef.current && domRef.current) (0, $6a99195332edec8b$export$80f3e147d781571c)(domRef.current);\n        autoFocusRef.current = false;\n    }, [\n        domRef\n    ]);\n    return {\n        focusableProps: (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.mergeProps)({\n            ...interactions,\n            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined\n        }, interactionProps)\n    };\n}\n\n\n\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nfunction $83013635b024ae3d$export$eac1895992b9f3d6(ref, options) {\n    let isDisabled = options === null || options === void 0 ? void 0 : options.isDisabled;\n    let [hasTabbableChild, setHasTabbableChild] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        if ((ref === null || ref === void 0 ? void 0 : ref.current) && !isDisabled) {\n            let update = ()=>{\n                if (ref.current) {\n                    let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref.current, {\n                        tabbable: true\n                    });\n                    setHasTabbableChild(!!walker.nextNode());\n                }\n            };\n            update();\n            // Update when new elements are inserted, or the tabIndex/disabled attribute updates.\n            let observer = new MutationObserver(update);\n            observer.observe(ref.current, {\n                subtree: true,\n                childList: true,\n                attributes: true,\n                attributeFilter: [\n                    \"tabIndex\",\n                    \"disabled\"\n                ]\n            });\n            return ()=>{\n                // Disconnect mutation observer when a React update occurs on the top-level component\n                // so we update synchronously after re-rendering. Otherwise React will emit act warnings\n                // in tests since mutation observers fire asynchronously. The mutation observer is necessary\n                // so we also update if a child component re-renders and adds/removes something tabbable.\n                observer.disconnect();\n            };\n        }\n    });\n    return isDisabled ? false : hasTabbableChild;\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL2ZvY3VzL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdU47QUFDb0U7QUFDbUI7QUFDL1E7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEVBQTZCO0FBQ3pDO0FBQ0EsWUFBWSxpRUFBeUI7QUFDckM7QUFDQSxpR0FBaUcsb0VBQTRCO0FBQzdILFNBQVM7QUFDVCxNQUFNLFNBQVMsb0VBQTRCO0FBQzNDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJDQUEyQztBQUNyRDtBQUNBO0FBQ0EsZ0JBQWdCLHFDQUFxQztBQUNyRCxjQUFjLDJEQUEyRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQSw2REFBNkQsa0NBQVk7QUFDekU7QUFDQTtBQUNBLFVBQVUseUZBQXlGO0FBQ25HLHVCQUF1Qix5Q0FBYTtBQUNwQyxxQkFBcUIseUNBQWE7QUFDbEMsdUJBQXVCLHlDQUFhO0FBQ3BDLFVBQVUseUJBQXlCLE1BQU0sNkNBQWlCO0FBQzFEO0FBQ0EsbUJBQW1CLDBDQUFjO0FBQ2pDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRLDhEQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Es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LWFyaWEvZm9jdXMvZGlzdC9pbXBvcnQubWpzPzZhY2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICQ2bmZGQyRyZWFjdCwge3VzZVJlZiBhcyAkNm5mRkMkdXNlUmVmLCB1c2VDb250ZXh0IGFzICQ2bmZGQyR1c2VDb250ZXh0LCB1c2VNZW1vIGFzICQ2bmZGQyR1c2VNZW1vLCB1c2VFZmZlY3QgYXMgJDZuZkZDJHVzZUVmZmVjdCwgdXNlU3RhdGUgYXMgJDZuZkZDJHVzZVN0YXRlLCB1c2VDYWxsYmFjayBhcyAkNm5mRkMkdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHt1c2VMYXlvdXRFZmZlY3QgYXMgJDZuZkZDJHVzZUxheW91dEVmZmVjdCwgcnVuQWZ0ZXJUcmFuc2l0aW9uIGFzICQ2bmZGQyRydW5BZnRlclRyYW5zaXRpb24sIGZvY3VzV2l0aG91dFNjcm9sbGluZyBhcyAkNm5mRkMkZm9jdXNXaXRob3V0U2Nyb2xsaW5nLCBtZXJnZVByb3BzIGFzICQ2bmZGQyRtZXJnZVByb3BzLCB1c2VTeW5jUmVmIGFzICQ2bmZGQyR1c2VTeW5jUmVmLCB1c2VPYmplY3RSZWYgYXMgJDZuZkZDJHVzZU9iamVjdFJlZn0gZnJvbSBcIkByZWFjdC1hcmlhL3V0aWxzXCI7XG5pbXBvcnQge2dldEludGVyYWN0aW9uTW9kYWxpdHkgYXMgJDZuZkZDJGdldEludGVyYWN0aW9uTW9kYWxpdHksIGlzRm9jdXNWaXNpYmxlIGFzICQ2bmZGQyRpc0ZvY3VzVmlzaWJsZSwgdXNlRm9jdXNWaXNpYmxlTGlzdGVuZXIgYXMgJDZuZkZDJHVzZUZvY3VzVmlzaWJsZUxpc3RlbmVyLCB1c2VGb2N1cyBhcyAkNm5mRkMkdXNlRm9jdXMsIHVzZUZvY3VzV2l0aGluIGFzICQ2bmZGQyR1c2VGb2N1c1dpdGhpbiwgdXNlS2V5Ym9hcmQgYXMgJDZuZkZDJHVzZUtleWJvYXJkfSBmcm9tIFwiQHJlYWN0LWFyaWEvaW50ZXJhY3Rpb25zXCI7XG5pbXBvcnQgJDZuZkZDJGNsc3ggZnJvbSBcImNsc3hcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuZnVuY3Rpb24gJDZhOTkxOTUzMzJlZGVjOGIkZXhwb3J0JDgwZjNlMTQ3ZDc4MTU3MWMoZWxlbWVudCkge1xuICAgIC8vIElmIHRoZSB1c2VyIGlzIGludGVyYWN0aW5nIHdpdGggYSB2aXJ0dWFsIGN1cnNvciwgZS5nLiBzY3JlZW4gcmVhZGVyLCB0aGVuXG4gICAgLy8gd2FpdCB1bnRpbCBhZnRlciBhbnkgYW5pbWF0ZWQgdHJhbnNpdGlvbnMgdGhhdCBhcmUgY3VycmVudGx5IG9jY3VycmluZyBvblxuICAgIC8vIHRoZSBwYWdlIGJlZm9yZSBzaGlmdGluZyBmb2N1cy4gVGhpcyBhdm9pZHMgaXNzdWVzIHdpdGggVm9pY2VPdmVyIG9uIGlPU1xuICAgIC8vIGNhdXNpbmcgdGhlIHBhZ2UgdG8gc2Nyb2xsIHdoZW4gbW92aW5nIGZvY3VzIGlmIHRoZSBlbGVtZW50IGlzIHRyYW5zaXRpb25pbmdcbiAgICAvLyBmcm9tIG9mZiB0aGUgc2NyZWVuLlxuICAgIGlmICgoMCwgJDZuZkZDJGdldEludGVyYWN0aW9uTW9kYWxpdHkpKCkgPT09IFwidmlydHVhbFwiKSB7XG4gICAgICAgIGxldCBsYXN0Rm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAoMCwgJDZuZkZDJHJ1bkFmdGVyVHJhbnNpdGlvbikoKCk9PntcbiAgICAgICAgICAgIC8vIElmIGZvY3VzIGRpZCBub3QgbW92ZSBhbmQgdGhlIGVsZW1lbnQgaXMgc3RpbGwgaW4gdGhlIGRvY3VtZW50LCBmb2N1cyBpdC5cbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBsYXN0Rm9jdXNlZEVsZW1lbnQgJiYgZG9jdW1lbnQuY29udGFpbnMoZWxlbWVudCkpICgwLCAkNm5mRkMkZm9jdXNXaXRob3V0U2Nyb2xsaW5nKShlbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlICgwLCAkNm5mRkMkZm9jdXNXaXRob3V0U2Nyb2xsaW5nKShlbGVtZW50KTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJDY0NWYyZTY3Yjg1YTI0YzkkdmFyJGlzU3R5bGVWaXNpYmxlKGVsZW1lbnQpIHtcbiAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpICYmICEoZWxlbWVudCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgZGlzcGxheTogZGlzcGxheSwgdmlzaWJpbGl0eTogdmlzaWJpbGl0eSB9ID0gZWxlbWVudC5zdHlsZTtcbiAgICBsZXQgaXNWaXNpYmxlID0gZGlzcGxheSAhPT0gXCJub25lXCIgJiYgdmlzaWJpbGl0eSAhPT0gXCJoaWRkZW5cIiAmJiB2aXNpYmlsaXR5ICE9PSBcImNvbGxhcHNlXCI7XG4gICAgaWYgKGlzVmlzaWJsZSkge1xuICAgICAgICBjb25zdCB7IGdldENvbXB1dGVkU3R5bGU6IGdldENvbXB1dGVkU3R5bGUgfSA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgICAgbGV0IHsgZGlzcGxheTogY29tcHV0ZWREaXNwbGF5LCB2aXNpYmlsaXR5OiBjb21wdXRlZFZpc2liaWxpdHkgfSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgICAgIGlzVmlzaWJsZSA9IGNvbXB1dGVkRGlzcGxheSAhPT0gXCJub25lXCIgJiYgY29tcHV0ZWRWaXNpYmlsaXR5ICE9PSBcImhpZGRlblwiICYmIGNvbXB1dGVkVmlzaWJpbGl0eSAhPT0gXCJjb2xsYXBzZVwiO1xuICAgIH1cbiAgICByZXR1cm4gaXNWaXNpYmxlO1xufVxuZnVuY3Rpb24gJDY0NWYyZTY3Yjg1YTI0YzkkdmFyJGlzQXR0cmlidXRlVmlzaWJsZShlbGVtZW50LCBjaGlsZEVsZW1lbnQpIHtcbiAgICByZXR1cm4gIWVsZW1lbnQuaGFzQXR0cmlidXRlKFwiaGlkZGVuXCIpICYmIChlbGVtZW50Lm5vZGVOYW1lID09PSBcIkRFVEFJTFNcIiAmJiBjaGlsZEVsZW1lbnQgJiYgY2hpbGRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIlNVTU1BUllcIiA/IGVsZW1lbnQuaGFzQXR0cmlidXRlKFwib3BlblwiKSA6IHRydWUpO1xufVxuZnVuY3Rpb24gJDY0NWYyZTY3Yjg1YTI0YzkkZXhwb3J0JGU5ODljMGZmZmFhNmIyN2EoZWxlbWVudCwgY2hpbGRFbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUgIT09IFwiI2NvbW1lbnRcIiAmJiAkNjQ1ZjJlNjdiODVhMjRjOSR2YXIkaXNTdHlsZVZpc2libGUoZWxlbWVudCkgJiYgJDY0NWYyZTY3Yjg1YTI0YzkkdmFyJGlzQXR0cmlidXRlVmlzaWJsZShlbGVtZW50LCBjaGlsZEVsZW1lbnQpICYmICghZWxlbWVudC5wYXJlbnRFbGVtZW50IHx8ICQ2NDVmMmU2N2I4NWEyNGM5JGV4cG9ydCRlOTg5YzBmZmZhYTZiMjdhKGVsZW1lbnQucGFyZW50RWxlbWVudCwgZWxlbWVudCkpO1xufVxuXG5cblxuXG5jb25zdCAkOWJmNzFlYTI4NzkzZTczOCR2YXIkRm9jdXNDb250ZXh0ID0gLyojX19QVVJFX18qLyAoMCwgJDZuZkZDJHJlYWN0KS5jcmVhdGVDb250ZXh0KG51bGwpO1xubGV0ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSA9IG51bGw7XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMjBlNDAyODk2NDFmYmJiNihwcm9wcykge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgY29udGFpbjogY29udGFpbiwgcmVzdG9yZUZvY3VzOiByZXN0b3JlRm9jdXMsIGF1dG9Gb2N1czogYXV0b0ZvY3VzIH0gPSBwcm9wcztcbiAgICBsZXQgc3RhcnRSZWYgPSAoMCwgJDZuZkZDJHVzZVJlZikobnVsbCk7XG4gICAgbGV0IGVuZFJlZiA9ICgwLCAkNm5mRkMkdXNlUmVmKShudWxsKTtcbiAgICBsZXQgc2NvcGVSZWYgPSAoMCwgJDZuZkZDJHVzZVJlZikoW10pO1xuICAgIGxldCB7IHBhcmVudE5vZGU6IHBhcmVudE5vZGUgfSA9ICgwLCAkNm5mRkMkdXNlQ29udGV4dCkoJDliZjcxZWEyODc5M2U3MzgkdmFyJEZvY3VzQ29udGV4dCkgfHwge307XG4gICAgLy8gQ3JlYXRlIGEgdHJlZSBub2RlIGhlcmUgc28gd2UgY2FuIGFkZCBjaGlsZHJlbiB0byBpdCBldmVuIGJlZm9yZSBpdCBpcyBhZGRlZCB0byB0aGUgdHJlZS5cbiAgICBsZXQgbm9kZSA9ICgwLCAkNm5mRkMkdXNlTWVtbykoKCk9Pm5ldyAkOWJmNzFlYTI4NzkzZTczOCR2YXIkVHJlZU5vZGUoe1xuICAgICAgICAgICAgc2NvcGVSZWY6IHNjb3BlUmVmXG4gICAgICAgIH0pLCBbXG4gICAgICAgIHNjb3BlUmVmXG4gICAgXSk7XG4gICAgKDAsICQ2bmZGQyR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIC8vIElmIGEgbmV3IHNjb3BlIG1vdW50cyBvdXRzaWRlIHRoZSBhY3RpdmUgc2NvcGUsIChlLmcuIERpYWxvZ0NvbnRhaW5lciBsYXVuY2hlZCBmcm9tIGEgbWVudSksXG4gICAgICAgIC8vIHVzZSB0aGUgYWN0aXZlIHNjb3BlIGFzIHRoZSBwYXJlbnQgaW5zdGVhZCBvZiB0aGUgcGFyZW50IGZyb20gY29udGV4dC4gTGF5b3V0IGVmZmVjdHMgcnVuIGJvdHRvbVxuICAgICAgICAvLyB1cCwgc28gaWYgdGhlIHBhcmVudCBpcyBub3QgeWV0IGFkZGVkIHRvIHRoZSB0cmVlLCBkb24ndCBkbyB0aGlzLiBPbmx5IHRoZSBvdXRlci1tb3N0IEZvY3VzU2NvcGVcbiAgICAgICAgLy8gdGhhdCBpcyBiZWluZyBhZGRlZCBzaG91bGQgZ2V0IHRoZSBhY3RpdmVTY29wZSBhcyBpdHMgcGFyZW50LlxuICAgICAgICBsZXQgcGFyZW50ID0gcGFyZW50Tm9kZSB8fCAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5yb290O1xuICAgICAgICBpZiAoJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUuZ2V0VHJlZU5vZGUocGFyZW50LnNjb3BlUmVmKSAmJiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUgJiYgISQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0FuY2VzdG9yU2NvcGUoJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlLCBwYXJlbnQuc2NvcGVSZWYpKSB7XG4gICAgICAgICAgICBsZXQgYWN0aXZlTm9kZSA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmdldFRyZWVOb2RlKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSk7XG4gICAgICAgICAgICBpZiAoYWN0aXZlTm9kZSkgcGFyZW50ID0gYWN0aXZlTm9kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIG5vZGUgdG8gdGhlIHBhcmVudCwgYW5kIHRvIHRoZSB0cmVlLlxuICAgICAgICBwYXJlbnQuYWRkQ2hpbGQobm9kZSk7XG4gICAgICAgICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmFkZE5vZGUobm9kZSk7XG4gICAgfSwgW1xuICAgICAgICBub2RlLFxuICAgICAgICBwYXJlbnROb2RlXG4gICAgXSk7XG4gICAgKDAsICQ2bmZGQyR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCBub2RlID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUuZ2V0VHJlZU5vZGUoc2NvcGVSZWYpO1xuICAgICAgICBpZiAobm9kZSkgbm9kZS5jb250YWluID0gISFjb250YWluO1xuICAgIH0sIFtcbiAgICAgICAgY29udGFpblxuICAgIF0pO1xuICAgICgwLCAkNm5mRkMkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICB2YXIgX3N0YXJ0UmVmX2N1cnJlbnQ7XG4gICAgICAgIC8vIEZpbmQgYWxsIHJlbmRlcmVkIG5vZGVzIGJldHdlZW4gdGhlIHNlbnRpbmVscyBhbmQgYWRkIHRoZW0gdG8gdGhlIHNjb3BlLlxuICAgICAgICBsZXQgbm9kZSA9IChfc3RhcnRSZWZfY3VycmVudCA9IHN0YXJ0UmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9zdGFydFJlZl9jdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhcnRSZWZfY3VycmVudC5uZXh0U2libGluZztcbiAgICAgICAgbGV0IG5vZGVzID0gW107XG4gICAgICAgIHdoaWxlKG5vZGUgJiYgbm9kZSAhPT0gZW5kUmVmLmN1cnJlbnQpe1xuICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIHNjb3BlUmVmLmN1cnJlbnQgPSBub2RlcztcbiAgICB9LCBbXG4gICAgICAgIGNoaWxkcmVuXG4gICAgXSk7XG4gICAgJDliZjcxZWEyODc5M2U3MzgkdmFyJHVzZUFjdGl2ZVNjb3BlVHJhY2tlcihzY29wZVJlZiwgcmVzdG9yZUZvY3VzLCBjb250YWluKTtcbiAgICAkOWJmNzFlYTI4NzkzZTczOCR2YXIkdXNlRm9jdXNDb250YWlubWVudChzY29wZVJlZiwgY29udGFpbik7XG4gICAgJDliZjcxZWEyODc5M2U3MzgkdmFyJHVzZVJlc3RvcmVGb2N1cyhzY29wZVJlZiwgcmVzdG9yZUZvY3VzLCBjb250YWluKTtcbiAgICAkOWJmNzFlYTI4NzkzZTczOCR2YXIkdXNlQXV0b0ZvY3VzKHNjb3BlUmVmLCBhdXRvRm9jdXMpO1xuICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgYW4gZWZmZWN0IHNvIHRoYXQgYWN0aXZlU2NvcGUgaXMgdXBkYXRlZCBhZnRlciB0aGUgRm9jdXNTY29wZSB0cmVlIGlzIGNvbXBsZXRlLlxuICAgIC8vIEl0IGNhbm5vdCBiZSBhIHVzZUxheW91dEVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgb2YgdGhpcyBub2RlIGhhc24ndCBiZWVuIGF0dGFjaGVkIGluIHRoZSB0cmVlIHlldC5cbiAgICAoMCwgJDZuZkZDJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgbGV0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBsZXQgc2NvcGUgPSBudWxsO1xuICAgICAgICBpZiAoJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUoYWN0aXZlRWxlbWVudCwgc2NvcGVSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdHJhdmVyc2UgdGhlIGZvY3VzU2NvcGUgdHJlZSBhbmQgZmluZCB0aGUgYm90dG9tIG1vc3Qgc2NvcGUgdGhhdFxuICAgICAgICAgICAgLy8gY29udGFpbnMgdGhlIGFjdGl2ZSBlbGVtZW50IGFuZCBzZXQgdGhhdCBhcyB0aGUgYWN0aXZlU2NvcGUuXG4gICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLnRyYXZlcnNlKCkpaWYgKG5vZGUuc2NvcGVSZWYgJiYgJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUoYWN0aXZlRWxlbWVudCwgbm9kZS5zY29wZVJlZi5jdXJyZW50KSkgc2NvcGUgPSBub2RlO1xuICAgICAgICAgICAgaWYgKHNjb3BlID09PSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5nZXRUcmVlTm9kZShzY29wZVJlZikpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSA9IHNjb3BlLnNjb3BlUmVmO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBzY29wZVJlZlxuICAgIF0pO1xuICAgIC8vIFRoaXMgbGF5b3V0IGVmZmVjdCBjbGVhbnVwIGlzIHNvIHRoYXQgdGhlIHRyZWUgbm9kZSBpcyByZW1vdmVkIHN5bmNocm9ub3VzbHkgd2l0aCByZWFjdCBiZWZvcmUgdGhlIFJBRlxuICAgIC8vIGluIHVzZVJlc3RvcmVGb2N1cyBjbGVhbnVwIHJ1bnMuXG4gICAgKDAsICQ2bmZGQyR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgdmFyIF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZV9wYXJlbnQsIF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZTtcbiAgICAgICAgICAgIHZhciBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGVfcGFyZW50X3Njb3BlUmVmO1xuICAgICAgICAgICAgLy8gU2NvcGUgbWF5IGhhdmUgYmVlbiByZS1wYXJlbnRlZC5cbiAgICAgICAgICAgIGxldCBwYXJlbnRTY29wZSA9IChfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGVfcGFyZW50X3Njb3BlUmVmID0gKF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZSA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmdldFRyZWVOb2RlKHNjb3BlUmVmKSkgPT09IG51bGwgfHwgX2ZvY3VzU2NvcGVUcmVlX2dldFRyZWVOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2ZvY3VzU2NvcGVUcmVlX2dldFRyZWVOb2RlX3BhcmVudCA9IF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZS5wYXJlbnQpID09PSBudWxsIHx8IF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZV9wYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZV9wYXJlbnQuc2NvcGVSZWYpICE9PSBudWxsICYmIF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZV9wYXJlbnRfc2NvcGVSZWYgIT09IHZvaWQgMCA/IF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZV9wYXJlbnRfc2NvcGVSZWYgOiBudWxsO1xuICAgICAgICAgICAgaWYgKChzY29wZVJlZiA9PT0gJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlIHx8ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0FuY2VzdG9yU2NvcGUoc2NvcGVSZWYsICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSkpICYmICghcGFyZW50U2NvcGUgfHwgJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUuZ2V0VHJlZU5vZGUocGFyZW50U2NvcGUpKSkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlID0gcGFyZW50U2NvcGU7XG4gICAgICAgICAgICAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5yZW1vdmVUcmVlTm9kZShzY29wZVJlZik7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBzY29wZVJlZlxuICAgIF0pO1xuICAgIGxldCBmb2N1c01hbmFnZXIgPSAoMCwgJDZuZkZDJHVzZU1lbW8pKCgpPT4kOWJmNzFlYTI4NzkzZTczOCR2YXIkY3JlYXRlRm9jdXNNYW5hZ2VyRm9yU2NvcGUoc2NvcGVSZWYpLCBbXSk7XG4gICAgbGV0IHZhbHVlID0gKDAsICQ2bmZGQyR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIGZvY3VzTWFuYWdlcjogZm9jdXNNYW5hZ2VyLFxuICAgICAgICAgICAgcGFyZW50Tm9kZTogbm9kZVxuICAgICAgICB9KSwgW1xuICAgICAgICBub2RlLFxuICAgICAgICBmb2N1c01hbmFnZXJcbiAgICBdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJDZuZkZDJHJlYWN0KS5jcmVhdGVFbGVtZW50KCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRGb2N1c0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSwgLyojX19QVVJFX18qLyAoMCwgJDZuZkZDJHJlYWN0KS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIFwiZGF0YS1mb2N1cy1zY29wZS1zdGFydFwiOiB0cnVlLFxuICAgICAgICBoaWRkZW46IHRydWUsXG4gICAgICAgIHJlZjogc3RhcnRSZWZcbiAgICB9KSwgY2hpbGRyZW4sIC8qI19fUFVSRV9fKi8gKDAsICQ2bmZGQyRyZWFjdCkuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBcImRhdGEtZm9jdXMtc2NvcGUtZW5kXCI6IHRydWUsXG4gICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgcmVmOiBlbmRSZWZcbiAgICB9KSk7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMTBjNTE2OTc1NWNlN2JkNygpIHtcbiAgICB2YXIgX3VzZUNvbnRleHQ7XG4gICAgcmV0dXJuIChfdXNlQ29udGV4dCA9ICgwLCAkNm5mRkMkdXNlQ29udGV4dCkoJDliZjcxZWEyODc5M2U3MzgkdmFyJEZvY3VzQ29udGV4dCkpID09PSBudWxsIHx8IF91c2VDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdXNlQ29udGV4dC5mb2N1c01hbmFnZXI7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkY3JlYXRlRm9jdXNNYW5hZ2VyRm9yU2NvcGUoc2NvcGVSZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb2N1c05leHQgKG9wdHMgPSB7fSkge1xuICAgICAgICAgICAgbGV0IHNjb3BlID0gc2NvcGVSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGxldCB7IGZyb206IGZyb20sIHRhYmJhYmxlOiB0YWJiYWJsZSwgd3JhcDogd3JhcCwgYWNjZXB0OiBhY2NlcHQgfSA9IG9wdHM7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGZyb20gfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGxldCBzZW50aW5lbCA9IHNjb3BlWzBdLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICBsZXQgc2NvcGVSb290ID0gJDliZjcxZWEyODc5M2U3MzgkdmFyJGdldFNjb3BlUm9vdChzY29wZSk7XG4gICAgICAgICAgICBsZXQgd2Fsa2VyID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDJkNmVjOGZjMzc1Y2VhZmEoc2NvcGVSb290LCB7XG4gICAgICAgICAgICAgICAgdGFiYmFibGU6IHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGFjY2VwdDogYWNjZXB0XG4gICAgICAgICAgICB9LCBzY29wZSk7XG4gICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5TY29wZShub2RlLCBzY29wZSkgPyBub2RlIDogc2VudGluZWw7XG4gICAgICAgICAgICBsZXQgbmV4dE5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIGlmICghbmV4dE5vZGUgJiYgd3JhcCkge1xuICAgICAgICAgICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IHNlbnRpbmVsO1xuICAgICAgICAgICAgICAgIG5leHROb2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dE5vZGUpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0VsZW1lbnQobmV4dE5vZGUsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHROb2RlO1xuICAgICAgICB9LFxuICAgICAgICBmb2N1c1ByZXZpb3VzIChvcHRzID0ge30pIHtcbiAgICAgICAgICAgIGxldCBzY29wZSA9IHNjb3BlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBsZXQgeyBmcm9tOiBmcm9tLCB0YWJiYWJsZTogdGFiYmFibGUsIHdyYXA6IHdyYXAsIGFjY2VwdDogYWNjZXB0IH0gPSBvcHRzO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBmcm9tIHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBsZXQgc2VudGluZWwgPSBzY29wZVtzY29wZS5sZW5ndGggLSAxXS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICBsZXQgc2NvcGVSb290ID0gJDliZjcxZWEyODc5M2U3MzgkdmFyJGdldFNjb3BlUm9vdChzY29wZSk7XG4gICAgICAgICAgICBsZXQgd2Fsa2VyID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDJkNmVjOGZjMzc1Y2VhZmEoc2NvcGVSb290LCB7XG4gICAgICAgICAgICAgICAgdGFiYmFibGU6IHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGFjY2VwdDogYWNjZXB0XG4gICAgICAgICAgICB9LCBzY29wZSk7XG4gICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5TY29wZShub2RlLCBzY29wZSkgPyBub2RlIDogc2VudGluZWw7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNOb2RlID0gd2Fsa2VyLnByZXZpb3VzTm9kZSgpO1xuICAgICAgICAgICAgaWYgKCFwcmV2aW91c05vZGUgJiYgd3JhcCkge1xuICAgICAgICAgICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IHNlbnRpbmVsO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHdhbGtlci5wcmV2aW91c05vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2aW91c05vZGUpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0VsZW1lbnQocHJldmlvdXNOb2RlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c05vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzRmlyc3QgKG9wdHMgPSB7fSkge1xuICAgICAgICAgICAgbGV0IHNjb3BlID0gc2NvcGVSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGxldCB7IHRhYmJhYmxlOiB0YWJiYWJsZSwgYWNjZXB0OiBhY2NlcHQgfSA9IG9wdHM7XG4gICAgICAgICAgICBsZXQgc2NvcGVSb290ID0gJDliZjcxZWEyODc5M2U3MzgkdmFyJGdldFNjb3BlUm9vdChzY29wZSk7XG4gICAgICAgICAgICBsZXQgd2Fsa2VyID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDJkNmVjOGZjMzc1Y2VhZmEoc2NvcGVSb290LCB7XG4gICAgICAgICAgICAgICAgdGFiYmFibGU6IHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGFjY2VwdDogYWNjZXB0XG4gICAgICAgICAgICB9LCBzY29wZSk7XG4gICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBzY29wZVswXS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgbGV0IG5leHROb2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICBpZiAobmV4dE5vZGUpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0VsZW1lbnQobmV4dE5vZGUsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHROb2RlO1xuICAgICAgICB9LFxuICAgICAgICBmb2N1c0xhc3QgKG9wdHMgPSB7fSkge1xuICAgICAgICAgICAgbGV0IHNjb3BlID0gc2NvcGVSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGxldCB7IHRhYmJhYmxlOiB0YWJiYWJsZSwgYWNjZXB0OiBhY2NlcHQgfSA9IG9wdHM7XG4gICAgICAgICAgICBsZXQgc2NvcGVSb290ID0gJDliZjcxZWEyODc5M2U3MzgkdmFyJGdldFNjb3BlUm9vdChzY29wZSk7XG4gICAgICAgICAgICBsZXQgd2Fsa2VyID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDJkNmVjOGZjMzc1Y2VhZmEoc2NvcGVSb290LCB7XG4gICAgICAgICAgICAgICAgdGFiYmFibGU6IHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGFjY2VwdDogYWNjZXB0XG4gICAgICAgICAgICB9LCBzY29wZSk7XG4gICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBzY29wZVtzY29wZS5sZW5ndGggLSAxXS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNOb2RlID0gd2Fsa2VyLnByZXZpb3VzTm9kZSgpO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzTm9kZSkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudChwcmV2aW91c05vZGUsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzTm9kZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNhYmxlRWxlbWVudHMgPSBbXG4gICAgXCJpbnB1dDpub3QoW2Rpc2FibGVkXSk6bm90KFt0eXBlPWhpZGRlbl0pXCIsXG4gICAgXCJzZWxlY3Q6bm90KFtkaXNhYmxlZF0pXCIsXG4gICAgXCJ0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSlcIixcbiAgICBcImJ1dHRvbjpub3QoW2Rpc2FibGVkXSlcIixcbiAgICBcImFbaHJlZl1cIixcbiAgICBcImFyZWFbaHJlZl1cIixcbiAgICBcInN1bW1hcnlcIixcbiAgICBcImlmcmFtZVwiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgXCJlbWJlZFwiLFxuICAgIFwiYXVkaW9bY29udHJvbHNdXCIsXG4gICAgXCJ2aWRlb1tjb250cm9sc11cIixcbiAgICBcIltjb250ZW50ZWRpdGFibGVdXCJcbl07XG5jb25zdCAkOWJmNzFlYTI4NzkzZTczOCR2YXIkRk9DVVNBQkxFX0VMRU1FTlRfU0VMRUNUT1IgPSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNhYmxlRWxlbWVudHMuam9pbihcIjpub3QoW2hpZGRlbl0pLFwiKSArIFwiLFt0YWJpbmRleF06bm90KFtkaXNhYmxlZF0pOm5vdChbaGlkZGVuXSlcIjtcbiQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c2FibGVFbGVtZW50cy5wdXNoKCdbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XCItMVwiXSk6bm90KFtkaXNhYmxlZF0pJyk7XG5jb25zdCAkOWJmNzFlYTI4NzkzZTczOCR2YXIkVEFCQkFCTEVfRUxFTUVOVF9TRUxFQ1RPUiA9ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c2FibGVFbGVtZW50cy5qb2luKCc6bm90KFtoaWRkZW5dKTpub3QoW3RhYmluZGV4PVwiLTFcIl0pLCcpO1xuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJGdldFNjb3BlUm9vdChzY29wZSkge1xuICAgIHJldHVybiBzY29wZVswXS5wYXJlbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJHNob3VsZENvbnRhaW5Gb2N1cyhzY29wZVJlZikge1xuICAgIGxldCBzY29wZSA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmdldFRyZWVOb2RlKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSk7XG4gICAgd2hpbGUoc2NvcGUgJiYgc2NvcGUuc2NvcGVSZWYgIT09IHNjb3BlUmVmKXtcbiAgICAgICAgaWYgKHNjb3BlLmNvbnRhaW4pIHJldHVybiBmYWxzZTtcbiAgICAgICAgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJHVzZUZvY3VzQ29udGFpbm1lbnQoc2NvcGVSZWYsIGNvbnRhaW4pIHtcbiAgICBsZXQgZm9jdXNlZE5vZGUgPSAoMCwgJDZuZkZDJHVzZVJlZikoKTtcbiAgICBsZXQgcmFmID0gKDAsICQ2bmZGQyR1c2VSZWYpKCk7XG4gICAgKDAsICQ2bmZGQyR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCBzY29wZSA9IHNjb3BlUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY29udGFpbikge1xuICAgICAgICAgICAgLy8gaWYgY29udGFpbiB3YXMgY2hhbmdlZCwgdGhlbiB3ZSBzaG91bGQgY2FuY2VsIGFueSBvbmdvaW5nIHdhaXRzIHRvIHB1bGwgZm9jdXMgYmFjayBpbnRvIGNvbnRhaW5tZW50XG4gICAgICAgICAgICBpZiAocmFmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgcmFmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHRoZSBUYWIga2V5IHRvIGNvbnRhaW4gZm9jdXMgd2l0aGluIHRoZSBzY29wZVxuICAgICAgICBsZXQgb25LZXlEb3duID0gKGUpPT57XG4gICAgICAgICAgICBpZiAoZS5rZXkgIT09IFwiVGFiXCIgfHwgZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCAhJDliZjcxZWEyODc5M2U3MzgkdmFyJHNob3VsZENvbnRhaW5Gb2N1cyhzY29wZVJlZikpIHJldHVybjtcbiAgICAgICAgICAgIGxldCBmb2N1c2VkRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBsZXQgc2NvcGUgPSBzY29wZVJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKCFzY29wZSB8fCAhJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUoZm9jdXNlZEVsZW1lbnQsIHNjb3BlKSkgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHNjb3BlUm9vdCA9ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRnZXRTY29wZVJvb3Qoc2NvcGUpO1xuICAgICAgICAgICAgbGV0IHdhbGtlciA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHNjb3BlUm9vdCwge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LCBzY29wZSk7XG4gICAgICAgICAgICBpZiAoIWZvY3VzZWRFbGVtZW50KSByZXR1cm47XG4gICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBmb2N1c2VkRWxlbWVudDtcbiAgICAgICAgICAgIGxldCBuZXh0RWxlbWVudCA9IGUuc2hpZnRLZXkgPyB3YWxrZXIucHJldmlvdXNOb2RlKCkgOiB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIGlmICghbmV4dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBlLnNoaWZ0S2V5ID8gc2NvcGVbc2NvcGUubGVuZ3RoIC0gMV0ubmV4dEVsZW1lbnRTaWJsaW5nIDogc2NvcGVbMF0ucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICAgICAgICAgICAgICBuZXh0RWxlbWVudCA9IGUuc2hpZnRLZXkgPyB3YWxrZXIucHJldmlvdXNOb2RlKCkgOiB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0RWxlbWVudCkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudChuZXh0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBvbkZvY3VzID0gKGUpPT57XG4gICAgICAgICAgICAvLyBJZiBmb2N1c2luZyBhbiBlbGVtZW50IGluIGEgY2hpbGQgc2NvcGUgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2NvcGUsIHRoZSBjaGlsZCBiZWNvbWVzIGFjdGl2ZS5cbiAgICAgICAgICAgIC8vIE1vdmluZyBvdXQgb2YgdGhlIGFjdGl2ZSBzY29wZSB0byBhbiBhbmNlc3RvciBpcyBub3QgYWxsb3dlZC5cbiAgICAgICAgICAgIGlmICgoISQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSB8fCAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNBbmNlc3RvclNjb3BlKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSwgc2NvcGVSZWYpKSAmJiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5TY29wZShlLnRhcmdldCwgc2NvcGVSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUgPSBzY29wZVJlZjtcbiAgICAgICAgICAgICAgICBmb2N1c2VkTm9kZS5jdXJyZW50ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRzaG91bGRDb250YWluRm9jdXMoc2NvcGVSZWYpICYmICEkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5DaGlsZFNjb3BlKGUudGFyZ2V0LCBzY29wZVJlZikpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIGZvY3VzIGV2ZW50IG9jY3VycyBvdXRzaWRlIHRoZSBhY3RpdmUgc2NvcGUgKGUuZy4gdXNlciB0YWJzIGZyb20gYnJvd3NlciBsb2NhdGlvbiBiYXIpLFxuICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgZm9jdXMgdG8gdGhlIHByZXZpb3VzbHkgZm9jdXNlZCBub2RlIG9yIHRoZSBmaXJzdCB0YWJiYWJsZSBlbGVtZW50IGluIHRoZSBhY3RpdmUgc2NvcGUuXG4gICAgICAgICAgICAgICAgaWYgKGZvY3VzZWROb2RlLmN1cnJlbnQpIGZvY3VzZWROb2RlLmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUgJiYgJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlLmN1cnJlbnQpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0ZpcnN0SW5TY29wZSgkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUuY3VycmVudCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRzaG91bGRDb250YWluRm9jdXMoc2NvcGVSZWYpKSBmb2N1c2VkTm9kZS5jdXJyZW50ID0gZS50YXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBvbkJsdXIgPSAoZSk9PntcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzaGlmdCBmb2N1cyBiYWNrIHRvIHRoZSBEaWFsb2cgcHJvcGVybHkgd2l0aG91dCB0aGlzXG4gICAgICAgICAgICBpZiAocmFmLmN1cnJlbnQpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZi5jdXJyZW50KTtcbiAgICAgICAgICAgIHJhZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57XG4gICAgICAgICAgICAgICAgLy8gVXNlIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW5zdGVhZCBvZiBlLnJlbGF0ZWRUYXJnZXQgc28gd2UgY2FuIHRlbGwgaWYgdXNlciBjbGlja2VkIGludG8gaWZyYW1lXG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgJDliZjcxZWEyODc5M2U3MzgkdmFyJHNob3VsZENvbnRhaW5Gb2N1cyhzY29wZVJlZikgJiYgISQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJbkNoaWxkU2NvcGUoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCwgc2NvcGVSZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSA9IHNjb3BlUmVmO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuYm9keS5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZm9jdXNlZE5vZGVfY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzZWROb2RlLmN1cnJlbnQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfZm9jdXNlZE5vZGVfY3VycmVudCA9IGZvY3VzZWROb2RlLmN1cnJlbnQpID09PSBudWxsIHx8IF9mb2N1c2VkTm9kZV9jdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZm9jdXNlZE5vZGVfY3VycmVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZS5jdXJyZW50KSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNGaXJzdEluU2NvcGUoJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24sIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25Gb2N1cywgZmFsc2UpO1xuICAgICAgICBzY29wZSA9PT0gbnVsbCB8fCBzY29wZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NvcGUuZm9yRWFjaCgoZWxlbWVudCk9PmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25Gb2N1cywgZmFsc2UpKTtcbiAgICAgICAgc2NvcGUgPT09IG51bGwgfHwgc2NvcGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjb3BlLmZvckVhY2goKGVsZW1lbnQpPT5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBvbkJsdXIsIGZhbHNlKSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duLCBmYWxzZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBvbkZvY3VzLCBmYWxzZSk7XG4gICAgICAgICAgICBzY29wZSA9PT0gbnVsbCB8fCBzY29wZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NvcGUuZm9yRWFjaCgoZWxlbWVudCk9PmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25Gb2N1cywgZmFsc2UpKTtcbiAgICAgICAgICAgIHNjb3BlID09PSBudWxsIHx8IHNjb3BlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY29wZS5mb3JFYWNoKChlbGVtZW50KT0+ZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgb25CbHVyLCBmYWxzZSkpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgc2NvcGVSZWYsXG4gICAgICAgIGNvbnRhaW5cbiAgICBdKTtcbiAgICAvLyBUaGlzIGlzIGEgdXNlTGF5b3V0RWZmZWN0IHNvIGl0IGlzIGd1YXJhbnRlZWQgdG8gcnVuIGJlZm9yZSBvdXIgYXN5bmMgc3ludGhldGljIGJsdXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyb3ctYm9keS1zdHlsZVxuICAgICgwLCAkNm5mRkMkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmIChyYWYuY3VycmVudCkgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmLmN1cnJlbnQpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgcmFmXG4gICAgXSk7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5BbnlTY29wZShlbGVtZW50KSB7XG4gICAgcmV0dXJuICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJbkNoaWxkU2NvcGUoZWxlbWVudCk7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5TY29wZShlbGVtZW50LCBzY29wZSkge1xuICAgIGlmICghZWxlbWVudCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghc2NvcGUpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gc2NvcGUuc29tZSgobm9kZSk9Pm5vZGUuY29udGFpbnMoZWxlbWVudCkpO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluQ2hpbGRTY29wZShlbGVtZW50LCBzY29wZSA9IG51bGwpIHtcbiAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyB3aXRoaW4gYSB0b3AgbGF5ZXIgZWxlbWVudCAoZS5nLiB0b2FzdHMpLCBhbHdheXMgYWxsb3cgbW92aW5nIGZvY3VzIHRoZXJlLlxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCAmJiBlbGVtZW50LmNsb3Nlc3QoXCJbZGF0YS1yZWFjdC1hcmlhLXRvcC1sYXllcl1cIikpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vZGUuY29udGFpbnMgaW4gaXNFbGVtZW50SW5TY29wZSBjb3ZlcnMgY2hpbGQgc2NvcGVzIHRoYXQgYXJlIGFsc28gRE9NIGNoaWxkcmVuLFxuICAgIC8vIGJ1dCBkb2VzIG5vdCBjb3ZlciBjaGlsZCBzY29wZXMgaW4gcG9ydGFscy5cbiAgICBmb3IgKGxldCB7IHNjb3BlUmVmOiBzIH0gb2YgJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUudHJhdmVyc2UoJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUuZ2V0VHJlZU5vZGUoc2NvcGUpKSl7XG4gICAgICAgIGlmIChzICYmICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJblNjb3BlKGVsZW1lbnQsIHMuY3VycmVudCkpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMTI1ODM5NWY5OWJmOWNiZihlbGVtZW50KSB7XG4gICAgcmV0dXJuICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJbkNoaWxkU2NvcGUoZWxlbWVudCwgJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlKTtcbn1cbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0FuY2VzdG9yU2NvcGUoYW5jZXN0b3IsIHNjb3BlKSB7XG4gICAgdmFyIF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZTtcbiAgICBsZXQgcGFyZW50ID0gKF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZSA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmdldFRyZWVOb2RlKHNjb3BlKSkgPT09IG51bGwgfHwgX2ZvY3VzU2NvcGVUcmVlX2dldFRyZWVOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGUucGFyZW50O1xuICAgIHdoaWxlKHBhcmVudCl7XG4gICAgICAgIGlmIChwYXJlbnQuc2NvcGVSZWYgPT09IGFuY2VzdG9yKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudChlbGVtZW50LCBzY3JvbGwgPSBmYWxzZSkge1xuICAgIGlmIChlbGVtZW50ICE9IG51bGwgJiYgIXNjcm9sbCkgdHJ5IHtcbiAgICAgICAgKDAsICQ2YTk5MTk1MzMyZWRlYzhiJGV4cG9ydCQ4MGYzZTE0N2Q3ODE1NzFjKShlbGVtZW50KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBpZ25vcmVcbiAgICB9XG4gICAgZWxzZSBpZiAoZWxlbWVudCAhPSBudWxsKSB0cnkge1xuICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gaWdub3JlXG4gICAgfVxufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRmlyc3RJblNjb3BlKHNjb3BlLCB0YWJiYWJsZSA9IHRydWUpIHtcbiAgICBsZXQgc2VudGluZWwgPSBzY29wZVswXS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIGxldCBzY29wZVJvb3QgPSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZ2V0U2NvcGVSb290KHNjb3BlKTtcbiAgICBsZXQgd2Fsa2VyID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDJkNmVjOGZjMzc1Y2VhZmEoc2NvcGVSb290LCB7XG4gICAgICAgIHRhYmJhYmxlOiB0YWJiYWJsZVxuICAgIH0sIHNjb3BlKTtcbiAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBzZW50aW5lbDtcbiAgICBsZXQgbmV4dE5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAvLyBJZiB0aGUgc2NvcGUgZG9lcyBub3QgY29udGFpbiBhIHRhYmJhYmxlIGVsZW1lbnQsIHVzZSB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQuXG4gICAgaWYgKHRhYmJhYmxlICYmICFuZXh0Tm9kZSkge1xuICAgICAgICBzY29wZVJvb3QgPSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZ2V0U2NvcGVSb290KHNjb3BlKTtcbiAgICAgICAgd2Fsa2VyID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDJkNmVjOGZjMzc1Y2VhZmEoc2NvcGVSb290LCB7XG4gICAgICAgICAgICB0YWJiYWJsZTogZmFsc2VcbiAgICAgICAgfSwgc2NvcGUpO1xuICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBzZW50aW5lbDtcbiAgICAgICAgbmV4dE5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICB9XG4gICAgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudChuZXh0Tm9kZSk7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkdXNlQXV0b0ZvY3VzKHNjb3BlUmVmLCBhdXRvRm9jdXMpIHtcbiAgICBjb25zdCBhdXRvRm9jdXNSZWYgPSAoMCwgJDZuZkZDJHJlYWN0KS51c2VSZWYoYXV0b0ZvY3VzKTtcbiAgICAoMCwgJDZuZkZDJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKGF1dG9Gb2N1c1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUgPSBzY29wZVJlZjtcbiAgICAgICAgICAgIGlmICghJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCwgJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlLmN1cnJlbnQpICYmIHNjb3BlUmVmLmN1cnJlbnQpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0ZpcnN0SW5TY29wZShzY29wZVJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBhdXRvRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH0sIFtcbiAgICAgICAgc2NvcGVSZWZcbiAgICBdKTtcbn1cbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JHZhciR1c2VBY3RpdmVTY29wZVRyYWNrZXIoc2NvcGVSZWYsIHJlc3RvcmUsIGNvbnRhaW4pIHtcbiAgICAvLyB0cmFja3MgdGhlIGFjdGl2ZSBzY29wZSwgaW4gY2FzZSByZXN0b3JlIGFuZCBjb250YWluIGFyZSBib3RoIGZhbHNlLlxuICAgIC8vIGlmIGVpdGhlciBhcmUgdHJ1ZSwgdGhpcyBpcyB0cmFja2VkIGluIHVzZVJlc3RvcmVGb2N1cyBvciB1c2VGb2N1c0NvbnRhaW5tZW50LlxuICAgICgwLCAkNm5mRkMkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAocmVzdG9yZSB8fCBjb250YWluKSByZXR1cm47XG4gICAgICAgIGxldCBzY29wZSA9IHNjb3BlUmVmLmN1cnJlbnQ7XG4gICAgICAgIGxldCBvbkZvY3VzID0gKGUpPT57XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUodGFyZ2V0LCBzY29wZVJlZi5jdXJyZW50KSkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlID0gc2NvcGVSZWY7XG4gICAgICAgICAgICBlbHNlIGlmICghJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluQW55U2NvcGUodGFyZ2V0KSkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25Gb2N1cywgZmFsc2UpO1xuICAgICAgICBzY29wZSA9PT0gbnVsbCB8fCBzY29wZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NvcGUuZm9yRWFjaCgoZWxlbWVudCk9PmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25Gb2N1cywgZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBvbkZvY3VzLCBmYWxzZSk7XG4gICAgICAgICAgICBzY29wZSA9PT0gbnVsbCB8fCBzY29wZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NvcGUuZm9yRWFjaCgoZWxlbWVudCk9PmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25Gb2N1cywgZmFsc2UpKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHNjb3BlUmVmLFxuICAgICAgICByZXN0b3JlLFxuICAgICAgICBjb250YWluXG4gICAgXSk7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkc2hvdWxkUmVzdG9yZUZvY3VzKHNjb3BlUmVmKSB7XG4gICAgbGV0IHNjb3BlID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUuZ2V0VHJlZU5vZGUoJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlKTtcbiAgICB3aGlsZShzY29wZSAmJiBzY29wZS5zY29wZVJlZiAhPT0gc2NvcGVSZWYpe1xuICAgICAgICBpZiAoc2NvcGUubm9kZVRvUmVzdG9yZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBzY29wZSA9IHNjb3BlLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIChzY29wZSA9PT0gbnVsbCB8fCBzY29wZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NvcGUuc2NvcGVSZWYpID09PSBzY29wZVJlZjtcbn1cbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JHZhciR1c2VSZXN0b3JlRm9jdXMoc2NvcGVSZWYsIHJlc3RvcmVGb2N1cywgY29udGFpbikge1xuICAgIC8vIGNyZWF0ZSBhIHJlZiBkdXJpbmcgcmVuZGVyIGluc3RlYWQgb2YgdXNlTGF5b3V0RWZmZWN0IHNvIHRoZSBhY3RpdmUgZWxlbWVudCBpcyBzYXZlZCBiZWZvcmUgYSBjaGlsZCB3aXRoIGF1dG9Gb2N1cz10cnVlIG1vdW50cy5cbiAgICBjb25zdCBub2RlVG9SZXN0b3JlUmVmID0gKDAsICQ2bmZGQyR1c2VSZWYpKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgOiBudWxsKTtcbiAgICAvLyByZXN0b3Jpbmcgc2NvcGVzIHNob3VsZCBhbGwgdHJhY2sgaWYgdGhleSBhcmUgYWN0aXZlIHJlZ2FyZGxlc3Mgb2YgY29udGFpbiwgYnV0IGNvbnRhaW4gYWxyZWFkeSB0cmFja3MgaXQgcGx1cyBsb2dpYyB0byBjb250YWluIHRoZSBmb2N1c1xuICAgIC8vIHJlc3RvcmluZy1ub24tY29udGFpbmluZyBzY29wZXMgc2hvdWxkIG9ubHkgY2FyZSBpZiB0aGV5IGJlY29tZSBhY3RpdmUgc28gdGhleSBjYW4gcGVyZm9ybSB0aGUgcmVzdG9yZVxuICAgICgwLCAkNm5mRkMkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgc2NvcGUgPSBzY29wZVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIXJlc3RvcmVGb2N1cyB8fCBjb250YWluKSByZXR1cm47XG4gICAgICAgIGxldCBvbkZvY3VzID0gKCk9PntcbiAgICAgICAgICAgIC8vIElmIGZvY3VzaW5nIGFuIGVsZW1lbnQgaW4gYSBjaGlsZCBzY29wZSBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBzY29wZSwgdGhlIGNoaWxkIGJlY29tZXMgYWN0aXZlLlxuICAgICAgICAgICAgLy8gTW92aW5nIG91dCBvZiB0aGUgYWN0aXZlIHNjb3BlIHRvIGFuIGFuY2VzdG9yIGlzIG5vdCBhbGxvd2VkLlxuICAgICAgICAgICAgaWYgKCghJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlIHx8ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0FuY2VzdG9yU2NvcGUoJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlLCBzY29wZVJlZikpICYmICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJblNjb3BlKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQsIHNjb3BlUmVmLmN1cnJlbnQpKSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUgPSBzY29wZVJlZjtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25Gb2N1cywgZmFsc2UpO1xuICAgICAgICBzY29wZSA9PT0gbnVsbCB8fCBzY29wZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NvcGUuZm9yRWFjaCgoZWxlbWVudCk9PmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25Gb2N1cywgZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBvbkZvY3VzLCBmYWxzZSk7XG4gICAgICAgICAgICBzY29wZSA9PT0gbnVsbCB8fCBzY29wZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NvcGUuZm9yRWFjaCgoZWxlbWVudCk9PmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25Gb2N1cywgZmFsc2UpKTtcbiAgICAgICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW1xuICAgICAgICBzY29wZVJlZixcbiAgICAgICAgY29udGFpblxuICAgIF0pO1xuICAgICgwLCAkNm5mRkMkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoIXJlc3RvcmVGb2N1cykgcmV0dXJuO1xuICAgICAgICAvLyBIYW5kbGUgdGhlIFRhYiBrZXkgc28gdGhhdCB0YWJiaW5nIG91dCBvZiB0aGUgc2NvcGUgZ29lcyB0byB0aGUgbmV4dCBlbGVtZW50XG4gICAgICAgIC8vIGFmdGVyIHRoZSBub2RlIHRoYXQgaGFkIGZvY3VzIHdoZW4gdGhlIHNjb3BlIG1vdW50ZWQuIFRoaXMgaXMgaW1wb3J0YW50IHdoZW5cbiAgICAgICAgLy8gdXNpbmcgcG9ydGFscyBmb3Igb3ZlcmxheXMsIHNvIHRoYXQgZm9jdXMgZ29lcyB0byB0aGUgZXhwZWN0ZWQgZWxlbWVudCB3aGVuXG4gICAgICAgIC8vIHRhYmJpbmcgb3V0IG9mIHRoZSBvdmVybGF5LlxuICAgICAgICBsZXQgb25LZXlEb3duID0gKGUpPT57XG4gICAgICAgICAgICBpZiAoZS5rZXkgIT09IFwiVGFiXCIgfHwgZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCAhJDliZjcxZWEyODc5M2U3MzgkdmFyJHNob3VsZENvbnRhaW5Gb2N1cyhzY29wZVJlZikpIHJldHVybjtcbiAgICAgICAgICAgIGxldCBmb2N1c2VkRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoISQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJblNjb3BlKGZvY3VzZWRFbGVtZW50LCBzY29wZVJlZi5jdXJyZW50KSkgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHRyZWVOb2RlID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUuZ2V0VHJlZU5vZGUoc2NvcGVSZWYpO1xuICAgICAgICAgICAgaWYgKCF0cmVlTm9kZSkgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IG5vZGVUb1Jlc3RvcmUgPSB0cmVlTm9kZS5ub2RlVG9SZXN0b3JlO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgRE9NIHRyZWUgd2Fsa2VyIHRoYXQgbWF0Y2hlcyBhbGwgdGFiYmFibGUgZWxlbWVudHNcbiAgICAgICAgICAgIGxldCB3YWxrZXIgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMmQ2ZWM4ZmMzNzVjZWFmYShkb2N1bWVudC5ib2R5LCB7XG4gICAgICAgICAgICAgICAgdGFiYmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgbmV4dCB0YWJiYWJsZSBlbGVtZW50IGFmdGVyIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50XG4gICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBmb2N1c2VkRWxlbWVudDtcbiAgICAgICAgICAgIGxldCBuZXh0RWxlbWVudCA9IGUuc2hpZnRLZXkgPyB3YWxrZXIucHJldmlvdXNOb2RlKCkgOiB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIGlmICghbm9kZVRvUmVzdG9yZSB8fCAhZG9jdW1lbnQuYm9keS5jb250YWlucyhub2RlVG9SZXN0b3JlKSB8fCBub2RlVG9SZXN0b3JlID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgbm9kZVRvUmVzdG9yZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0cmVlTm9kZS5ub2RlVG9SZXN0b3JlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbmV4dCBlbGVtZW50LCBvciBpdCBpcyBvdXRzaWRlIHRoZSBjdXJyZW50IHNjb3BlLCBtb3ZlIGZvY3VzIHRvIHRoZVxuICAgICAgICAgICAgLy8gbmV4dCBlbGVtZW50IGFmdGVyIHRoZSBub2RlIHRvIHJlc3RvcmUgdG8gaW5zdGVhZC5cbiAgICAgICAgICAgIGlmICgoIW5leHRFbGVtZW50IHx8ICEkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5TY29wZShuZXh0RWxlbWVudCwgc2NvcGVSZWYuY3VycmVudCkpICYmIG5vZGVUb1Jlc3RvcmUpIHtcbiAgICAgICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBub2RlVG9SZXN0b3JlO1xuICAgICAgICAgICAgICAgIC8vIFNraXAgb3ZlciBlbGVtZW50cyB3aXRoaW4gdGhlIHNjb3BlLCBpbiBjYXNlIHRoZSBzY29wZSBpbW1lZGlhdGVseSBmb2xsb3dzIHRoZSBub2RlIHRvIHJlc3RvcmUuXG4gICAgICAgICAgICAgICAgZG8gbmV4dEVsZW1lbnQgPSBlLnNoaWZ0S2V5ID8gd2Fsa2VyLnByZXZpb3VzTm9kZSgpIDogd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJblNjb3BlKG5leHRFbGVtZW50LCBzY29wZVJlZi5jdXJyZW50KSk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRFbGVtZW50KSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNFbGVtZW50KG5leHRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIC8vIElmIHRoZXJlIGlzIG5vIG5leHQgZWxlbWVudCBhbmQgdGhlIG5vZGVUb1Jlc3RvcmUgaXNuJ3Qgd2l0aGluIGEgRm9jdXNTY29wZSAoaS5lLiB3ZSBhcmUgbGVhdmluZyB0aGUgdG9wIGxldmVsIGZvY3VzIHNjb3BlKVxuICAgICAgICAgICAgICAgIC8vIHRoZW4gbW92ZSBmb2N1cyB0byB0aGUgYm9keS5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgcmVzdG9yZSBmb2N1cyB0byB0aGUgbm9kZVRvUmVzdG9yZSAoZS5nIG1lbnUgd2l0aGluIGEgcG9wb3ZlciAtPiB0YWJiaW5nIHRvIGNsb3NlIHRoZSBtZW51IHNob3VsZCBtb3ZlIGZvY3VzIHRvIG1lbnUgdHJpZ2dlcilcbiAgICAgICAgICAgICAgICBpZiAoISQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJbkFueVNjb3BlKG5vZGVUb1Jlc3RvcmUpKSBmb2N1c2VkRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgZWxzZSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNFbGVtZW50KG5vZGVUb1Jlc3RvcmUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWNvbnRhaW4pIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93biwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaWYgKCFjb250YWluKSBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24sIHRydWUpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgc2NvcGVSZWYsXG4gICAgICAgIHJlc3RvcmVGb2N1cyxcbiAgICAgICAgY29udGFpblxuICAgIF0pO1xuICAgIC8vIHVzZUxheW91dEVmZmVjdCBpbnN0ZWFkIG9mIHVzZUVmZmVjdCBzbyB0aGUgYWN0aXZlIGVsZW1lbnQgaXMgc2F2ZWQgc3luY2hyb25vdXNseSBpbnN0ZWFkIG9mIGFzeW5jaHJvbm91c2x5LlxuICAgICgwLCAkNm5mRkMkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoIXJlc3RvcmVGb2N1cykgcmV0dXJuO1xuICAgICAgICBsZXQgdHJlZU5vZGUgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5nZXRUcmVlTm9kZShzY29wZVJlZik7XG4gICAgICAgIGlmICghdHJlZU5vZGUpIHJldHVybjtcbiAgICAgICAgdmFyIF9ub2RlVG9SZXN0b3JlUmVmX2N1cnJlbnQ7XG4gICAgICAgIHRyZWVOb2RlLm5vZGVUb1Jlc3RvcmUgPSAoX25vZGVUb1Jlc3RvcmVSZWZfY3VycmVudCA9IG5vZGVUb1Jlc3RvcmVSZWYuY3VycmVudCkgIT09IG51bGwgJiYgX25vZGVUb1Jlc3RvcmVSZWZfY3VycmVudCAhPT0gdm9pZCAwID8gX25vZGVUb1Jlc3RvcmVSZWZfY3VycmVudCA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBsZXQgdHJlZU5vZGUgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5nZXRUcmVlTm9kZShzY29wZVJlZik7XG4gICAgICAgICAgICBpZiAoIXRyZWVOb2RlKSByZXR1cm47XG4gICAgICAgICAgICBsZXQgbm9kZVRvUmVzdG9yZSA9IHRyZWVOb2RlLm5vZGVUb1Jlc3RvcmU7XG4gICAgICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGxvc3QgZm9jdXMgdG8gdGhlIGJvZHkgYW5kIHRoaXMgd2FzIHRoZSBhY3RpdmUgc2NvcGUsIHRoZW4gd2Ugc2hvdWxkIGF0dGVtcHQgdG8gcmVzdG9yZVxuICAgICAgICAgICAgaWYgKHJlc3RvcmVGb2N1cyAmJiBub2RlVG9SZXN0b3JlICYmIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgICAgICAgICgkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5TY29wZShkb2N1bWVudC5hY3RpdmVFbGVtZW50LCBzY29wZVJlZi5jdXJyZW50KSB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5ib2R5ICYmICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRzaG91bGRSZXN0b3JlRm9jdXMoc2NvcGVSZWYpKSkge1xuICAgICAgICAgICAgICAgIC8vIGZyZWV6ZSB0aGUgZm9jdXNTY29wZVRyZWUgc28gaXQgcGVyc2lzdHMgYWZ0ZXIgdGhlIHJhZiwgb3RoZXJ3aXNlIGR1cmluZyB1bm1vdW50IG5vZGVzIGFyZSByZW1vdmVkIGZyb20gaXRcbiAgICAgICAgICAgICAgICBsZXQgY2xvbmVkVHJlZSA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVzdG9yZSBmb2N1cyBpZiB3ZSd2ZSBsb3N0IGZvY3VzIHRvIHRoZSBib2R5LCB0aGUgYWx0ZXJuYXRpdmUgaXMgdGhhdCBmb2N1cyBoYXMgYmVlbiBwdXJwb3NlZnVsbHkgbW92ZWQgZWxzZXdoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb29rIHVwIHRoZSB0cmVlIHN0YXJ0aW5nIHdpdGggb3VyIHNjb3BlIHRvIGZpbmQgYSBub2RlVG9SZXN0b3JlIHN0aWxsIGluIHRoZSBET01cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0cmVlTm9kZSA9IGNsb25lZFRyZWUuZ2V0VHJlZU5vZGUoc2NvcGVSZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUodHJlZU5vZGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmVlTm9kZS5ub2RlVG9SZXN0b3JlICYmIGRvY3VtZW50LmJvZHkuY29udGFpbnModHJlZU5vZGUubm9kZVRvUmVzdG9yZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudCh0cmVlTm9kZS5ub2RlVG9SZXN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZSA9IHRyZWVOb2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIG5vZGVUb1Jlc3RvcmUgd2FzIGZvdW5kLCBmb2N1cyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgbmVhcmVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5jZXN0b3Igc2NvcGUgdGhhdCBpcyBzdGlsbCBpbiB0aGUgdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlID0gY2xvbmVkVHJlZS5nZXRUcmVlTm9kZShzY29wZVJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSh0cmVlTm9kZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVOb2RlLnNjb3BlUmVmICYmIHRyZWVOb2RlLnNjb3BlUmVmLmN1cnJlbnQgJiYgJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUuZ2V0VHJlZU5vZGUodHJlZU5vZGUuc2NvcGVSZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0ZpcnN0SW5TY29wZSh0cmVlTm9kZS5zY29wZVJlZi5jdXJyZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZSA9IHRyZWVOb2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgc2NvcGVSZWYsXG4gICAgICAgIHJlc3RvcmVGb2N1c1xuICAgIF0pO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDJkNmVjOGZjMzc1Y2VhZmEocm9vdCwgb3B0cywgc2NvcGUpIHtcbiAgICBsZXQgc2VsZWN0b3IgPSAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnRhYmJhYmxlKSA/ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRUQUJCQUJMRV9FTEVNRU5UX1NFTEVDVE9SIDogJDliZjcxZWEyODc5M2U3MzgkdmFyJEZPQ1VTQUJMRV9FTEVNRU5UX1NFTEVDVE9SO1xuICAgIGxldCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKHJvb3QsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCB7XG4gICAgICAgIGFjY2VwdE5vZGUgKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBfb3B0c19mcm9tO1xuICAgICAgICAgICAgLy8gU2tpcCBub2RlcyBpbnNpZGUgdGhlIHN0YXJ0aW5nIG5vZGUuXG4gICAgICAgICAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX29wdHNfZnJvbSA9IG9wdHMuZnJvbSkgPT09IG51bGwgfHwgX29wdHNfZnJvbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdHNfZnJvbS5jb250YWlucyhub2RlKSkgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVDtcbiAgICAgICAgICAgIGlmIChub2RlLm1hdGNoZXMoc2VsZWN0b3IpICYmICgwLCAkNjQ1ZjJlNjdiODVhMjRjOSRleHBvcnQkZTk4OWMwZmZmYWE2YjI3YSkobm9kZSkgJiYgKCFzY29wZSB8fCAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5TY29wZShub2RlLCBzY29wZSkpICYmICghKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5hY2NlcHQpIHx8IG9wdHMuYWNjZXB0KG5vZGUpKSkgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5mcm9tKSB3YWxrZXIuY3VycmVudE5vZGUgPSBvcHRzLmZyb207XG4gICAgcmV0dXJuIHdhbGtlcjtcbn1cbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRjNTI1MWI5ZTEyNGJmMjkocmVmLCBkZWZhdWx0T3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9jdXNOZXh0IChvcHRzID0ge30pIHtcbiAgICAgICAgICAgIGxldCByb290ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoIXJvb3QpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IHsgZnJvbTogZnJvbSwgdGFiYmFibGU6IHRhYmJhYmxlID0gZGVmYXVsdE9wdGlvbnMudGFiYmFibGUsIHdyYXA6IHdyYXAgPSBkZWZhdWx0T3B0aW9ucy53cmFwLCBhY2NlcHQ6IGFjY2VwdCA9IGRlZmF1bHRPcHRpb25zLmFjY2VwdCB9ID0gb3B0cztcbiAgICAgICAgICAgIGxldCBub2RlID0gZnJvbSB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgbGV0IHdhbGtlciA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHJvb3QsIHtcbiAgICAgICAgICAgICAgICB0YWJiYWJsZTogdGFiYmFibGUsXG4gICAgICAgICAgICAgICAgYWNjZXB0OiBhY2NlcHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJvb3QuY29udGFpbnMobm9kZSkpIHdhbGtlci5jdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICBsZXQgbmV4dE5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIGlmICghbmV4dE5vZGUgJiYgd3JhcCkge1xuICAgICAgICAgICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgbmV4dE5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0Tm9kZSkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudChuZXh0Tm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dE5vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzUHJldmlvdXMgKG9wdHMgPSBkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgbGV0IHJvb3QgPSByZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmICghcm9vdCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgeyBmcm9tOiBmcm9tLCB0YWJiYWJsZTogdGFiYmFibGUgPSBkZWZhdWx0T3B0aW9ucy50YWJiYWJsZSwgd3JhcDogd3JhcCA9IGRlZmF1bHRPcHRpb25zLndyYXAsIGFjY2VwdDogYWNjZXB0ID0gZGVmYXVsdE9wdGlvbnMuYWNjZXB0IH0gPSBvcHRzO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBmcm9tIHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBsZXQgd2Fsa2VyID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDJkNmVjOGZjMzc1Y2VhZmEocm9vdCwge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlOiB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6IGFjY2VwdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocm9vdC5jb250YWlucyhub2RlKSkgd2Fsa2VyLmN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gJDliZjcxZWEyODc5M2U3MzgkdmFyJGxhc3Qod2Fsa2VyKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudChuZXh0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCAhPT0gbnVsbCAmJiBuZXh0ICE9PSB2b2lkIDAgPyBuZXh0IDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwcmV2aW91c05vZGUgPSB3YWxrZXIucHJldmlvdXNOb2RlKCk7XG4gICAgICAgICAgICBpZiAoIXByZXZpb3VzTm9kZSAmJiB3cmFwKSB7XG4gICAgICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gcm9vdDtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdE5vZGUgPSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkbGFzdCh3YWxrZXIpO1xuICAgICAgICAgICAgICAgIGlmICghbGFzdE5vZGUpIC8vIGNvdWxkbid0IHdyYXBcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBwcmV2aW91c05vZGUgPSBsYXN0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2aW91c05vZGUpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0VsZW1lbnQocHJldmlvdXNOb2RlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c05vZGUgIT09IG51bGwgJiYgcHJldmlvdXNOb2RlICE9PSB2b2lkIDAgPyBwcmV2aW91c05vZGUgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBmb2N1c0ZpcnN0IChvcHRzID0gZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCByb290ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoIXJvb3QpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IHsgdGFiYmFibGU6IHRhYmJhYmxlID0gZGVmYXVsdE9wdGlvbnMudGFiYmFibGUsIGFjY2VwdDogYWNjZXB0ID0gZGVmYXVsdE9wdGlvbnMuYWNjZXB0IH0gPSBvcHRzO1xuICAgICAgICAgICAgbGV0IHdhbGtlciA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHJvb3QsIHtcbiAgICAgICAgICAgICAgICB0YWJiYWJsZTogdGFiYmFibGUsXG4gICAgICAgICAgICAgICAgYWNjZXB0OiBhY2NlcHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IG5leHROb2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICBpZiAobmV4dE5vZGUpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0VsZW1lbnQobmV4dE5vZGUsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHROb2RlO1xuICAgICAgICB9LFxuICAgICAgICBmb2N1c0xhc3QgKG9wdHMgPSBkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgbGV0IHJvb3QgPSByZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmICghcm9vdCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgeyB0YWJiYWJsZTogdGFiYmFibGUgPSBkZWZhdWx0T3B0aW9ucy50YWJiYWJsZSwgYWNjZXB0OiBhY2NlcHQgPSBkZWZhdWx0T3B0aW9ucy5hY2NlcHQgfSA9IG9wdHM7XG4gICAgICAgICAgICBsZXQgd2Fsa2VyID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDJkNmVjOGZjMzc1Y2VhZmEocm9vdCwge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlOiB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6IGFjY2VwdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgbmV4dCA9ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRsYXN0KHdhbGtlcik7XG4gICAgICAgICAgICBpZiAobmV4dCkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudChuZXh0LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0ICE9PSBudWxsICYmIG5leHQgIT09IHZvaWQgMCA/IG5leHQgOiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRsYXN0KHdhbGtlcikge1xuICAgIGxldCBuZXh0ID0gdW5kZWZpbmVkO1xuICAgIGxldCBsYXN0O1xuICAgIGRvIHtcbiAgICAgICAgbGFzdCA9IHdhbGtlci5sYXN0Q2hpbGQoKTtcbiAgICAgICAgaWYgKGxhc3QpIG5leHQgPSBsYXN0O1xuICAgIH13aGlsZSAobGFzdCk7XG4gICAgcmV0dXJuIG5leHQ7XG59XG5jbGFzcyAkOWJmNzFlYTI4NzkzZTczOCR2YXIkVHJlZSB7XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhc3RNYXAuc2l6ZTtcbiAgICB9XG4gICAgZ2V0VHJlZU5vZGUoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mYXN0TWFwLmdldChkYXRhKTtcbiAgICB9XG4gICAgYWRkVHJlZU5vZGUoc2NvcGVSZWYsIHBhcmVudCwgbm9kZVRvUmVzdG9yZSkge1xuICAgICAgICBsZXQgcGFyZW50Tm9kZSA9IHRoaXMuZmFzdE1hcC5nZXQocGFyZW50ICE9PSBudWxsICYmIHBhcmVudCAhPT0gdm9pZCAwID8gcGFyZW50IDogbnVsbCk7XG4gICAgICAgIGlmICghcGFyZW50Tm9kZSkgcmV0dXJuO1xuICAgICAgICBsZXQgbm9kZSA9IG5ldyAkOWJmNzFlYTI4NzkzZTczOCR2YXIkVHJlZU5vZGUoe1xuICAgICAgICAgICAgc2NvcGVSZWY6IHNjb3BlUmVmXG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnROb2RlLmFkZENoaWxkKG5vZGUpO1xuICAgICAgICBub2RlLnBhcmVudCA9IHBhcmVudE5vZGU7XG4gICAgICAgIHRoaXMuZmFzdE1hcC5zZXQoc2NvcGVSZWYsIG5vZGUpO1xuICAgICAgICBpZiAobm9kZVRvUmVzdG9yZSkgbm9kZS5ub2RlVG9SZXN0b3JlID0gbm9kZVRvUmVzdG9yZTtcbiAgICB9XG4gICAgYWRkTm9kZShub2RlKSB7XG4gICAgICAgIHRoaXMuZmFzdE1hcC5zZXQobm9kZS5zY29wZVJlZiwgbm9kZSk7XG4gICAgfVxuICAgIHJlbW92ZVRyZWVOb2RlKHNjb3BlUmVmKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlbW92ZSB0aGUgcm9vdFxuICAgICAgICBpZiAoc2NvcGVSZWYgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmZhc3RNYXAuZ2V0KHNjb3BlUmVmKTtcbiAgICAgICAgaWYgKCFub2RlKSByZXR1cm47XG4gICAgICAgIGxldCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIC8vIHdoZW4gd2UgcmVtb3ZlIGEgc2NvcGUsIGNoZWNrIGlmIGFueSBzaWJsaW5nIHNjb3BlcyBhcmUgdHJ5aW5nIHRvIHJlc3RvcmUgZm9jdXMgdG8gc29tZXRoaW5nIGluc2lkZSB0aGUgc2NvcGUgd2UncmUgcmVtb3ZpbmdcbiAgICAgICAgLy8gaWYgd2UgYXJlLCB0aGVuIHJlcGxhY2UgdGhlIHNpYmxpbmdzIHJlc3RvcmUgd2l0aCB0aGUgcmVzdG9yZSBmcm9tIHRoZSBzY29wZSB3ZSdyZSByZW1vdmluZ1xuICAgICAgICBmb3IgKGxldCBjdXJyZW50IG9mIHRoaXMudHJhdmVyc2UoKSlpZiAoY3VycmVudCAhPT0gbm9kZSAmJiBub2RlLm5vZGVUb1Jlc3RvcmUgJiYgY3VycmVudC5ub2RlVG9SZXN0b3JlICYmIG5vZGUuc2NvcGVSZWYgJiYgbm9kZS5zY29wZVJlZi5jdXJyZW50ICYmICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJblNjb3BlKGN1cnJlbnQubm9kZVRvUmVzdG9yZSwgbm9kZS5zY29wZVJlZi5jdXJyZW50KSkgY3VycmVudC5ub2RlVG9SZXN0b3JlID0gbm9kZS5ub2RlVG9SZXN0b3JlO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbi5zaXplID4gMCkgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpPT5wYXJlbnROb2RlICYmIHBhcmVudE5vZGUuYWRkQ2hpbGQoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZhc3RNYXAuZGVsZXRlKG5vZGUuc2NvcGVSZWYpO1xuICAgIH1cbiAgICAvLyBQcmUgT3JkZXIgRGVwdGggRmlyc3RcbiAgICAqdHJhdmVyc2Uobm9kZSA9IHRoaXMucm9vdCkge1xuICAgICAgICBpZiAobm9kZS5zY29wZVJlZiAhPSBudWxsKSB5aWVsZCBub2RlO1xuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5zaXplID4gMCkgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbil5aWVsZCogdGhpcy50cmF2ZXJzZShjaGlsZCk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICB2YXIgX25vZGVfcGFyZW50O1xuICAgICAgICBsZXQgbmV3VHJlZSA9IG5ldyAkOWJmNzFlYTI4NzkzZTczOCR2YXIkVHJlZSgpO1xuICAgICAgICB2YXIgX25vZGVfcGFyZW50X3Njb3BlUmVmO1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIHRoaXMudHJhdmVyc2UoKSluZXdUcmVlLmFkZFRyZWVOb2RlKG5vZGUuc2NvcGVSZWYsIChfbm9kZV9wYXJlbnRfc2NvcGVSZWYgPSAoX25vZGVfcGFyZW50ID0gbm9kZS5wYXJlbnQpID09PSBudWxsIHx8IF9ub2RlX3BhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGVfcGFyZW50LnNjb3BlUmVmKSAhPT0gbnVsbCAmJiBfbm9kZV9wYXJlbnRfc2NvcGVSZWYgIT09IHZvaWQgMCA/IF9ub2RlX3BhcmVudF9zY29wZVJlZiA6IG51bGwsIG5vZGUubm9kZVRvUmVzdG9yZSk7XG4gICAgICAgIHJldHVybiBuZXdUcmVlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmZhc3RNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucm9vdCA9IG5ldyAkOWJmNzFlYTI4NzkzZTczOCR2YXIkVHJlZU5vZGUoe1xuICAgICAgICAgICAgc2NvcGVSZWY6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmFzdE1hcC5zZXQobnVsbCwgdGhpcy5yb290KTtcbiAgICB9XG59XG5jbGFzcyAkOWJmNzFlYTI4NzkzZTczOCR2YXIkVHJlZU5vZGUge1xuICAgIGFkZENoaWxkKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5hZGQobm9kZSk7XG4gICAgICAgIG5vZGUucGFyZW50ID0gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlQ2hpbGQobm9kZSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmRlbGV0ZShub2RlKTtcbiAgICAgICAgbm9kZS5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5jb250YWluID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2NvcGVSZWYgPSBwcm9wcy5zY29wZVJlZjtcbiAgICB9XG59XG5sZXQgJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUgPSBuZXcgJDliZjcxZWEyODc5M2U3MzgkdmFyJFRyZWUoKTtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuXG5cbmZ1bmN0aW9uICRmN2RjZWZmYzVhZDc3NjhiJGV4cG9ydCQ0ZTMyOGY2MWM1Mzg2ODdmKHByb3BzID0ge30pIHtcbiAgICBsZXQgeyBhdXRvRm9jdXM6IGF1dG9Gb2N1cyA9IGZhbHNlLCBpc1RleHRJbnB1dDogaXNUZXh0SW5wdXQsIHdpdGhpbjogd2l0aGluIH0gPSBwcm9wcztcbiAgICBsZXQgc3RhdGUgPSAoMCwgJDZuZkZDJHVzZVJlZikoe1xuICAgICAgICBpc0ZvY3VzZWQ6IGZhbHNlLFxuICAgICAgICBpc0ZvY3VzVmlzaWJsZTogYXV0b0ZvY3VzIHx8ICgwLCAkNm5mRkMkaXNGb2N1c1Zpc2libGUpKClcbiAgICB9KTtcbiAgICBsZXQgW2lzRm9jdXNlZCwgc2V0Rm9jdXNlZF0gPSAoMCwgJDZuZkZDJHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IFtpc0ZvY3VzVmlzaWJsZVN0YXRlLCBzZXRGb2N1c1Zpc2libGVdID0gKDAsICQ2bmZGQyR1c2VTdGF0ZSkoKCk9PnN0YXRlLmN1cnJlbnQuaXNGb2N1c2VkICYmIHN0YXRlLmN1cnJlbnQuaXNGb2N1c1Zpc2libGUpO1xuICAgIGxldCB1cGRhdGVTdGF0ZSA9ICgwLCAkNm5mRkMkdXNlQ2FsbGJhY2spKCgpPT5zZXRGb2N1c1Zpc2libGUoc3RhdGUuY3VycmVudC5pc0ZvY3VzZWQgJiYgc3RhdGUuY3VycmVudC5pc0ZvY3VzVmlzaWJsZSksIFtdKTtcbiAgICBsZXQgb25Gb2N1c0NoYW5nZSA9ICgwLCAkNm5mRkMkdXNlQ2FsbGJhY2spKChpc0ZvY3VzZWQpPT57XG4gICAgICAgIHN0YXRlLmN1cnJlbnQuaXNGb2N1c2VkID0gaXNGb2N1c2VkO1xuICAgICAgICBzZXRGb2N1c2VkKGlzRm9jdXNlZCk7XG4gICAgICAgIHVwZGF0ZVN0YXRlKCk7XG4gICAgfSwgW1xuICAgICAgICB1cGRhdGVTdGF0ZVxuICAgIF0pO1xuICAgICgwLCAkNm5mRkMkdXNlRm9jdXNWaXNpYmxlTGlzdGVuZXIpKChpc0ZvY3VzVmlzaWJsZSk9PntcbiAgICAgICAgc3RhdGUuY3VycmVudC5pc0ZvY3VzVmlzaWJsZSA9IGlzRm9jdXNWaXNpYmxlO1xuICAgICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgIH0sIFtdLCB7XG4gICAgICAgIGlzVGV4dElucHV0OiBpc1RleHRJbnB1dFxuICAgIH0pO1xuICAgIGxldCB7IGZvY3VzUHJvcHM6IGZvY3VzUHJvcHMgfSA9ICgwLCAkNm5mRkMkdXNlRm9jdXMpKHtcbiAgICAgICAgaXNEaXNhYmxlZDogd2l0aGluLFxuICAgICAgICBvbkZvY3VzQ2hhbmdlOiBvbkZvY3VzQ2hhbmdlXG4gICAgfSk7XG4gICAgbGV0IHsgZm9jdXNXaXRoaW5Qcm9wczogZm9jdXNXaXRoaW5Qcm9wcyB9ID0gKDAsICQ2bmZGQyR1c2VGb2N1c1dpdGhpbikoe1xuICAgICAgICBpc0Rpc2FibGVkOiAhd2l0aGluLFxuICAgICAgICBvbkZvY3VzV2l0aGluQ2hhbmdlOiBvbkZvY3VzQ2hhbmdlXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNGb2N1c2VkOiBpc0ZvY3VzZWQsXG4gICAgICAgIGlzRm9jdXNWaXNpYmxlOiBpc0ZvY3VzVmlzaWJsZVN0YXRlLFxuICAgICAgICBmb2N1c1Byb3BzOiB3aXRoaW4gPyBmb2N1c1dpdGhpblByb3BzIDogZm9jdXNQcm9wc1xuICAgIH07XG59XG5cblxuZnVuY3Rpb24gJDkwNzcxODcwOGVhYjY4YWYkZXhwb3J0JDFhMzhiNGFkN2Y1NzhlMWQocHJvcHMpIHtcbiAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4sIGZvY3VzQ2xhc3M6IGZvY3VzQ2xhc3MsIGZvY3VzUmluZ0NsYXNzOiBmb2N1c1JpbmdDbGFzcyB9ID0gcHJvcHM7XG4gICAgbGV0IHsgaXNGb2N1c2VkOiBpc0ZvY3VzZWQsIGlzRm9jdXNWaXNpYmxlOiBpc0ZvY3VzVmlzaWJsZSwgZm9jdXNQcm9wczogZm9jdXNQcm9wcyB9ID0gKDAsICRmN2RjZWZmYzVhZDc3NjhiJGV4cG9ydCQ0ZTMyOGY2MWM1Mzg2ODdmKShwcm9wcyk7XG4gICAgbGV0IGNoaWxkID0gKDAsICQ2bmZGQyRyZWFjdCkuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICQ2bmZGQyRyZWFjdCkuY2xvbmVFbGVtZW50KGNoaWxkLCAoMCwgJDZuZkZDJG1lcmdlUHJvcHMpKGNoaWxkLnByb3BzLCB7XG4gICAgICAgIC4uLmZvY3VzUHJvcHMsXG4gICAgICAgIGNsYXNzTmFtZTogKDAsICQ2bmZGQyRjbHN4KSh7XG4gICAgICAgICAgICBbZm9jdXNDbGFzcyB8fCBcIlwiXTogaXNGb2N1c2VkLFxuICAgICAgICAgICAgW2ZvY3VzUmluZ0NsYXNzIHx8IFwiXCJdOiBpc0ZvY3VzVmlzaWJsZVxuICAgICAgICB9KVxuICAgIH0pKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuXG5sZXQgJGU2YWZiZDgzZmU2ZWJiZDIkdmFyJEZvY3VzYWJsZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovICgwLCAkNm5mRkMkcmVhY3QpLmNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiAkZTZhZmJkODNmZTZlYmJkMiR2YXIkdXNlRm9jdXNhYmxlQ29udGV4dChyZWYpIHtcbiAgICBsZXQgY29udGV4dCA9ICgwLCAkNm5mRkMkdXNlQ29udGV4dCkoJGU2YWZiZDgzZmU2ZWJiZDIkdmFyJEZvY3VzYWJsZUNvbnRleHQpIHx8IHt9O1xuICAgICgwLCAkNm5mRkMkdXNlU3luY1JlZikoY29udGV4dCwgcmVmKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBsZXQgeyByZWY6IF8sIC4uLm90aGVyUHJvcHMgfSA9IGNvbnRleHQ7XG4gICAgcmV0dXJuIG90aGVyUHJvcHM7XG59XG4vKipcbiAqIFByb3ZpZGVzIERPTSBwcm9wcyB0byB0aGUgbmVhcmVzdCBmb2N1c2FibGUgY2hpbGQuXG4gKi8gZnVuY3Rpb24gJGU2YWZiZDgzZmU2ZWJiZDIkdmFyJEZvY3VzYWJsZVByb3ZpZGVyKHByb3BzLCByZWYpIHtcbiAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4sIC4uLm90aGVyUHJvcHMgfSA9IHByb3BzO1xuICAgIGxldCBvYmpSZWYgPSAoMCwgJDZuZkZDJHVzZU9iamVjdFJlZikocmVmKTtcbiAgICBsZXQgY29udGV4dCA9IHtcbiAgICAgICAgLi4ub3RoZXJQcm9wcyxcbiAgICAgICAgcmVmOiBvYmpSZWZcbiAgICB9O1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkNm5mRkMkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoJGU2YWZiZDgzZmU2ZWJiZDIkdmFyJEZvY3VzYWJsZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGNvbnRleHRcbiAgICB9LCBjaGlsZHJlbik7XG59XG5sZXQgJGU2YWZiZDgzZmU2ZWJiZDIkZXhwb3J0JDEzZjMyMDJhM2U1ZGRkNSA9IC8qI19fUFVSRV9fKi8gKDAsICQ2bmZGQyRyZWFjdCkuZm9yd2FyZFJlZigkZTZhZmJkODNmZTZlYmJkMiR2YXIkRm9jdXNhYmxlUHJvdmlkZXIpO1xuZnVuY3Rpb24gJGU2YWZiZDgzZmU2ZWJiZDIkZXhwb3J0JDRjMDE0ZGU3Yzg5NDBiNGMocHJvcHMsIGRvbVJlZikge1xuICAgIGxldCB7IGZvY3VzUHJvcHM6IGZvY3VzUHJvcHMgfSA9ICgwLCAkNm5mRkMkdXNlRm9jdXMpKHByb3BzKTtcbiAgICBsZXQgeyBrZXlib2FyZFByb3BzOiBrZXlib2FyZFByb3BzIH0gPSAoMCwgJDZuZkZDJHVzZUtleWJvYXJkKShwcm9wcyk7XG4gICAgbGV0IGludGVyYWN0aW9ucyA9ICgwLCAkNm5mRkMkbWVyZ2VQcm9wcykoZm9jdXNQcm9wcywga2V5Ym9hcmRQcm9wcyk7XG4gICAgbGV0IGRvbVByb3BzID0gJGU2YWZiZDgzZmU2ZWJiZDIkdmFyJHVzZUZvY3VzYWJsZUNvbnRleHQoZG9tUmVmKTtcbiAgICBsZXQgaW50ZXJhY3Rpb25Qcm9wcyA9IHByb3BzLmlzRGlzYWJsZWQgPyB7fSA6IGRvbVByb3BzO1xuICAgIGxldCBhdXRvRm9jdXNSZWYgPSAoMCwgJDZuZkZDJHVzZVJlZikocHJvcHMuYXV0b0ZvY3VzKTtcbiAgICAoMCwgJDZuZkZDJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKGF1dG9Gb2N1c1JlZi5jdXJyZW50ICYmIGRvbVJlZi5jdXJyZW50KSAoMCwgJDZhOTkxOTUzMzJlZGVjOGIkZXhwb3J0JDgwZjNlMTQ3ZDc4MTU3MWMpKGRvbVJlZi5jdXJyZW50KTtcbiAgICAgICAgYXV0b0ZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LCBbXG4gICAgICAgIGRvbVJlZlxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvY3VzYWJsZVByb3BzOiAoMCwgJDZuZkZDJG1lcmdlUHJvcHMpKHtcbiAgICAgICAgICAgIC4uLmludGVyYWN0aW9ucyxcbiAgICAgICAgICAgIHRhYkluZGV4OiBwcm9wcy5leGNsdWRlRnJvbVRhYk9yZGVyICYmICFwcm9wcy5pc0Rpc2FibGVkID8gLTEgOiB1bmRlZmluZWRcbiAgICAgICAgfSwgaW50ZXJhY3Rpb25Qcm9wcylcbiAgICB9O1xufVxuXG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuZnVuY3Rpb24gJDgzMDEzNjM1YjAyNGFlM2QkZXhwb3J0JGVhYzE4OTU5OTJiOWYzZDYocmVmLCBvcHRpb25zKSB7XG4gICAgbGV0IGlzRGlzYWJsZWQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaXNEaXNhYmxlZDtcbiAgICBsZXQgW2hhc1RhYmJhYmxlQ2hpbGQsIHNldEhhc1RhYmJhYmxlQ2hpbGRdID0gKDAsICQ2bmZGQyR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgICgwLCAkNm5mRkMkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoKHJlZiA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5jdXJyZW50KSAmJiAhaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgbGV0IHVwZGF0ZSA9ICgpPT57XG4gICAgICAgICAgICAgICAgaWYgKHJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3YWxrZXIgPSAoMCwgJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDJkNmVjOGZjMzc1Y2VhZmEpKHJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJiYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0SGFzVGFiYmFibGVDaGlsZCghIXdhbGtlci5uZXh0Tm9kZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgd2hlbiBuZXcgZWxlbWVudHMgYXJlIGluc2VydGVkLCBvciB0aGUgdGFiSW5kZXgvZGlzYWJsZWQgYXR0cmlidXRlIHVwZGF0ZXMuXG4gICAgICAgICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih1cGRhdGUpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShyZWYuY3VycmVudCwge1xuICAgICAgICAgICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBbXG4gICAgICAgICAgICAgICAgICAgIFwidGFiSW5kZXhcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICAgICAvLyBEaXNjb25uZWN0IG11dGF0aW9uIG9ic2VydmVyIHdoZW4gYSBSZWFjdCB1cGRhdGUgb2NjdXJzIG9uIHRoZSB0b3AtbGV2ZWwgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgLy8gc28gd2UgdXBkYXRlIHN5bmNocm9ub3VzbHkgYWZ0ZXIgcmUtcmVuZGVyaW5nLiBPdGhlcndpc2UgUmVhY3Qgd2lsbCBlbWl0IGFjdCB3YXJuaW5nc1xuICAgICAgICAgICAgICAgIC8vIGluIHRlc3RzIHNpbmNlIG11dGF0aW9uIG9ic2VydmVycyBmaXJlIGFzeW5jaHJvbm91c2x5LiBUaGUgbXV0YXRpb24gb2JzZXJ2ZXIgaXMgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgLy8gc28gd2UgYWxzbyB1cGRhdGUgaWYgYSBjaGlsZCBjb21wb25lbnQgcmUtcmVuZGVycyBhbmQgYWRkcy9yZW1vdmVzIHNvbWV0aGluZyB0YWJiYWJsZS5cbiAgICAgICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzRGlzYWJsZWQgPyBmYWxzZSA6IGhhc1RhYmJhYmxlQ2hpbGQ7XG59XG5cblxuXG5cbmV4cG9ydCB7JDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDIwZTQwMjg5NjQxZmJiYjYgYXMgRm9jdXNTY29wZSwgJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDEwYzUxNjk3NTVjZTdiZDcgYXMgdXNlRm9jdXNNYW5hZ2VyLCAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMmQ2ZWM4ZmMzNzVjZWFmYSBhcyBnZXRGb2N1c2FibGVUcmVlV2Fsa2VyLCAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkYzUyNTFiOWUxMjRiZjI5IGFzIGNyZWF0ZUZvY3VzTWFuYWdlciwgJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDEyNTgzOTVmOTliZjljYmYgYXMgaXNFbGVtZW50SW5DaGlsZE9mQWN0aXZlU2NvcGUsICQ5MDc3MTg3MDhlYWI2OGFmJGV4cG9ydCQxYTM4YjRhZDdmNTc4ZTFkIGFzIEZvY3VzUmluZywgJGU2YWZiZDgzZmU2ZWJiZDIkZXhwb3J0JDEzZjMyMDJhM2U1ZGRkNSBhcyBGb2N1c2FibGVQcm92aWRlciwgJGU2YWZiZDgzZmU2ZWJiZDIkZXhwb3J0JDRjMDE0ZGU3Yzg5NDBiNGMgYXMgdXNlRm9jdXNhYmxlLCAkZjdkY2VmZmM1YWQ3NzY4YiRleHBvcnQkNGUzMjhmNjFjNTM4Njg3ZiBhcyB1c2VGb2N1c1JpbmcsICQ2YTk5MTk1MzMyZWRlYzhiJGV4cG9ydCQ4MGYzZTE0N2Q3ODE1NzFjIGFzIGZvY3VzU2FmZWx5LCAkODMwMTM2MzViMDI0YWUzZCRleHBvcnQkZWFjMTg5NTk5MmI5ZjNkNiBhcyB1c2VIYXNUYWJiYWJsZUNoaWxkfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@react-aria/focus/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@react-aria/i18n/dist/real-module.mjs":
/*!****************************************************************!*\
  !*** ../../node_modules/@react-aria/i18n/dist/real-module.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I18nProvider: () => (/* binding */ $18f2051aff69b9bf$export$a54013f0d02a8f82),\n/* harmony export */   useCollator: () => (/* binding */ $325a3faab7a68acd$export$a16aca283550c30d),\n/* harmony export */   useDateFormatter: () => (/* binding */ $896ba0a80a8f4d36$export$85fd5fdf27bacc79),\n/* harmony export */   useFilter: () => (/* binding */ $bb77f239b46e8c72$export$3274cf84b703fff),\n/* harmony export */   useListFormatter: () => (/* binding */ $33bf17300c498528$export$a2f47a3d2973640),\n/* harmony export */   useLocale: () => (/* binding */ $18f2051aff69b9bf$export$43bb16f9c6d9e3f7),\n/* harmony export */   useLocalizedStringFormatter: () => (/* binding */ $fca6afa0e843324b$export$f12b703ca79dfbb1),\n/* harmony export */   useNumberFormatter: () => (/* binding */ $a916eb452884faea$export$b7a616150fdb9f44)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_ssr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/ssr */ \"(ssr)/../../node_modules/@react-aria/ssr/dist/import.mjs\");\n/* harmony import */ var _internationalized_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @internationalized/string */ \"(ssr)/../../node_modules/@internationalized/string/dist/import.mjs\");\n/* harmony import */ var _internationalized_date__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @internationalized/date */ \"(ssr)/../../node_modules/@internationalized/date/dist/import.mjs\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/../../node_modules/@react-aria/utils/dist/import.mjs\");\n/* harmony import */ var _internationalized_number__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @internationalized/number */ \"(ssr)/../../node_modules/@internationalized/number/dist/import.mjs\");\n\n\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // https://en.wikipedia.org/wiki/Right-to-left\nconst $148a7a147e38ea7f$var$RTL_SCRIPTS = new Set([\n    \"Arab\",\n    \"Syrc\",\n    \"Samr\",\n    \"Mand\",\n    \"Thaa\",\n    \"Mend\",\n    \"Nkoo\",\n    \"Adlm\",\n    \"Rohg\",\n    \"Hebr\"\n]);\nconst $148a7a147e38ea7f$var$RTL_LANGS = new Set([\n    \"ae\",\n    \"ar\",\n    \"arc\",\n    \"bcc\",\n    \"bqi\",\n    \"ckb\",\n    \"dv\",\n    \"fa\",\n    \"glk\",\n    \"he\",\n    \"ku\",\n    \"mzn\",\n    \"nqo\",\n    \"pnb\",\n    \"ps\",\n    \"sd\",\n    \"ug\",\n    \"ur\",\n    \"yi\"\n]);\nfunction $148a7a147e38ea7f$export$702d680b21cbd764(locale) {\n    // If the Intl.Locale API is available, use it to get the script for the locale.\n    // This is more accurate than guessing by language, since languages can be written in multiple scripts.\n    // @ts-ignore\n    if (Intl.Locale) {\n        // @ts-ignore\n        let script = new Intl.Locale(locale).maximize().script;\n        if (!script) return false;\n        return $148a7a147e38ea7f$var$RTL_SCRIPTS.has(script);\n    }\n    // If not, just guess by the language (first part of the locale)\n    let lang = locale.split(\"-\")[0];\n    return $148a7a147e38ea7f$var$RTL_LANGS.has(lang);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nfunction $1e5a04cdaf7d1af8$export$f09106e7c6677ec5() {\n    // @ts-ignore\n    let locale = typeof navigator !== \"undefined\" && (navigator.language || navigator.userLanguage) || \"en-US\";\n    try {\n        // @ts-ignore\n        Intl.DateTimeFormat.supportedLocalesOf([\n            locale\n        ]);\n    } catch (_err) {\n        locale = \"en-US\";\n    }\n    return {\n        locale: locale,\n        direction: (0, $148a7a147e38ea7f$export$702d680b21cbd764)(locale) ? \"rtl\" : \"ltr\"\n    };\n}\nlet $1e5a04cdaf7d1af8$var$currentLocale = $1e5a04cdaf7d1af8$export$f09106e7c6677ec5();\nlet $1e5a04cdaf7d1af8$var$listeners = new Set();\nfunction $1e5a04cdaf7d1af8$var$updateLocale() {\n    $1e5a04cdaf7d1af8$var$currentLocale = $1e5a04cdaf7d1af8$export$f09106e7c6677ec5();\n    for (let listener of $1e5a04cdaf7d1af8$var$listeners)listener($1e5a04cdaf7d1af8$var$currentLocale);\n}\nfunction $1e5a04cdaf7d1af8$export$188ec29ebc2bdc3a() {\n    let isSSR = (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_1__.useIsSSR)();\n    let [defaultLocale, setDefaultLocale] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($1e5a04cdaf7d1af8$var$currentLocale);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if ($1e5a04cdaf7d1af8$var$listeners.size === 0) window.addEventListener(\"languagechange\", $1e5a04cdaf7d1af8$var$updateLocale);\n        $1e5a04cdaf7d1af8$var$listeners.add(setDefaultLocale);\n        return ()=>{\n            $1e5a04cdaf7d1af8$var$listeners.delete(setDefaultLocale);\n            if ($1e5a04cdaf7d1af8$var$listeners.size === 0) window.removeEventListener(\"languagechange\", $1e5a04cdaf7d1af8$var$updateLocale);\n        };\n    }, []);\n    // We cannot determine the browser's language on the server, so default to\n    // en-US. This will be updated after hydration on the client to the correct value.\n    if (isSSR) return {\n        locale: \"en-US\",\n        direction: \"ltr\"\n    };\n    return defaultLocale;\n}\n\n\n\nconst $18f2051aff69b9bf$var$I18nContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext(null);\nfunction $18f2051aff69b9bf$export$a54013f0d02a8f82(props) {\n    let { locale: locale, children: children } = props;\n    let defaultLocale = (0, $1e5a04cdaf7d1af8$export$188ec29ebc2bdc3a)();\n    let value = locale ? {\n        locale: locale,\n        direction: (0, $148a7a147e38ea7f$export$702d680b21cbd764)(locale) ? \"rtl\" : \"ltr\"\n    } : defaultLocale;\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($18f2051aff69b9bf$var$I18nContext.Provider, {\n        value: value\n    }, children);\n}\nfunction $18f2051aff69b9bf$export$43bb16f9c6d9e3f7() {\n    let defaultLocale = (0, $1e5a04cdaf7d1af8$export$188ec29ebc2bdc3a)();\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($18f2051aff69b9bf$var$I18nContext);\n    return context || defaultLocale;\n}\n\n\nvar $2aa2084a6c2b6b4f$exports = {};\n\"use strict\";\n\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nconst $fca6afa0e843324b$var$cache = new WeakMap();\nfunction $fca6afa0e843324b$var$getCachedDictionary(strings) {\n    let dictionary = $fca6afa0e843324b$var$cache.get(strings);\n    if (!dictionary) {\n        dictionary = new (0, _internationalized_string__WEBPACK_IMPORTED_MODULE_2__.LocalizedStringDictionary)(strings);\n        $fca6afa0e843324b$var$cache.set(strings, dictionary);\n    }\n    return dictionary;\n}\nfunction $fca6afa0e843324b$export$f12b703ca79dfbb1(strings) {\n    let { locale: locale } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();\n    let dictionary = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$fca6afa0e843324b$var$getCachedDictionary(strings), [\n        strings\n    ]);\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _internationalized_string__WEBPACK_IMPORTED_MODULE_2__.LocalizedStringFormatter)(locale, dictionary), [\n        locale,\n        dictionary\n    ]);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nfunction $33bf17300c498528$export$a2f47a3d2973640(options = {}) {\n    let { locale: locale } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new Intl.ListFormat(locale, options), [\n        locale,\n        options\n    ]);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\nfunction $896ba0a80a8f4d36$export$85fd5fdf27bacc79(options) {\n    // Reuse last options object if it is shallowly equal, which allows the useMemo result to also be reused.\n    options = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useDeepMemo)(options !== null && options !== void 0 ? options : {}, $896ba0a80a8f4d36$var$isEqual);\n    let { locale: locale } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_4__.DateFormatter)(locale, options), [\n        locale,\n        options\n    ]);\n}\nfunction $896ba0a80a8f4d36$var$isEqual(a, b) {\n    if (a === b) return true;\n    let aKeys = Object.keys(a);\n    let bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length) return false;\n    for (let key of aKeys){\n        if (b[key] !== a[key]) return false;\n    }\n    return true;\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nfunction $a916eb452884faea$export$b7a616150fdb9f44(options = {}) {\n    let { locale: locale } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _internationalized_number__WEBPACK_IMPORTED_MODULE_5__.NumberFormatter)(locale, options), [\n        locale,\n        options\n    ]);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nlet $325a3faab7a68acd$var$cache = new Map();\nfunction $325a3faab7a68acd$export$a16aca283550c30d(options) {\n    let { locale: locale } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();\n    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : \"\");\n    if ($325a3faab7a68acd$var$cache.has(cacheKey)) return $325a3faab7a68acd$var$cache.get(cacheKey);\n    let formatter = new Intl.Collator(locale, options);\n    $325a3faab7a68acd$var$cache.set(cacheKey, formatter);\n    return formatter;\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nfunction $bb77f239b46e8c72$export$3274cf84b703fff(options) {\n    let collator = (0, $325a3faab7a68acd$export$a16aca283550c30d)({\n        usage: \"search\",\n        ...options\n    });\n    // TODO(later): these methods don't currently support the ignorePunctuation option.\n    let startsWith = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((string, substring)=>{\n        if (substring.length === 0) return true;\n        // Normalize both strings so we can slice safely\n        // TODO: take into account the ignorePunctuation option as well...\n        string = string.normalize(\"NFC\");\n        substring = substring.normalize(\"NFC\");\n        return collator.compare(string.slice(0, substring.length), substring) === 0;\n    }, [\n        collator\n    ]);\n    let endsWith = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((string, substring)=>{\n        if (substring.length === 0) return true;\n        string = string.normalize(\"NFC\");\n        substring = substring.normalize(\"NFC\");\n        return collator.compare(string.slice(-substring.length), substring) === 0;\n    }, [\n        collator\n    ]);\n    let contains = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((string, substring)=>{\n        if (substring.length === 0) return true;\n        string = string.normalize(\"NFC\");\n        substring = substring.normalize(\"NFC\");\n        let scan = 0;\n        let sliceLen = substring.length;\n        for(; scan + sliceLen <= string.length; scan++){\n            let slice = string.slice(scan, scan + sliceLen);\n            if (collator.compare(substring, slice) === 0) return true;\n        }\n        return false;\n    }, [\n        collator\n    ]);\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            startsWith: startsWith,\n            endsWith: endsWith,\n            contains: contains\n        }), [\n        startsWith,\n        endsWith,\n        contains\n    ]);\n}\n\n\n\n\n\n//# sourceMappingURL=real-module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL2kxOG4vZGlzdC9yZWFsLW1vZHVsZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEw7QUFDbEk7QUFDeUc7QUFDdkY7QUFDVjtBQUNnQjs7QUFFcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQWU7QUFDbkMsZ0RBQWdELDJDQUFlO0FBQy9ELFFBQVEsNENBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEsNERBQTRELGtDQUFZO0FBQ3hFO0FBQ0EsVUFBVSxxQ0FBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNkJBQTZCLGtDQUFZO0FBQ3pDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2Q0FBaUI7QUFDdkM7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0ZBQWdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQix5QkFBeUIsMENBQWM7QUFDdkM7QUFDQTtBQUNBLGVBQWUsMENBQWMsY0FBYywrRUFBK0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThEO0FBQzlELFVBQVUsaUJBQWlCO0FBQzNCLGVBQWUsMENBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0Esa0JBQWtCLDBEQUFrQix1REFBdUQ7QUFDM0YsVUFBVSxpQkFBaUI7QUFDM0IsZUFBZSwwQ0FBYyxjQUFjLGtFQUFvQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSwrREFBK0Q7QUFDL0QsVUFBVSxpQkFBaUI7QUFDM0IsZUFBZSwwQ0FBYyxjQUFjLHNFQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5QkFBeUIsOENBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQ0FBa0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUsMENBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS29mO0FBQ3BmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL2kxOG4vZGlzdC9yZWFsLW1vZHVsZS5tanM/YmQzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJGlGQURnJHJlYWN0LCB7dXNlQ29udGV4dCBhcyAkaUZBRGckdXNlQ29udGV4dCwgdXNlU3RhdGUgYXMgJGlGQURnJHVzZVN0YXRlLCB1c2VFZmZlY3QgYXMgJGlGQURnJHVzZUVmZmVjdCwgdXNlTWVtbyBhcyAkaUZBRGckdXNlTWVtbywgdXNlQ2FsbGJhY2sgYXMgJGlGQURnJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlSXNTU1IgYXMgJGlGQURnJHVzZUlzU1NSfSBmcm9tIFwiQHJlYWN0LWFyaWEvc3NyXCI7XG5pbXBvcnQge0xvY2FsaXplZFN0cmluZ0RpY3Rpb25hcnkgYXMgJGlGQURnJExvY2FsaXplZFN0cmluZ0RpY3Rpb25hcnksIExvY2FsaXplZFN0cmluZ0Zvcm1hdHRlciBhcyAkaUZBRGckTG9jYWxpemVkU3RyaW5nRm9ybWF0dGVyfSBmcm9tIFwiQGludGVybmF0aW9uYWxpemVkL3N0cmluZ1wiO1xuaW1wb3J0IHtEYXRlRm9ybWF0dGVyIGFzICRpRkFEZyREYXRlRm9ybWF0dGVyfSBmcm9tIFwiQGludGVybmF0aW9uYWxpemVkL2RhdGVcIjtcbmltcG9ydCB7dXNlRGVlcE1lbW8gYXMgJGlGQURnJHVzZURlZXBNZW1vfSBmcm9tIFwiQHJlYWN0LWFyaWEvdXRpbHNcIjtcbmltcG9ydCB7TnVtYmVyRm9ybWF0dGVyIGFzICRpRkFEZyROdW1iZXJGb3JtYXR0ZXJ9IGZyb20gXCJAaW50ZXJuYXRpb25hbGl6ZWQvbnVtYmVyXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JpZ2h0LXRvLWxlZnRcbmNvbnN0ICQxNDhhN2ExNDdlMzhlYTdmJHZhciRSVExfU0NSSVBUUyA9IG5ldyBTZXQoW1xuICAgIFwiQXJhYlwiLFxuICAgIFwiU3lyY1wiLFxuICAgIFwiU2FtclwiLFxuICAgIFwiTWFuZFwiLFxuICAgIFwiVGhhYVwiLFxuICAgIFwiTWVuZFwiLFxuICAgIFwiTmtvb1wiLFxuICAgIFwiQWRsbVwiLFxuICAgIFwiUm9oZ1wiLFxuICAgIFwiSGViclwiXG5dKTtcbmNvbnN0ICQxNDhhN2ExNDdlMzhlYTdmJHZhciRSVExfTEFOR1MgPSBuZXcgU2V0KFtcbiAgICBcImFlXCIsXG4gICAgXCJhclwiLFxuICAgIFwiYXJjXCIsXG4gICAgXCJiY2NcIixcbiAgICBcImJxaVwiLFxuICAgIFwiY2tiXCIsXG4gICAgXCJkdlwiLFxuICAgIFwiZmFcIixcbiAgICBcImdsa1wiLFxuICAgIFwiaGVcIixcbiAgICBcImt1XCIsXG4gICAgXCJtem5cIixcbiAgICBcIm5xb1wiLFxuICAgIFwicG5iXCIsXG4gICAgXCJwc1wiLFxuICAgIFwic2RcIixcbiAgICBcInVnXCIsXG4gICAgXCJ1clwiLFxuICAgIFwieWlcIlxuXSk7XG5mdW5jdGlvbiAkMTQ4YTdhMTQ3ZTM4ZWE3ZiRleHBvcnQkNzAyZDY4MGIyMWNiZDc2NChsb2NhbGUpIHtcbiAgICAvLyBJZiB0aGUgSW50bC5Mb2NhbGUgQVBJIGlzIGF2YWlsYWJsZSwgdXNlIGl0IHRvIGdldCB0aGUgc2NyaXB0IGZvciB0aGUgbG9jYWxlLlxuICAgIC8vIFRoaXMgaXMgbW9yZSBhY2N1cmF0ZSB0aGFuIGd1ZXNzaW5nIGJ5IGxhbmd1YWdlLCBzaW5jZSBsYW5ndWFnZXMgY2FuIGJlIHdyaXR0ZW4gaW4gbXVsdGlwbGUgc2NyaXB0cy5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKEludGwuTG9jYWxlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IHNjcmlwdCA9IG5ldyBJbnRsLkxvY2FsZShsb2NhbGUpLm1heGltaXplKCkuc2NyaXB0O1xuICAgICAgICBpZiAoIXNjcmlwdCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gJDE0OGE3YTE0N2UzOGVhN2YkdmFyJFJUTF9TQ1JJUFRTLmhhcyhzY3JpcHQpO1xuICAgIH1cbiAgICAvLyBJZiBub3QsIGp1c3QgZ3Vlc3MgYnkgdGhlIGxhbmd1YWdlIChmaXJzdCBwYXJ0IG9mIHRoZSBsb2NhbGUpXG4gICAgbGV0IGxhbmcgPSBsb2NhbGUuc3BsaXQoXCItXCIpWzBdO1xuICAgIHJldHVybiAkMTQ4YTdhMTQ3ZTM4ZWE3ZiR2YXIkUlRMX0xBTkdTLmhhcyhsYW5nKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuZnVuY3Rpb24gJDFlNWEwNGNkYWY3ZDFhZjgkZXhwb3J0JGYwOTEwNmU3YzY2NzdlYzUoKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGxldCBsb2NhbGUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIChuYXZpZ2F0b3IubGFuZ3VhZ2UgfHwgbmF2aWdhdG9yLnVzZXJMYW5ndWFnZSkgfHwgXCJlbi1VU1wiO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgSW50bC5EYXRlVGltZUZvcm1hdC5zdXBwb3J0ZWRMb2NhbGVzT2YoW1xuICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgIF0pO1xuICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgbG9jYWxlID0gXCJlbi1VU1wiO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgZGlyZWN0aW9uOiAoMCwgJDE0OGE3YTE0N2UzOGVhN2YkZXhwb3J0JDcwMmQ2ODBiMjFjYmQ3NjQpKGxvY2FsZSkgPyBcInJ0bFwiIDogXCJsdHJcIlxuICAgIH07XG59XG5sZXQgJDFlNWEwNGNkYWY3ZDFhZjgkdmFyJGN1cnJlbnRMb2NhbGUgPSAkMWU1YTA0Y2RhZjdkMWFmOCRleHBvcnQkZjA5MTA2ZTdjNjY3N2VjNSgpO1xubGV0ICQxZTVhMDRjZGFmN2QxYWY4JHZhciRsaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiAkMWU1YTA0Y2RhZjdkMWFmOCR2YXIkdXBkYXRlTG9jYWxlKCkge1xuICAgICQxZTVhMDRjZGFmN2QxYWY4JHZhciRjdXJyZW50TG9jYWxlID0gJDFlNWEwNGNkYWY3ZDFhZjgkZXhwb3J0JGYwOTEwNmU3YzY2NzdlYzUoKTtcbiAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiAkMWU1YTA0Y2RhZjdkMWFmOCR2YXIkbGlzdGVuZXJzKWxpc3RlbmVyKCQxZTVhMDRjZGFmN2QxYWY4JHZhciRjdXJyZW50TG9jYWxlKTtcbn1cbmZ1bmN0aW9uICQxZTVhMDRjZGFmN2QxYWY4JGV4cG9ydCQxODhlYzI5ZWJjMmJkYzNhKCkge1xuICAgIGxldCBpc1NTUiA9ICgwLCAkaUZBRGckdXNlSXNTU1IpKCk7XG4gICAgbGV0IFtkZWZhdWx0TG9jYWxlLCBzZXREZWZhdWx0TG9jYWxlXSA9ICgwLCAkaUZBRGckdXNlU3RhdGUpKCQxZTVhMDRjZGFmN2QxYWY4JHZhciRjdXJyZW50TG9jYWxlKTtcbiAgICAoMCwgJGlGQURnJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKCQxZTVhMDRjZGFmN2QxYWY4JHZhciRsaXN0ZW5lcnMuc2l6ZSA9PT0gMCkgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsYW5ndWFnZWNoYW5nZVwiLCAkMWU1YTA0Y2RhZjdkMWFmOCR2YXIkdXBkYXRlTG9jYWxlKTtcbiAgICAgICAgJDFlNWEwNGNkYWY3ZDFhZjgkdmFyJGxpc3RlbmVycy5hZGQoc2V0RGVmYXVsdExvY2FsZSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgJDFlNWEwNGNkYWY3ZDFhZjgkdmFyJGxpc3RlbmVycy5kZWxldGUoc2V0RGVmYXVsdExvY2FsZSk7XG4gICAgICAgICAgICBpZiAoJDFlNWEwNGNkYWY3ZDFhZjgkdmFyJGxpc3RlbmVycy5zaXplID09PSAwKSB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxhbmd1YWdlY2hhbmdlXCIsICQxZTVhMDRjZGFmN2QxYWY4JHZhciR1cGRhdGVMb2NhbGUpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICAvLyBXZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBicm93c2VyJ3MgbGFuZ3VhZ2Ugb24gdGhlIHNlcnZlciwgc28gZGVmYXVsdCB0b1xuICAgIC8vIGVuLVVTLiBUaGlzIHdpbGwgYmUgdXBkYXRlZCBhZnRlciBoeWRyYXRpb24gb24gdGhlIGNsaWVudCB0byB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBpZiAoaXNTU1IpIHJldHVybiB7XG4gICAgICAgIGxvY2FsZTogXCJlbi1VU1wiLFxuICAgICAgICBkaXJlY3Rpb246IFwibHRyXCJcbiAgICB9O1xuICAgIHJldHVybiBkZWZhdWx0TG9jYWxlO1xufVxuXG5cblxuY29uc3QgJDE4ZjIwNTFhZmY2OWI5YmYkdmFyJEkxOG5Db250ZXh0ID0gLyojX19QVVJFX18qLyAoMCwgJGlGQURnJHJlYWN0KS5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gJDE4ZjIwNTFhZmY2OWI5YmYkZXhwb3J0JGE1NDAxM2YwZDAyYThmODIocHJvcHMpIHtcbiAgICBsZXQgeyBsb2NhbGU6IGxvY2FsZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgICBsZXQgZGVmYXVsdExvY2FsZSA9ICgwLCAkMWU1YTA0Y2RhZjdkMWFmOCRleHBvcnQkMTg4ZWMyOWViYzJiZGMzYSkoKTtcbiAgICBsZXQgdmFsdWUgPSBsb2NhbGUgPyB7XG4gICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICBkaXJlY3Rpb246ICgwLCAkMTQ4YTdhMTQ3ZTM4ZWE3ZiRleHBvcnQkNzAyZDY4MGIyMWNiZDc2NCkobG9jYWxlKSA/IFwicnRsXCIgOiBcImx0clwiXG4gICAgfSA6IGRlZmF1bHRMb2NhbGU7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICRpRkFEZyRyZWFjdCkuY3JlYXRlRWxlbWVudCgkMThmMjA1MWFmZjY5YjliZiR2YXIkSTE4bkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gJDE4ZjIwNTFhZmY2OWI5YmYkZXhwb3J0JDQzYmIxNmY5YzZkOWUzZjcoKSB7XG4gICAgbGV0IGRlZmF1bHRMb2NhbGUgPSAoMCwgJDFlNWEwNGNkYWY3ZDFhZjgkZXhwb3J0JDE4OGVjMjllYmMyYmRjM2EpKCk7XG4gICAgbGV0IGNvbnRleHQgPSAoMCwgJGlGQURnJHVzZUNvbnRleHQpKCQxOGYyMDUxYWZmNjliOWJmJHZhciRJMThuQ29udGV4dCk7XG4gICAgcmV0dXJuIGNvbnRleHQgfHwgZGVmYXVsdExvY2FsZTtcbn1cblxuXG52YXIgJDJhYTIwODRhNmMyYjZiNGYkZXhwb3J0cyA9IHt9O1xuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbmNvbnN0ICRmY2E2YWZhMGU4NDMzMjRiJHZhciRjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiAkZmNhNmFmYTBlODQzMzI0YiR2YXIkZ2V0Q2FjaGVkRGljdGlvbmFyeShzdHJpbmdzKSB7XG4gICAgbGV0IGRpY3Rpb25hcnkgPSAkZmNhNmFmYTBlODQzMzI0YiR2YXIkY2FjaGUuZ2V0KHN0cmluZ3MpO1xuICAgIGlmICghZGljdGlvbmFyeSkge1xuICAgICAgICBkaWN0aW9uYXJ5ID0gbmV3ICgwLCAkaUZBRGckTG9jYWxpemVkU3RyaW5nRGljdGlvbmFyeSkoc3RyaW5ncyk7XG4gICAgICAgICRmY2E2YWZhMGU4NDMzMjRiJHZhciRjYWNoZS5zZXQoc3RyaW5ncywgZGljdGlvbmFyeSk7XG4gICAgfVxuICAgIHJldHVybiBkaWN0aW9uYXJ5O1xufVxuZnVuY3Rpb24gJGZjYTZhZmEwZTg0MzMyNGIkZXhwb3J0JGYxMmI3MDNjYTc5ZGZiYjEoc3RyaW5ncykge1xuICAgIGxldCB7IGxvY2FsZTogbG9jYWxlIH0gPSAoMCwgJDE4ZjIwNTFhZmY2OWI5YmYkZXhwb3J0JDQzYmIxNmY5YzZkOWUzZjcpKCk7XG4gICAgbGV0IGRpY3Rpb25hcnkgPSAoMCwgJGlGQURnJHVzZU1lbW8pKCgpPT4kZmNhNmFmYTBlODQzMzI0YiR2YXIkZ2V0Q2FjaGVkRGljdGlvbmFyeShzdHJpbmdzKSwgW1xuICAgICAgICBzdHJpbmdzXG4gICAgXSk7XG4gICAgcmV0dXJuICgwLCAkaUZBRGckdXNlTWVtbykoKCk9Pm5ldyAoMCwgJGlGQURnJExvY2FsaXplZFN0cmluZ0Zvcm1hdHRlcikobG9jYWxlLCBkaWN0aW9uYXJ5KSwgW1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIGRpY3Rpb25hcnlcbiAgICBdKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmZ1bmN0aW9uICQzM2JmMTczMDBjNDk4NTI4JGV4cG9ydCRhMmY0N2EzZDI5NzM2NDAob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHsgbG9jYWxlOiBsb2NhbGUgfSA9ICgwLCAkMThmMjA1MWFmZjY5YjliZiRleHBvcnQkNDNiYjE2ZjljNmQ5ZTNmNykoKTtcbiAgICByZXR1cm4gKDAsICRpRkFEZyR1c2VNZW1vKSgoKT0+bmV3IEludGwuTGlzdEZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLCBbXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgb3B0aW9uc1xuICAgIF0pO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5cbmZ1bmN0aW9uICQ4OTZiYTBhODBhOGY0ZDM2JGV4cG9ydCQ4NWZkNWZkZjI3YmFjYzc5KG9wdGlvbnMpIHtcbiAgICAvLyBSZXVzZSBsYXN0IG9wdGlvbnMgb2JqZWN0IGlmIGl0IGlzIHNoYWxsb3dseSBlcXVhbCwgd2hpY2ggYWxsb3dzIHRoZSB1c2VNZW1vIHJlc3VsdCB0byBhbHNvIGJlIHJldXNlZC5cbiAgICBvcHRpb25zID0gKDAsICRpRkFEZyR1c2VEZWVwTWVtbykob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30sICQ4OTZiYTBhODBhOGY0ZDM2JHZhciRpc0VxdWFsKTtcbiAgICBsZXQgeyBsb2NhbGU6IGxvY2FsZSB9ID0gKDAsICQxOGYyMDUxYWZmNjliOWJmJGV4cG9ydCQ0M2JiMTZmOWM2ZDllM2Y3KSgpO1xuICAgIHJldHVybiAoMCwgJGlGQURnJHVzZU1lbW8pKCgpPT5uZXcgKDAsICRpRkFEZyREYXRlRm9ybWF0dGVyKShsb2NhbGUsIG9wdGlvbnMpLCBbXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgb3B0aW9uc1xuICAgIF0pO1xufVxuZnVuY3Rpb24gJDg5NmJhMGE4MGE4ZjRkMzYkdmFyJGlzRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZXQgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcbiAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2YgYUtleXMpe1xuICAgICAgICBpZiAoYltrZXldICE9PSBhW2tleV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbmZ1bmN0aW9uICRhOTE2ZWI0NTI4ODRmYWVhJGV4cG9ydCRiN2E2MTYxNTBmZGI5ZjQ0KG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCB7IGxvY2FsZTogbG9jYWxlIH0gPSAoMCwgJDE4ZjIwNTFhZmY2OWI5YmYkZXhwb3J0JDQzYmIxNmY5YzZkOWUzZjcpKCk7XG4gICAgcmV0dXJuICgwLCAkaUZBRGckdXNlTWVtbykoKCk9Pm5ldyAoMCwgJGlGQURnJE51bWJlckZvcm1hdHRlcikobG9jYWxlLCBvcHRpb25zKSwgW1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG9wdGlvbnNcbiAgICBdKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5sZXQgJDMyNWEzZmFhYjdhNjhhY2QkdmFyJGNhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gJDMyNWEzZmFhYjdhNjhhY2QkZXhwb3J0JGExNmFjYTI4MzU1MGMzMGQob3B0aW9ucykge1xuICAgIGxldCB7IGxvY2FsZTogbG9jYWxlIH0gPSAoMCwgJDE4ZjIwNTFhZmY2OWI5YmYkZXhwb3J0JDQzYmIxNmY5YzZkOWUzZjcpKCk7XG4gICAgbGV0IGNhY2hlS2V5ID0gbG9jYWxlICsgKG9wdGlvbnMgPyBPYmplY3QuZW50cmllcyhvcHRpb25zKS5zb3J0KChhLCBiKT0+YVswXSA8IGJbMF0gPyAtMSA6IDEpLmpvaW4oKSA6IFwiXCIpO1xuICAgIGlmICgkMzI1YTNmYWFiN2E2OGFjZCR2YXIkY2FjaGUuaGFzKGNhY2hlS2V5KSkgcmV0dXJuICQzMjVhM2ZhYWI3YTY4YWNkJHZhciRjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGxldCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5Db2xsYXRvcihsb2NhbGUsIG9wdGlvbnMpO1xuICAgICQzMjVhM2ZhYWI3YTY4YWNkJHZhciRjYWNoZS5zZXQoY2FjaGVLZXksIGZvcm1hdHRlcik7XG4gICAgcmV0dXJuIGZvcm1hdHRlcjtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmZ1bmN0aW9uICRiYjc3ZjIzOWI0NmU4YzcyJGV4cG9ydCQzMjc0Y2Y4NGI3MDNmZmYob3B0aW9ucykge1xuICAgIGxldCBjb2xsYXRvciA9ICgwLCAkMzI1YTNmYWFiN2E2OGFjZCRleHBvcnQkYTE2YWNhMjgzNTUwYzMwZCkoe1xuICAgICAgICB1c2FnZTogXCJzZWFyY2hcIixcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICAgIC8vIFRPRE8obGF0ZXIpOiB0aGVzZSBtZXRob2RzIGRvbid0IGN1cnJlbnRseSBzdXBwb3J0IHRoZSBpZ25vcmVQdW5jdHVhdGlvbiBvcHRpb24uXG4gICAgbGV0IHN0YXJ0c1dpdGggPSAoMCwgJGlGQURnJHVzZUNhbGxiYWNrKSgoc3RyaW5nLCBzdWJzdHJpbmcpPT57XG4gICAgICAgIGlmIChzdWJzdHJpbmcubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gTm9ybWFsaXplIGJvdGggc3RyaW5ncyBzbyB3ZSBjYW4gc2xpY2Ugc2FmZWx5XG4gICAgICAgIC8vIFRPRE86IHRha2UgaW50byBhY2NvdW50IHRoZSBpZ25vcmVQdW5jdHVhdGlvbiBvcHRpb24gYXMgd2VsbC4uLlxuICAgICAgICBzdHJpbmcgPSBzdHJpbmcubm9ybWFsaXplKFwiTkZDXCIpO1xuICAgICAgICBzdWJzdHJpbmcgPSBzdWJzdHJpbmcubm9ybWFsaXplKFwiTkZDXCIpO1xuICAgICAgICByZXR1cm4gY29sbGF0b3IuY29tcGFyZShzdHJpbmcuc2xpY2UoMCwgc3Vic3RyaW5nLmxlbmd0aCksIHN1YnN0cmluZykgPT09IDA7XG4gICAgfSwgW1xuICAgICAgICBjb2xsYXRvclxuICAgIF0pO1xuICAgIGxldCBlbmRzV2l0aCA9ICgwLCAkaUZBRGckdXNlQ2FsbGJhY2spKChzdHJpbmcsIHN1YnN0cmluZyk9PntcbiAgICAgICAgaWYgKHN1YnN0cmluZy5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmcubm9ybWFsaXplKFwiTkZDXCIpO1xuICAgICAgICBzdWJzdHJpbmcgPSBzdWJzdHJpbmcubm9ybWFsaXplKFwiTkZDXCIpO1xuICAgICAgICByZXR1cm4gY29sbGF0b3IuY29tcGFyZShzdHJpbmcuc2xpY2UoLXN1YnN0cmluZy5sZW5ndGgpLCBzdWJzdHJpbmcpID09PSAwO1xuICAgIH0sIFtcbiAgICAgICAgY29sbGF0b3JcbiAgICBdKTtcbiAgICBsZXQgY29udGFpbnMgPSAoMCwgJGlGQURnJHVzZUNhbGxiYWNrKSgoc3RyaW5nLCBzdWJzdHJpbmcpPT57XG4gICAgICAgIGlmIChzdWJzdHJpbmcubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLm5vcm1hbGl6ZShcIk5GQ1wiKTtcbiAgICAgICAgc3Vic3RyaW5nID0gc3Vic3RyaW5nLm5vcm1hbGl6ZShcIk5GQ1wiKTtcbiAgICAgICAgbGV0IHNjYW4gPSAwO1xuICAgICAgICBsZXQgc2xpY2VMZW4gPSBzdWJzdHJpbmcubGVuZ3RoO1xuICAgICAgICBmb3IoOyBzY2FuICsgc2xpY2VMZW4gPD0gc3RyaW5nLmxlbmd0aDsgc2NhbisrKXtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IHN0cmluZy5zbGljZShzY2FuLCBzY2FuICsgc2xpY2VMZW4pO1xuICAgICAgICAgICAgaWYgKGNvbGxhdG9yLmNvbXBhcmUoc3Vic3RyaW5nLCBzbGljZSkgPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBbXG4gICAgICAgIGNvbGxhdG9yXG4gICAgXSk7XG4gICAgcmV0dXJuICgwLCAkaUZBRGckdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICBzdGFydHNXaXRoOiBzdGFydHNXaXRoLFxuICAgICAgICAgICAgZW5kc1dpdGg6IGVuZHNXaXRoLFxuICAgICAgICAgICAgY29udGFpbnM6IGNvbnRhaW5zXG4gICAgICAgIH0pLCBbXG4gICAgICAgIHN0YXJ0c1dpdGgsXG4gICAgICAgIGVuZHNXaXRoLFxuICAgICAgICBjb250YWluc1xuICAgIF0pO1xufVxuXG5cblxuXG5leHBvcnQgeyQxOGYyMDUxYWZmNjliOWJmJGV4cG9ydCRhNTQwMTNmMGQwMmE4ZjgyIGFzIEkxOG5Qcm92aWRlciwgJDE4ZjIwNTFhZmY2OWI5YmYkZXhwb3J0JDQzYmIxNmY5YzZkOWUzZjcgYXMgdXNlTG9jYWxlLCAkZmNhNmFmYTBlODQzMzI0YiRleHBvcnQkZjEyYjcwM2NhNzlkZmJiMSBhcyB1c2VMb2NhbGl6ZWRTdHJpbmdGb3JtYXR0ZXIsICQzM2JmMTczMDBjNDk4NTI4JGV4cG9ydCRhMmY0N2EzZDI5NzM2NDAgYXMgdXNlTGlzdEZvcm1hdHRlciwgJDg5NmJhMGE4MGE4ZjRkMzYkZXhwb3J0JDg1ZmQ1ZmRmMjdiYWNjNzkgYXMgdXNlRGF0ZUZvcm1hdHRlciwgJGE5MTZlYjQ1Mjg4NGZhZWEkZXhwb3J0JGI3YTYxNjE1MGZkYjlmNDQgYXMgdXNlTnVtYmVyRm9ybWF0dGVyLCAkMzI1YTNmYWFiN2E2OGFjZCRleHBvcnQkYTE2YWNhMjgzNTUwYzMwZCBhcyB1c2VDb2xsYXRvciwgJGJiNzdmMjM5YjQ2ZThjNzIkZXhwb3J0JDMyNzRjZjg0YjcwM2ZmZiBhcyB1c2VGaWx0ZXJ9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhbC1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@react-aria/i18n/dist/real-module.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@react-aria/interactions/dist/import.mjs":
/*!*******************************************************************!*\
  !*** ../../node_modules/@react-aria/interactions/dist/import.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClearPressResponder: () => (/* binding */ $f1ab8c75478c6f73$export$cf75428e0b9ed1ea),\n/* harmony export */   PressResponder: () => (/* binding */ $f1ab8c75478c6f73$export$3351871ee4b288b8),\n/* harmony export */   Pressable: () => (/* binding */ $3b117e43dc0ca95d$export$27c701ed9e449e99),\n/* harmony export */   getInteractionModality: () => (/* binding */ $507fabe10e71c6fb$export$630ff653c5ada6a9),\n/* harmony export */   isFocusVisible: () => (/* binding */ $507fabe10e71c6fb$export$b9b3dfddab17db27),\n/* harmony export */   setInteractionModality: () => (/* binding */ $507fabe10e71c6fb$export$8397ddfc504fdb9a),\n/* harmony export */   useFocus: () => (/* binding */ $a1ea59d68270f0dd$export$f8168d8dd8fd66e6),\n/* harmony export */   useFocusVisible: () => (/* binding */ $507fabe10e71c6fb$export$ffd9e5021c1fb2d6),\n/* harmony export */   useFocusVisibleListener: () => (/* binding */ $507fabe10e71c6fb$export$ec71b4b83ac08ec3),\n/* harmony export */   useFocusWithin: () => (/* binding */ $9ab94262bd0047c7$export$420e68273165f4ec),\n/* harmony export */   useHover: () => (/* binding */ $6179b936705e76d3$export$ae780daf29e6d456),\n/* harmony export */   useInteractOutside: () => (/* binding */ $e0b6e0b68ec7f50f$export$872b660ac5a1ff98),\n/* harmony export */   useInteractionModality: () => (/* binding */ $507fabe10e71c6fb$export$98e20ec92f614cfe),\n/* harmony export */   useKeyboard: () => (/* binding */ $46d819fcbaf35654$export$8f71654801c2f7cd),\n/* harmony export */   useLongPress: () => (/* binding */ $8a26561d2877236e$export$c24ed0104d07eab9),\n/* harmony export */   useMove: () => (/* binding */ $e8a7022cf87cba2a$export$36da96379f79f245),\n/* harmony export */   usePress: () => (/* binding */ $f6c31cce2adf654f$export$45712eceda6fad21),\n/* harmony export */   useScrollWheel: () => (/* binding */ $7d0a636d7a4dcefd$export$2123ff2b87c81ca)\n/* harmony export */ });\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/../../node_modules/@react-aria/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(ssr)/../../node_modules/@swc/helpers/cjs/_class_private_field_get.cjs\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(ssr)/../../node_modules/@swc/helpers/cjs/_class_private_field_init.cjs\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(ssr)/../../node_modules/@swc/helpers/cjs/_class_private_field_set.cjs\");\n/* harmony import */ var _react_aria_ssr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-aria/ssr */ \"(ssr)/../../node_modules/@react-aria/ssr/dist/import.mjs\");\n\n\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element\n// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually\nlet $14c0b72509d70225$var$state = \"default\";\nlet $14c0b72509d70225$var$savedUserSelect = \"\";\nlet $14c0b72509d70225$var$modifiedElementMap = new WeakMap();\nfunction $14c0b72509d70225$export$16a4697467175487(target) {\n    if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isIOS)()) {\n        if ($14c0b72509d70225$var$state === \"default\") {\n            // eslint-disable-next-line no-restricted-globals\n            const documentObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(target);\n            $14c0b72509d70225$var$savedUserSelect = documentObject.documentElement.style.webkitUserSelect;\n            documentObject.documentElement.style.webkitUserSelect = \"none\";\n        }\n        $14c0b72509d70225$var$state = \"disabled\";\n    } else if (target instanceof HTMLElement || target instanceof SVGElement) {\n        // If not iOS, store the target's original user-select and change to user-select: none\n        // Ignore state since it doesn't apply for non iOS\n        $14c0b72509d70225$var$modifiedElementMap.set(target, target.style.userSelect);\n        target.style.userSelect = \"none\";\n    }\n}\nfunction $14c0b72509d70225$export$b0d6fa1ab32e3295(target) {\n    if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isIOS)()) {\n        // If the state is already default, there's nothing to do.\n        // If it is restoring, then there's no need to queue a second restore.\n        if ($14c0b72509d70225$var$state !== \"disabled\") return;\n        $14c0b72509d70225$var$state = \"restoring\";\n        // There appears to be a delay on iOS where selection still might occur\n        // after pointer up, so wait a bit before removing user-select.\n        setTimeout(()=>{\n            // Wait for any CSS transitions to complete so we don't recompute style\n            // for the whole page in the middle of the animation and cause jank.\n            (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.runAfterTransition)(()=>{\n                // Avoid race conditions\n                if ($14c0b72509d70225$var$state === \"restoring\") {\n                    // eslint-disable-next-line no-restricted-globals\n                    const documentObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(target);\n                    if (documentObject.documentElement.style.webkitUserSelect === \"none\") documentObject.documentElement.style.webkitUserSelect = $14c0b72509d70225$var$savedUserSelect || \"\";\n                    $14c0b72509d70225$var$savedUserSelect = \"\";\n                    $14c0b72509d70225$var$state = \"default\";\n                }\n            });\n        }, 300);\n    } else if (target instanceof HTMLElement || target instanceof SVGElement) // If not iOS, restore the target's original user-select if any\n    // Ignore state since it doesn't apply for non iOS\n    {\n        if (target && $14c0b72509d70225$var$modifiedElementMap.has(target)) {\n            let targetOldUserSelect = $14c0b72509d70225$var$modifiedElementMap.get(target);\n            if (target.style.userSelect === \"none\" && targetOldUserSelect) target.style.userSelect = targetOldUserSelect;\n            if (target.getAttribute(\"style\") === \"\") target.removeAttribute(\"style\");\n            $14c0b72509d70225$var$modifiedElementMap.delete(target);\n        }\n    }\n}\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nconst $ae1eeba8b9eafd08$export$5165eccb35aaadb5 = (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext({\n    register: ()=>{}\n});\n$ae1eeba8b9eafd08$export$5165eccb35aaadb5.displayName = \"PressResponderContext\";\n\n\n\nfunction $f6c31cce2adf654f$var$usePressResponderContext(props) {\n    // Consume context from <PressResponder> and merge with props.\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));\n    if (context) {\n        let { register: register, ...contextProps } = context;\n        props = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(contextProps, props);\n        register();\n    }\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useSyncRef)(context, props.ref);\n    return props;\n}\nvar $f6c31cce2adf654f$var$_shouldStopPropagation = /*#__PURE__*/ new WeakMap();\nclass $f6c31cce2adf654f$var$PressEvent {\n    continuePropagation() {\n        (0, _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, false);\n    }\n    get shouldStopPropagation() {\n        return (0, _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, $f6c31cce2adf654f$var$_shouldStopPropagation);\n    }\n    constructor(type, pointerType, originalEvent){\n        (0, _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, {\n            writable: true,\n            value: void 0\n        });\n        (0, _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, true);\n        this.type = type;\n        this.pointerType = pointerType;\n        this.target = originalEvent.currentTarget;\n        this.shiftKey = originalEvent.shiftKey;\n        this.metaKey = originalEvent.metaKey;\n        this.ctrlKey = originalEvent.ctrlKey;\n        this.altKey = originalEvent.altKey;\n    }\n}\nconst $f6c31cce2adf654f$var$LINK_CLICKED = Symbol(\"linkClicked\");\nfunction $f6c31cce2adf654f$export$45712eceda6fad21(props) {\n    let { onPress: onPress, onPressChange: onPressChange, onPressStart: onPressStart, onPressEnd: onPressEnd, onPressUp: onPressUp, isDisabled: isDisabled, isPressed: isPressedProp, preventFocusOnPress: preventFocusOnPress, shouldCancelOnPointerExit: shouldCancelOnPointerExit, allowTextSelectionOnPress: allowTextSelectionOnPress, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ref: _, ...domProps } = $f6c31cce2adf654f$var$usePressResponderContext(props);\n    let [isPressed, setPressed] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isPressed: false,\n        ignoreEmulatedMouseEvents: false,\n        ignoreClickAfterPress: false,\n        didFirePressStart: false,\n        isTriggeringEvent: false,\n        activePointerId: null,\n        target: null,\n        isOverTarget: false,\n        pointerType: null\n    });\n    let { addGlobalListener: addGlobalListener, removeAllGlobalListeners: removeAllGlobalListeners } = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useGlobalListeners)();\n    let triggerPressStart = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType)=>{\n        let state = ref.current;\n        if (isDisabled || state.didFirePressStart) return false;\n        let shouldStopPropagation = true;\n        state.isTriggeringEvent = true;\n        if (onPressStart) {\n            let event = new $f6c31cce2adf654f$var$PressEvent(\"pressstart\", pointerType, originalEvent);\n            onPressStart(event);\n            shouldStopPropagation = event.shouldStopPropagation;\n        }\n        if (onPressChange) onPressChange(true);\n        state.isTriggeringEvent = false;\n        state.didFirePressStart = true;\n        setPressed(true);\n        return shouldStopPropagation;\n    });\n    let triggerPressEnd = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType, wasPressed = true)=>{\n        let state = ref.current;\n        if (!state.didFirePressStart) return false;\n        state.ignoreClickAfterPress = true;\n        state.didFirePressStart = false;\n        state.isTriggeringEvent = true;\n        let shouldStopPropagation = true;\n        if (onPressEnd) {\n            let event = new $f6c31cce2adf654f$var$PressEvent(\"pressend\", pointerType, originalEvent);\n            onPressEnd(event);\n            shouldStopPropagation = event.shouldStopPropagation;\n        }\n        if (onPressChange) onPressChange(false);\n        setPressed(false);\n        if (onPress && wasPressed && !isDisabled) {\n            let event = new $f6c31cce2adf654f$var$PressEvent(\"press\", pointerType, originalEvent);\n            onPress(event);\n            shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);\n        }\n        state.isTriggeringEvent = false;\n        return shouldStopPropagation;\n    });\n    let triggerPressUp = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType)=>{\n        let state = ref.current;\n        if (isDisabled) return false;\n        if (onPressUp) {\n            state.isTriggeringEvent = true;\n            let event = new $f6c31cce2adf654f$var$PressEvent(\"pressup\", pointerType, originalEvent);\n            onPressUp(event);\n            state.isTriggeringEvent = false;\n            return event.shouldStopPropagation;\n        }\n        return true;\n    });\n    let cancel = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        let state = ref.current;\n        if (state.isPressed && state.target) {\n            if (state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n            state.isPressed = false;\n            state.isOverTarget = false;\n            state.activePointerId = null;\n            state.pointerType = null;\n            removeAllGlobalListeners();\n            if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n        }\n    });\n    let cancelOnPointerExit = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        if (shouldCancelOnPointerExit) cancel(e);\n    });\n    let pressProps = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let state = ref.current;\n        let pressProps = {\n            onKeyDown (e) {\n                if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {\n                    var _state_metaKeyEvents;\n                    if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();\n                    // If the event is repeating, it may have started on a different element\n                    // after which focus moved to the current element. Ignore these events and\n                    // only handle the first key down event.\n                    let shouldStopPropagation = true;\n                    if (!state.isPressed && !e.repeat) {\n                        state.target = e.currentTarget;\n                        state.isPressed = true;\n                        shouldStopPropagation = triggerPressStart(e, \"keyboard\");\n                        // Focus may move before the key up event, so register the event on the document\n                        // instead of the same element where the key down event occurred.\n                        addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"keyup\", onKeyUp, false);\n                    }\n                    if (shouldStopPropagation) e.stopPropagation();\n                    // Keep track of the keydown events that occur while the Meta (e.g. Command) key is held.\n                    // macOS has a bug where keyup events are not fired while the Meta key is down.\n                    // When the Meta key itself is released we will get an event for that, and we'll act as if\n                    // all of these other keys were released as well.\n                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1393524\n                    // https://bugs.webkit.org/show_bug.cgi?id=55291\n                    // https://bugzilla.mozilla.org/show_bug.cgi?id=1299553\n                    if (e.metaKey && (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isMac)()) (_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.set(e.key, e.nativeEvent);\n                } else if (e.key === \"Meta\") state.metaKeyEvents = new Map();\n            },\n            onKeyUp (e) {\n                if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target) && state.target) triggerPressUp($f6c31cce2adf654f$var$createEvent(state.target, e), \"keyboard\");\n            },\n            onClick (e) {\n                if (e && !e.currentTarget.contains(e.target)) return;\n                if (e && e.button === 0 && !state.isTriggeringEvent && !(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.openLink).isOpening) {\n                    let shouldStopPropagation = true;\n                    if (isDisabled) e.preventDefault();\n                    // If triggered from a screen reader or by using element.click(),\n                    // trigger as if it were a keyboard click.\n                    if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === \"virtual\" || (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isVirtualClick)(e.nativeEvent))) {\n                        // Ensure the element receives focus (VoiceOver on iOS does not do this)\n                        if (!isDisabled && !preventFocusOnPress) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.focusWithoutScrolling)(e.currentTarget);\n                        let stopPressStart = triggerPressStart(e, \"virtual\");\n                        let stopPressUp = triggerPressUp(e, \"virtual\");\n                        let stopPressEnd = triggerPressEnd(e, \"virtual\");\n                        shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n                    }\n                    state.ignoreEmulatedMouseEvents = false;\n                    state.ignoreClickAfterPress = false;\n                    if (shouldStopPropagation) e.stopPropagation();\n                }\n            }\n        };\n        let onKeyUp = (e)=>{\n            var _state_metaKeyEvents;\n            if (state.isPressed && state.target && $f6c31cce2adf654f$var$isValidKeyboardEvent(e, state.target)) {\n                var _state_metaKeyEvents1;\n                if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();\n                let target = e.target;\n                let shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), \"keyboard\", state.target.contains(target));\n                removeAllGlobalListeners();\n                if (shouldStopPropagation) e.stopPropagation();\n                // If a link was triggered with a key other than Enter, open the URL ourselves.\n                // This means the link has a role override, and the default browser behavior\n                // only applies when using the Enter key.\n                if (e.key !== \"Enter\" && $f6c31cce2adf654f$var$isHTMLAnchorLink(state.target) && state.target.contains(target) && !e[$f6c31cce2adf654f$var$LINK_CLICKED]) {\n                    // Store a hidden property on the event so we only trigger link click once,\n                    // even if there are multiple usePress instances attached to the element.\n                    e[$f6c31cce2adf654f$var$LINK_CLICKED] = true;\n                    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.openLink)(state.target, e, false);\n                }\n                state.isPressed = false;\n                (_state_metaKeyEvents1 = state.metaKeyEvents) === null || _state_metaKeyEvents1 === void 0 ? void 0 : _state_metaKeyEvents1.delete(e.key);\n            } else if (e.key === \"Meta\" && ((_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.size)) {\n                var _state_target;\n                // If we recorded keydown events that occurred while the Meta key was pressed,\n                // and those haven't received keyup events already, fire keyup events ourselves.\n                // See comment above for more info about the macOS bug causing this.\n                let events = state.metaKeyEvents;\n                state.metaKeyEvents = undefined;\n                for (let event of events.values())(_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.dispatchEvent(new KeyboardEvent(\"keyup\", event));\n            }\n        };\n        if (typeof PointerEvent !== \"undefined\") {\n            pressProps.onPointerDown = (e)=>{\n                // Only handle left clicks, and ignore events that bubbled through portals.\n                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;\n                // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.\n                // Ignore and let the onClick handler take care of it instead.\n                // https://bugs.webkit.org/show_bug.cgi?id=222627\n                // https://bugs.webkit.org/show_bug.cgi?id=223202\n                if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isVirtualPointerEvent)(e.nativeEvent)) {\n                    state.pointerType = \"virtual\";\n                    return;\n                }\n                // Due to browser inconsistencies, especially on mobile browsers, we prevent\n                // default on pointer down and handle focusing the pressable element ourselves.\n                if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n                state.pointerType = e.pointerType;\n                let shouldStopPropagation = true;\n                if (!state.isPressed) {\n                    state.isPressed = true;\n                    state.isOverTarget = true;\n                    state.activePointerId = e.pointerId;\n                    state.target = e.currentTarget;\n                    if (!isDisabled && !preventFocusOnPress) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.focusWithoutScrolling)(e.currentTarget);\n                    if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);\n                    shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                    addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"pointermove\", onPointerMove, false);\n                    addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"pointerup\", onPointerUp, false);\n                    addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"pointercancel\", onPointerCancel, false);\n                }\n                if (shouldStopPropagation) e.stopPropagation();\n            };\n            pressProps.onMouseDown = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (e.button === 0) {\n                    // Chrome and Firefox on touch Windows devices require mouse down events\n                    // to be canceled in addition to pointer events, or an extra asynchronous\n                    // focus event will be fired.\n                    if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n                    e.stopPropagation();\n                }\n            };\n            pressProps.onPointerUp = (e)=>{\n                // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.\n                if (!e.currentTarget.contains(e.target) || state.pointerType === \"virtual\") return;\n                // Only handle left clicks\n                // Safari on iOS sometimes fires pointerup events, even\n                // when the touch isn't over the target, so double check.\n                if (e.button === 0 && $f6c31cce2adf654f$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);\n            };\n            // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.\n            // Use pointer move events instead to implement our own hit testing.\n            // See https://bugs.webkit.org/show_bug.cgi?id=199803\n            let onPointerMove = (e)=>{\n                if (e.pointerId !== state.activePointerId) return;\n                if (state.target && $f6c31cce2adf654f$var$isOverTarget(e, state.target)) {\n                    if (!state.isOverTarget && state.pointerType != null) {\n                        state.isOverTarget = true;\n                        triggerPressStart($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n                    }\n                } else if (state.target && state.isOverTarget && state.pointerType != null) {\n                    state.isOverTarget = false;\n                    triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n                    cancelOnPointerExit(e);\n                }\n            };\n            let onPointerUp = (e)=>{\n                if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n                    if ($f6c31cce2adf654f$var$isOverTarget(e, state.target) && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n                    else if (state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n                    state.isPressed = false;\n                    state.isOverTarget = false;\n                    state.activePointerId = null;\n                    state.pointerType = null;\n                    removeAllGlobalListeners();\n                    if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n                }\n            };\n            let onPointerCancel = (e)=>{\n                cancel(e);\n            };\n            pressProps.onDragStart = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.\n                cancel(e);\n            };\n        } else {\n            pressProps.onMouseDown = (e)=>{\n                // Only handle left clicks\n                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;\n                // Due to browser inconsistencies, especially on mobile browsers, we prevent\n                // default on mouse down and handle focusing the pressable element ourselves.\n                if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n                if (state.ignoreEmulatedMouseEvents) {\n                    e.stopPropagation();\n                    return;\n                }\n                state.isPressed = true;\n                state.isOverTarget = true;\n                state.target = e.currentTarget;\n                state.pointerType = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isVirtualClick)(e.nativeEvent) ? \"virtual\" : \"mouse\";\n                if (!isDisabled && !preventFocusOnPress) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.focusWithoutScrolling)(e.currentTarget);\n                let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                if (shouldStopPropagation) e.stopPropagation();\n                addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"mouseup\", onMouseUp, false);\n            };\n            pressProps.onMouseEnter = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                let shouldStopPropagation = true;\n                if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n                    state.isOverTarget = true;\n                    shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                }\n                if (shouldStopPropagation) e.stopPropagation();\n            };\n            pressProps.onMouseLeave = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                let shouldStopPropagation = true;\n                if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n                    state.isOverTarget = false;\n                    shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n                    cancelOnPointerExit(e);\n                }\n                if (shouldStopPropagation) e.stopPropagation();\n            };\n            pressProps.onMouseUp = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType || \"mouse\");\n            };\n            let onMouseUp = (e)=>{\n                // Only handle left clicks\n                if (e.button !== 0) return;\n                state.isPressed = false;\n                removeAllGlobalListeners();\n                if (state.ignoreEmulatedMouseEvents) {\n                    state.ignoreEmulatedMouseEvents = false;\n                    return;\n                }\n                if (state.target && $f6c31cce2adf654f$var$isOverTarget(e, state.target) && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n                else if (state.target && state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n                state.isOverTarget = false;\n            };\n            pressProps.onTouchStart = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                let touch = $f6c31cce2adf654f$var$getTouchFromEvent(e.nativeEvent);\n                if (!touch) return;\n                state.activePointerId = touch.identifier;\n                state.ignoreEmulatedMouseEvents = true;\n                state.isOverTarget = true;\n                state.isPressed = true;\n                state.target = e.currentTarget;\n                state.pointerType = \"touch\";\n                // Due to browser inconsistencies, especially on mobile browsers, we prevent default\n                // on the emulated mouse event and handle focusing the pressable element ourselves.\n                if (!isDisabled && !preventFocusOnPress) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.focusWithoutScrolling)(e.currentTarget);\n                if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);\n                let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                if (shouldStopPropagation) e.stopPropagation();\n                addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerWindow)(e.currentTarget), \"scroll\", onScroll, true);\n            };\n            pressProps.onTouchMove = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (!state.isPressed) {\n                    e.stopPropagation();\n                    return;\n                }\n                let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);\n                let shouldStopPropagation = true;\n                if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget)) {\n                    if (!state.isOverTarget && state.pointerType != null) {\n                        state.isOverTarget = true;\n                        shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                    }\n                } else if (state.isOverTarget && state.pointerType != null) {\n                    state.isOverTarget = false;\n                    shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n                    cancelOnPointerExit(e);\n                }\n                if (shouldStopPropagation) e.stopPropagation();\n            };\n            pressProps.onTouchEnd = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (!state.isPressed) {\n                    e.stopPropagation();\n                    return;\n                }\n                let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);\n                let shouldStopPropagation = true;\n                if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget) && state.pointerType != null) {\n                    triggerPressUp(e, state.pointerType);\n                    shouldStopPropagation = triggerPressEnd(e, state.pointerType);\n                } else if (state.isOverTarget && state.pointerType != null) shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n                if (shouldStopPropagation) e.stopPropagation();\n                state.isPressed = false;\n                state.activePointerId = null;\n                state.isOverTarget = false;\n                state.ignoreEmulatedMouseEvents = true;\n                if (state.target && !allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n                removeAllGlobalListeners();\n            };\n            pressProps.onTouchCancel = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                e.stopPropagation();\n                if (state.isPressed) cancel(e);\n            };\n            let onScroll = (e)=>{\n                if (state.isPressed && e.target.contains(state.target)) cancel({\n                    currentTarget: state.target,\n                    shiftKey: false,\n                    ctrlKey: false,\n                    metaKey: false,\n                    altKey: false\n                });\n            };\n            pressProps.onDragStart = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                cancel(e);\n            };\n        }\n        return pressProps;\n    }, [\n        addGlobalListener,\n        isDisabled,\n        preventFocusOnPress,\n        removeAllGlobalListeners,\n        allowTextSelectionOnPress,\n        cancel,\n        cancelOnPointerExit,\n        triggerPressEnd,\n        triggerPressStart,\n        triggerPressUp\n    ]);\n    // Remove user-select: none in case component unmounts immediately after pressStart\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            var _ref_current_target;\n            if (!allowTextSelectionOnPress) // eslint-disable-next-line react-hooks/exhaustive-deps\n            (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)((_ref_current_target = ref.current.target) !== null && _ref_current_target !== void 0 ? _ref_current_target : undefined);\n        };\n    }, [\n        allowTextSelectionOnPress\n    ]);\n    return {\n        isPressed: isPressedProp || isPressed,\n        pressProps: (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(domProps, pressProps)\n    };\n}\nfunction $f6c31cce2adf654f$var$isHTMLAnchorLink(target) {\n    return target.tagName === \"A\" && target.hasAttribute(\"href\");\n}\nfunction $f6c31cce2adf654f$var$isValidKeyboardEvent(event, currentTarget) {\n    const { key: key, code: code } = event;\n    const element = currentTarget;\n    const role = element.getAttribute(\"role\");\n    // Accessibility for keyboards. Space and Enter only.\n    // \"Spacebar\" is for IE 11\n    return (key === \"Enter\" || key === \" \" || key === \"Spacebar\" || code === \"Space\") && !(element instanceof (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerWindow)(element).HTMLInputElement && !$f6c31cce2adf654f$var$isValidInputKey(element, key) || element instanceof (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerWindow)(element).HTMLTextAreaElement || element.isContentEditable) && // Links should only trigger with Enter key\n    !((role === \"link\" || !role && $f6c31cce2adf654f$var$isHTMLAnchorLink(element)) && key !== \"Enter\");\n}\nfunction $f6c31cce2adf654f$var$getTouchFromEvent(event) {\n    const { targetTouches: targetTouches } = event;\n    if (targetTouches.length > 0) return targetTouches[0];\n    return null;\n}\nfunction $f6c31cce2adf654f$var$getTouchById(event, pointerId) {\n    const changedTouches = event.changedTouches;\n    for(let i = 0; i < changedTouches.length; i++){\n        const touch = changedTouches[i];\n        if (touch.identifier === pointerId) return touch;\n    }\n    return null;\n}\nfunction $f6c31cce2adf654f$var$createEvent(target, e) {\n    return {\n        currentTarget: target,\n        shiftKey: e.shiftKey,\n        ctrlKey: e.ctrlKey,\n        metaKey: e.metaKey,\n        altKey: e.altKey\n    };\n}\nfunction $f6c31cce2adf654f$var$getPointClientRect(point) {\n    let offsetX = 0;\n    let offsetY = 0;\n    if (point.width !== undefined) offsetX = point.width / 2;\n    else if (point.radiusX !== undefined) offsetX = point.radiusX;\n    if (point.height !== undefined) offsetY = point.height / 2;\n    else if (point.radiusY !== undefined) offsetY = point.radiusY;\n    return {\n        top: point.clientY - offsetY,\n        right: point.clientX + offsetX,\n        bottom: point.clientY + offsetY,\n        left: point.clientX - offsetX\n    };\n}\nfunction $f6c31cce2adf654f$var$areRectanglesOverlapping(a, b) {\n    // check if they cannot overlap on x axis\n    if (a.left > b.right || b.left > a.right) return false;\n    // check if they cannot overlap on y axis\n    if (a.top > b.bottom || b.top > a.bottom) return false;\n    return true;\n}\nfunction $f6c31cce2adf654f$var$isOverTarget(point, target) {\n    let rect = target.getBoundingClientRect();\n    let pointRect = $f6c31cce2adf654f$var$getPointClientRect(point);\n    return $f6c31cce2adf654f$var$areRectanglesOverlapping(rect, pointRect);\n}\nfunction $f6c31cce2adf654f$var$shouldPreventDefault(target) {\n    // We cannot prevent default if the target is a draggable element.\n    return !(target instanceof HTMLElement) || !target.hasAttribute(\"draggable\");\n}\nfunction $f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(target, key) {\n    if (target instanceof HTMLInputElement) return !$f6c31cce2adf654f$var$isValidInputKey(target, key);\n    if (target instanceof HTMLButtonElement) return target.type !== \"submit\" && target.type !== \"reset\";\n    if ($f6c31cce2adf654f$var$isHTMLAnchorLink(target)) return false;\n    return true;\n}\nconst $f6c31cce2adf654f$var$nonTextInputTypes = new Set([\n    \"checkbox\",\n    \"radio\",\n    \"range\",\n    \"color\",\n    \"file\",\n    \"image\",\n    \"button\",\n    \"submit\",\n    \"reset\"\n]);\nfunction $f6c31cce2adf654f$var$isValidInputKey(target, key) {\n    // Only space should toggle checkboxes and radios, not enter.\n    return target.type === \"checkbox\" || target.type === \"radio\" ? key === \" \" : $f6c31cce2adf654f$var$nonTextInputTypes.has(target.type);\n}\n\n\n\nconst $3b117e43dc0ca95d$export$27c701ed9e449e99 = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).forwardRef(({ children: children, ...props }, ref)=>{\n    ref = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useObjectRef)(ref);\n    let { pressProps: pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({\n        ...props,\n        ref: ref\n    });\n    let child = (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.only(children);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).cloneElement(child, // @ts-ignore\n    {\n        ref: ref,\n        ...(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(child.props, pressProps)\n    });\n});\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nconst $f1ab8c75478c6f73$export$3351871ee4b288b8 = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).forwardRef(({ children: children, ...props }, ref)=>{\n    let isRegistered = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let prevContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));\n    ref = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useObjectRef)(ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref));\n    let context = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(prevContext || {}, {\n        ...props,\n        ref: ref,\n        register () {\n            isRegistered.current = true;\n            if (prevContext) prevContext.register();\n        }\n    });\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useSyncRef)(prevContext, ref);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isRegistered.current) {\n            console.warn(\"A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.\");\n            isRegistered.current = true; // only warn once in strict mode.\n        }\n    }, []);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {\n        value: context\n    }, children);\n});\nfunction $f1ab8c75478c6f73$export$cf75428e0b9ed1ea({ children: children }) {\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            register: ()=>{}\n        }), []);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {\n        value: context\n    }, children);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nclass $8a9cb279dc87e130$export$905e7fc544a71f36 {\n    isDefaultPrevented() {\n        return this.nativeEvent.defaultPrevented;\n    }\n    preventDefault() {\n        this.defaultPrevented = true;\n        this.nativeEvent.preventDefault();\n    }\n    stopPropagation() {\n        this.nativeEvent.stopPropagation();\n        this.isPropagationStopped = ()=>true;\n    }\n    isPropagationStopped() {\n        return false;\n    }\n    persist() {}\n    constructor(type, nativeEvent){\n        this.nativeEvent = nativeEvent;\n        this.target = nativeEvent.target;\n        this.currentTarget = nativeEvent.currentTarget;\n        this.relatedTarget = nativeEvent.relatedTarget;\n        this.bubbles = nativeEvent.bubbles;\n        this.cancelable = nativeEvent.cancelable;\n        this.defaultPrevented = nativeEvent.defaultPrevented;\n        this.eventPhase = nativeEvent.eventPhase;\n        this.isTrusted = nativeEvent.isTrusted;\n        this.timeStamp = nativeEvent.timeStamp;\n        this.type = type;\n    }\n}\nfunction $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {\n    let stateRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isFocused: false,\n        observer: null\n    });\n    // Clean up MutationObserver on unmount. See below.\n    // eslint-disable-next-line arrow-body-style\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{\n        const state = stateRef.current;\n        return ()=>{\n            if (state.observer) {\n                state.observer.disconnect();\n                state.observer = null;\n            }\n        };\n    }, []);\n    let dispatchBlur = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);\n    });\n    // This function is called during a React onFocus event.\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142\n        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a\n        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.\n        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.\n        if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {\n            stateRef.current.isFocused = true;\n            let target = e.target;\n            let onBlurHandler = (e)=>{\n                stateRef.current.isFocused = false;\n                if (target.disabled) // For backward compatibility, dispatch a (fake) React synthetic event.\n                dispatchBlur(new $8a9cb279dc87e130$export$905e7fc544a71f36(\"blur\", e));\n                // We no longer need the MutationObserver once the target is blurred.\n                if (stateRef.current.observer) {\n                    stateRef.current.observer.disconnect();\n                    stateRef.current.observer = null;\n                }\n            };\n            target.addEventListener(\"focusout\", onBlurHandler, {\n                once: true\n            });\n            stateRef.current.observer = new MutationObserver(()=>{\n                if (stateRef.current.isFocused && target.disabled) {\n                    var _stateRef_current_observer;\n                    (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();\n                    let relatedTargetEl = target === document.activeElement ? null : document.activeElement;\n                    target.dispatchEvent(new FocusEvent(\"blur\", {\n                        relatedTarget: relatedTargetEl\n                    }));\n                    target.dispatchEvent(new FocusEvent(\"focusout\", {\n                        bubbles: true,\n                        relatedTarget: relatedTargetEl\n                    }));\n                }\n            });\n            stateRef.current.observer.observe(target, {\n                attributes: true,\n                attributeFilter: [\n                    \"disabled\"\n                ]\n            });\n        }\n    }, [\n        dispatchBlur\n    ]);\n}\n\n\nfunction $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {\n    let { isDisabled: isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange: onFocusChange } = props;\n    const onBlur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (e.target === e.currentTarget) {\n            if (onBlurProp) onBlurProp(e);\n            if (onFocusChange) onFocusChange(false);\n            return true;\n        }\n    }, [\n        onBlurProp,\n        onFocusChange\n    ]);\n    const onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);\n    const onFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // Double check that document.activeElement actually matches e.target in case a previously chained\n        // focus handler already moved focus somewhere else.\n        if (e.target === e.currentTarget && document.activeElement === e.target) {\n            if (onFocusProp) onFocusProp(e);\n            if (onFocusChange) onFocusChange(true);\n            onSyntheticFocus(e);\n        }\n    }, [\n        onFocusChange,\n        onFocusProp,\n        onSyntheticFocus\n    ]);\n    return {\n        focusProps: {\n            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,\n            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined\n        }\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\n\n\nlet $507fabe10e71c6fb$var$currentModality = null;\nlet $507fabe10e71c6fb$var$changeHandlers = new Set();\nlet $507fabe10e71c6fb$var$hasSetupGlobalListeners = false;\nlet $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\nlet $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n// Only Tab or Esc keys will make focus visible on text input elements\nconst $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {\n    Tab: true,\n    Escape: true\n};\nfunction $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e) {\n    for (let handler of $507fabe10e71c6fb$var$changeHandlers)handler(modality, e);\n}\n/**\n * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.\n */ function $507fabe10e71c6fb$var$isValidKey(e) {\n    // Control and Shift keys trigger when navigating back to the tab with keyboard.\n    return !(e.metaKey || !(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isMac)() && e.altKey || e.ctrlKey || e.key === \"Control\" || e.key === \"Shift\" || e.key === \"Meta\");\n}\nfunction $507fabe10e71c6fb$var$handleKeyboardEvent(e) {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    if ($507fabe10e71c6fb$var$isValidKey(e)) {\n        $507fabe10e71c6fb$var$currentModality = \"keyboard\";\n        $507fabe10e71c6fb$var$triggerChangeHandlers(\"keyboard\", e);\n    }\n}\nfunction $507fabe10e71c6fb$var$handlePointerEvent(e) {\n    $507fabe10e71c6fb$var$currentModality = \"pointer\";\n    if (e.type === \"mousedown\" || e.type === \"pointerdown\") {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        $507fabe10e71c6fb$var$triggerChangeHandlers(\"pointer\", e);\n    }\n}\nfunction $507fabe10e71c6fb$var$handleClickEvent(e) {\n    if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isVirtualClick)(e)) {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        $507fabe10e71c6fb$var$currentModality = \"virtual\";\n    }\n}\nfunction $507fabe10e71c6fb$var$handleFocusEvent(e) {\n    // Firefox fires two extra focus events when the user first clicks into an iframe:\n    // first on the window, then on the document. We ignore these events so they don't\n    // cause keyboard focus rings to appear.\n    if (e.target === window || e.target === document) return;\n    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.\n    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.\n    if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {\n        $507fabe10e71c6fb$var$currentModality = \"virtual\";\n        $507fabe10e71c6fb$var$triggerChangeHandlers(\"virtual\", e);\n    }\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n    $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n}\nfunction $507fabe10e71c6fb$var$handleWindowBlur() {\n    // When the window is blurred, reset state. This is necessary when tabbing out of the window,\n    // for example, since a subsequent focus event won't be fired.\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n    $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;\n}\n/**\n * Setup global event listeners to control when keyboard focus style should be visible.\n */ function $507fabe10e71c6fb$var$setupGlobalFocusEvents() {\n    if (typeof window === \"undefined\" || $507fabe10e71c6fb$var$hasSetupGlobalListeners) return;\n    // Programmatic focus() calls shouldn't affect the current input modality.\n    // However, we need to detect other cases when a focus event occurs without\n    // a preceding user event (e.g. screen reader focus). Overriding the focus\n    // method on HTMLElement.prototype is a bit hacky, but works.\n    let focus = HTMLElement.prototype.focus;\n    HTMLElement.prototype.focus = function() {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        focus.apply(this, arguments);\n    };\n    document.addEventListener(\"keydown\", $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n    document.addEventListener(\"keyup\", $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n    document.addEventListener(\"click\", $507fabe10e71c6fb$var$handleClickEvent, true);\n    // Register focus events on the window so they are sure to happen\n    // before React's event listeners (registered on the document).\n    window.addEventListener(\"focus\", $507fabe10e71c6fb$var$handleFocusEvent, true);\n    window.addEventListener(\"blur\", $507fabe10e71c6fb$var$handleWindowBlur, false);\n    if (typeof PointerEvent !== \"undefined\") {\n        document.addEventListener(\"pointerdown\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener(\"pointermove\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener(\"pointerup\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    } else {\n        document.addEventListener(\"mousedown\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener(\"mousemove\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener(\"mouseup\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    }\n    $507fabe10e71c6fb$var$hasSetupGlobalListeners = true;\n}\nif (typeof document !== \"undefined\") {\n    if (document.readyState !== \"loading\") $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    else document.addEventListener(\"DOMContentLoaded\", $507fabe10e71c6fb$var$setupGlobalFocusEvents);\n}\nfunction $507fabe10e71c6fb$export$b9b3dfddab17db27() {\n    return $507fabe10e71c6fb$var$currentModality !== \"pointer\";\n}\nfunction $507fabe10e71c6fb$export$630ff653c5ada6a9() {\n    return $507fabe10e71c6fb$var$currentModality;\n}\nfunction $507fabe10e71c6fb$export$8397ddfc504fdb9a(modality) {\n    $507fabe10e71c6fb$var$currentModality = modality;\n    $507fabe10e71c6fb$var$triggerChangeHandlers(modality, null);\n}\nfunction $507fabe10e71c6fb$export$98e20ec92f614cfe() {\n    $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    let [modality, setModality] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($507fabe10e71c6fb$var$currentModality);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let handler = ()=>{\n            setModality($507fabe10e71c6fb$var$currentModality);\n        };\n        $507fabe10e71c6fb$var$changeHandlers.add(handler);\n        return ()=>{\n            $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n        };\n    }, []);\n    return (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_5__.useIsSSR)() ? null : modality;\n}\nconst $507fabe10e71c6fb$var$nonTextInputTypes = new Set([\n    \"checkbox\",\n    \"radio\",\n    \"range\",\n    \"color\",\n    \"file\",\n    \"image\",\n    \"button\",\n    \"submit\",\n    \"reset\"\n]);\n/**\n * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that\n * focus visible style can be properly set.\n */ function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e) {\n    var _e_target;\n    isTextInput = isTextInput || (e === null || e === void 0 ? void 0 : e.target) instanceof HTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(e === null || e === void 0 ? void 0 : (_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.type) || (e === null || e === void 0 ? void 0 : e.target) instanceof HTMLTextAreaElement || (e === null || e === void 0 ? void 0 : e.target) instanceof HTMLElement && (e === null || e === void 0 ? void 0 : e.target.isContentEditable);\n    return !(isTextInput && modality === \"keyboard\" && e instanceof KeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\nfunction $507fabe10e71c6fb$export$ffd9e5021c1fb2d6(props = {}) {\n    let { isTextInput: isTextInput, autoFocus: autoFocus } = props;\n    let [isFocusVisibleState, setFocusVisible] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27());\n    $507fabe10e71c6fb$export$ec71b4b83ac08ec3((isFocusVisible)=>{\n        setFocusVisible(isFocusVisible);\n    }, [\n        isTextInput\n    ], {\n        isTextInput: isTextInput\n    });\n    return {\n        isFocusVisible: isFocusVisibleState\n    };\n}\nfunction $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {\n    $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let handler = (modality, e)=>{\n            if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e)) return;\n            fn($507fabe10e71c6fb$export$b9b3dfddab17db27());\n        };\n        $507fabe10e71c6fb$var$changeHandlers.add(handler);\n        return ()=>{\n            $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, deps);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\n\nfunction $9ab94262bd0047c7$export$420e68273165f4ec(props) {\n    let { isDisabled: isDisabled, onBlurWithin: onBlurWithin, onFocusWithin: onFocusWithin, onFocusWithinChange: onFocusWithinChange } = props;\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isFocusWithin: false\n    });\n    let onBlur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again\n        // when moving focus inside the element. Only trigger if the currentTarget doesn't\n        // include the relatedTarget (where focus is moving).\n        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {\n            state.current.isFocusWithin = false;\n            if (onBlurWithin) onBlurWithin(e);\n            if (onFocusWithinChange) onFocusWithinChange(false);\n        }\n    }, [\n        onBlurWithin,\n        onFocusWithinChange,\n        state\n    ]);\n    let onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);\n    let onFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // Double check that document.activeElement actually matches e.target in case a previously chained\n        // focus handler already moved focus somewhere else.\n        if (!state.current.isFocusWithin && document.activeElement === e.target) {\n            if (onFocusWithin) onFocusWithin(e);\n            if (onFocusWithinChange) onFocusWithinChange(true);\n            state.current.isFocusWithin = true;\n            onSyntheticFocus(e);\n        }\n    }, [\n        onFocusWithin,\n        onFocusWithinChange,\n        onSyntheticFocus\n    ]);\n    if (isDisabled) return {\n        focusWithinProps: {\n            // These should not have been null, that would conflict in mergeProps\n            onFocus: undefined,\n            onBlur: undefined\n        }\n    };\n    return {\n        focusWithinProps: {\n            onFocus: onFocus,\n            onBlur: onBlur\n        }\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\n// iOS fires onPointerEnter twice: once with pointerType=\"touch\" and again with pointerType=\"mouse\".\n// We want to ignore these emulated events so they do not trigger hover behavior.\n// See https://bugs.webkit.org/show_bug.cgi?id=214609.\nlet $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\nlet $6179b936705e76d3$var$hoverCount = 0;\nfunction $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {\n    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;\n    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter\n    // with pointerType=\"mouse\" immediately after onPointerUp and before onFocus. On other\n    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in\n    // the distant future because a user previously touched the element.\n    setTimeout(()=>{\n        $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\n    }, 50);\n}\nfunction $6179b936705e76d3$var$handleGlobalPointerEvent(e) {\n    if (e.pointerType === \"touch\") $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();\n}\nfunction $6179b936705e76d3$var$setupGlobalTouchEvents() {\n    if (typeof document === \"undefined\") return;\n    if (typeof PointerEvent !== \"undefined\") document.addEventListener(\"pointerup\", $6179b936705e76d3$var$handleGlobalPointerEvent);\n    else document.addEventListener(\"touchend\", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);\n    $6179b936705e76d3$var$hoverCount++;\n    return ()=>{\n        $6179b936705e76d3$var$hoverCount--;\n        if ($6179b936705e76d3$var$hoverCount > 0) return;\n        if (typeof PointerEvent !== \"undefined\") document.removeEventListener(\"pointerup\", $6179b936705e76d3$var$handleGlobalPointerEvent);\n        else document.removeEventListener(\"touchend\", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);\n    };\n}\nfunction $6179b936705e76d3$export$ae780daf29e6d456(props) {\n    let { onHoverStart: onHoverStart, onHoverChange: onHoverChange, onHoverEnd: onHoverEnd, isDisabled: isDisabled } = props;\n    let [isHovered, setHovered] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isHovered: false,\n        ignoreEmulatedMouseEvents: false,\n        pointerType: \"\",\n        target: null\n    }).current;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);\n    let { hoverProps: hoverProps, triggerHoverEnd: triggerHoverEnd } = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let triggerHoverStart = (event, pointerType)=>{\n            state.pointerType = pointerType;\n            if (isDisabled || pointerType === \"touch\" || state.isHovered || !event.currentTarget.contains(event.target)) return;\n            state.isHovered = true;\n            let target = event.currentTarget;\n            state.target = target;\n            if (onHoverStart) onHoverStart({\n                type: \"hoverstart\",\n                target: target,\n                pointerType: pointerType\n            });\n            if (onHoverChange) onHoverChange(true);\n            setHovered(true);\n        };\n        let triggerHoverEnd = (event, pointerType)=>{\n            state.pointerType = \"\";\n            state.target = null;\n            if (pointerType === \"touch\" || !state.isHovered) return;\n            state.isHovered = false;\n            let target = event.currentTarget;\n            if (onHoverEnd) onHoverEnd({\n                type: \"hoverend\",\n                target: target,\n                pointerType: pointerType\n            });\n            if (onHoverChange) onHoverChange(false);\n            setHovered(false);\n        };\n        let hoverProps = {};\n        if (typeof PointerEvent !== \"undefined\") {\n            hoverProps.onPointerEnter = (e)=>{\n                if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e.pointerType === \"mouse\") return;\n                triggerHoverStart(e, e.pointerType);\n            };\n            hoverProps.onPointerLeave = (e)=>{\n                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);\n            };\n        } else {\n            hoverProps.onTouchStart = ()=>{\n                state.ignoreEmulatedMouseEvents = true;\n            };\n            hoverProps.onMouseEnter = (e)=>{\n                if (!state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, \"mouse\");\n                state.ignoreEmulatedMouseEvents = false;\n            };\n            hoverProps.onMouseLeave = (e)=>{\n                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, \"mouse\");\n            };\n        }\n        return {\n            hoverProps: hoverProps,\n            triggerHoverEnd: triggerHoverEnd\n        };\n    }, [\n        onHoverStart,\n        onHoverChange,\n        onHoverEnd,\n        isDisabled,\n        state\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Call the triggerHoverEnd as soon as isDisabled changes to true\n        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering\n        if (isDisabled) triggerHoverEnd({\n            currentTarget: state.target\n        }, state.pointerType);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled\n    ]);\n    return {\n        hoverProps: hoverProps,\n        isHovered: isHovered\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\n\nfunction $e0b6e0b68ec7f50f$export$872b660ac5a1ff98(props) {\n    let { ref: ref, onInteractOutside: onInteractOutside, isDisabled: isDisabled, onInteractOutsideStart: onInteractOutsideStart } = props;\n    let stateRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isPointerDown: false,\n        ignoreEmulatedMouseEvents: false\n    });\n    let onPointerDown = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        if (onInteractOutside && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) {\n            if (onInteractOutsideStart) onInteractOutsideStart(e);\n            stateRef.current.isPointerDown = true;\n        }\n    });\n    let triggerInteractOutside = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        if (onInteractOutside) onInteractOutside(e);\n    });\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let state = stateRef.current;\n        if (isDisabled) return;\n        const element = ref.current;\n        const documentObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(element);\n        // Use pointer events if available. Otherwise, fall back to mouse and touch events.\n        if (typeof PointerEvent !== \"undefined\") {\n            let onPointerUp = (e)=>{\n                if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n                state.isPointerDown = false;\n            };\n            // changing these to capture phase fixed combobox\n            documentObject.addEventListener(\"pointerdown\", onPointerDown, true);\n            documentObject.addEventListener(\"pointerup\", onPointerUp, true);\n            return ()=>{\n                documentObject.removeEventListener(\"pointerdown\", onPointerDown, true);\n                documentObject.removeEventListener(\"pointerup\", onPointerUp, true);\n            };\n        } else {\n            let onMouseUp = (e)=>{\n                if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;\n                else if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n                state.isPointerDown = false;\n            };\n            let onTouchEnd = (e)=>{\n                state.ignoreEmulatedMouseEvents = true;\n                if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n                state.isPointerDown = false;\n            };\n            documentObject.addEventListener(\"mousedown\", onPointerDown, true);\n            documentObject.addEventListener(\"mouseup\", onMouseUp, true);\n            documentObject.addEventListener(\"touchstart\", onPointerDown, true);\n            documentObject.addEventListener(\"touchend\", onTouchEnd, true);\n            return ()=>{\n                documentObject.removeEventListener(\"mousedown\", onPointerDown, true);\n                documentObject.removeEventListener(\"mouseup\", onMouseUp, true);\n                documentObject.removeEventListener(\"touchstart\", onPointerDown, true);\n                documentObject.removeEventListener(\"touchend\", onTouchEnd, true);\n            };\n        }\n    }, [\n        ref,\n        isDisabled,\n        onPointerDown,\n        triggerInteractOutside\n    ]);\n}\nfunction $e0b6e0b68ec7f50f$var$isValidEvent(event, ref) {\n    if (event.button > 0) return false;\n    if (event.target) {\n        // if the event target is no longer in the document, ignore\n        const ownerDocument = event.target.ownerDocument;\n        if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;\n        // If the target is within a top layer element (e.g. toasts), ignore.\n        if (event.target.closest(\"[data-react-aria-top-layer]\")) return false;\n    }\n    return ref.current && !ref.current.contains(event.target);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $93925083ecbb358c$export$48d1ea6320830260(handler) {\n    if (!handler) return undefined;\n    let shouldStopPropagation = true;\n    return (e)=>{\n        let event = {\n            ...e,\n            preventDefault () {\n                e.preventDefault();\n            },\n            isDefaultPrevented () {\n                return e.isDefaultPrevented();\n            },\n            stopPropagation () {\n                console.error(\"stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.\");\n            },\n            continuePropagation () {\n                shouldStopPropagation = false;\n            }\n        };\n        handler(event);\n        if (shouldStopPropagation) e.stopPropagation();\n    };\n}\n\n\nfunction $46d819fcbaf35654$export$8f71654801c2f7cd(props) {\n    return {\n        keyboardProps: props.isDisabled ? {} : {\n            onKeyDown: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyDown),\n            onKeyUp: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyUp)\n        }\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nfunction $e8a7022cf87cba2a$export$36da96379f79f245(props) {\n    let { onMoveStart: onMoveStart, onMove: onMove, onMoveEnd: onMoveEnd } = props;\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        didMove: false,\n        lastPosition: null,\n        id: null\n    });\n    let { addGlobalListener: addGlobalListener, removeGlobalListener: removeGlobalListener } = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useGlobalListeners)();\n    let move = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType, deltaX, deltaY)=>{\n        if (deltaX === 0 && deltaY === 0) return;\n        if (!state.current.didMove) {\n            state.current.didMove = true;\n            onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({\n                type: \"movestart\",\n                pointerType: pointerType,\n                shiftKey: originalEvent.shiftKey,\n                metaKey: originalEvent.metaKey,\n                ctrlKey: originalEvent.ctrlKey,\n                altKey: originalEvent.altKey\n            });\n        }\n        onMove === null || onMove === void 0 ? void 0 : onMove({\n            type: \"move\",\n            pointerType: pointerType,\n            deltaX: deltaX,\n            deltaY: deltaY,\n            shiftKey: originalEvent.shiftKey,\n            metaKey: originalEvent.metaKey,\n            ctrlKey: originalEvent.ctrlKey,\n            altKey: originalEvent.altKey\n        });\n    });\n    let end = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType)=>{\n        (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)();\n        if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({\n            type: \"moveend\",\n            pointerType: pointerType,\n            shiftKey: originalEvent.shiftKey,\n            metaKey: originalEvent.metaKey,\n            ctrlKey: originalEvent.ctrlKey,\n            altKey: originalEvent.altKey\n        });\n    });\n    let moveProps = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let moveProps = {};\n        let start = ()=>{\n            (0, $14c0b72509d70225$export$16a4697467175487)();\n            state.current.didMove = false;\n        };\n        if (typeof PointerEvent === \"undefined\") {\n            let onMouseMove = (e)=>{\n                if (e.button === 0) {\n                    var _state_current_lastPosition, _state_current_lastPosition1;\n                    var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;\n                    move(e, \"mouse\", e.pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), e.pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                }\n            };\n            let onMouseUp = (e)=>{\n                if (e.button === 0) {\n                    end(e, \"mouse\");\n                    removeGlobalListener(window, \"mousemove\", onMouseMove, false);\n                    removeGlobalListener(window, \"mouseup\", onMouseUp, false);\n                }\n            };\n            moveProps.onMouseDown = (e)=>{\n                if (e.button === 0) {\n                    start();\n                    e.stopPropagation();\n                    e.preventDefault();\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                    addGlobalListener(window, \"mousemove\", onMouseMove, false);\n                    addGlobalListener(window, \"mouseup\", onMouseUp, false);\n                }\n            };\n            let onTouchMove = (e)=>{\n                let touch = [\n                    ...e.changedTouches\n                ].findIndex(({ identifier: identifier })=>identifier === state.current.id);\n                if (touch >= 0) {\n                    var _state_current_lastPosition, _state_current_lastPosition1;\n                    let { pageX: pageX, pageY: pageY } = e.changedTouches[touch];\n                    var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;\n                    move(e, \"touch\", pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));\n                    state.current.lastPosition = {\n                        pageX: pageX,\n                        pageY: pageY\n                    };\n                }\n            };\n            let onTouchEnd = (e)=>{\n                let touch = [\n                    ...e.changedTouches\n                ].findIndex(({ identifier: identifier })=>identifier === state.current.id);\n                if (touch >= 0) {\n                    end(e, \"touch\");\n                    state.current.id = null;\n                    removeGlobalListener(window, \"touchmove\", onTouchMove);\n                    removeGlobalListener(window, \"touchend\", onTouchEnd);\n                    removeGlobalListener(window, \"touchcancel\", onTouchEnd);\n                }\n            };\n            moveProps.onTouchStart = (e)=>{\n                if (e.changedTouches.length === 0 || state.current.id != null) return;\n                let { pageX: pageX, pageY: pageY, identifier: identifier } = e.changedTouches[0];\n                start();\n                e.stopPropagation();\n                e.preventDefault();\n                state.current.lastPosition = {\n                    pageX: pageX,\n                    pageY: pageY\n                };\n                state.current.id = identifier;\n                addGlobalListener(window, \"touchmove\", onTouchMove, false);\n                addGlobalListener(window, \"touchend\", onTouchEnd, false);\n                addGlobalListener(window, \"touchcancel\", onTouchEnd, false);\n            };\n        } else {\n            let onPointerMove = (e)=>{\n                if (e.pointerId === state.current.id) {\n                    var _state_current_lastPosition, _state_current_lastPosition1;\n                    let pointerType = e.pointerType || \"mouse\";\n                    var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;\n                    // Problems with PointerEvent#movementX/movementY:\n                    // 1. it is always 0 on macOS Safari.\n                    // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS\n                    move(e, pointerType, e.pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), e.pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                }\n            };\n            let onPointerUp = (e)=>{\n                if (e.pointerId === state.current.id) {\n                    let pointerType = e.pointerType || \"mouse\";\n                    end(e, pointerType);\n                    state.current.id = null;\n                    removeGlobalListener(window, \"pointermove\", onPointerMove, false);\n                    removeGlobalListener(window, \"pointerup\", onPointerUp, false);\n                    removeGlobalListener(window, \"pointercancel\", onPointerUp, false);\n                }\n            };\n            moveProps.onPointerDown = (e)=>{\n                if (e.button === 0 && state.current.id == null) {\n                    start();\n                    e.stopPropagation();\n                    e.preventDefault();\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                    state.current.id = e.pointerId;\n                    addGlobalListener(window, \"pointermove\", onPointerMove, false);\n                    addGlobalListener(window, \"pointerup\", onPointerUp, false);\n                    addGlobalListener(window, \"pointercancel\", onPointerUp, false);\n                }\n            };\n        }\n        let triggerKeyboardMove = (e, deltaX, deltaY)=>{\n            start();\n            move(e, \"keyboard\", deltaX, deltaY);\n            end(e, \"keyboard\");\n        };\n        moveProps.onKeyDown = (e)=>{\n            switch(e.key){\n                case \"Left\":\n                case \"ArrowLeft\":\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, -1, 0);\n                    break;\n                case \"Right\":\n                case \"ArrowRight\":\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, 1, 0);\n                    break;\n                case \"Up\":\n                case \"ArrowUp\":\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, 0, -1);\n                    break;\n                case \"Down\":\n                case \"ArrowDown\":\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, 0, 1);\n                    break;\n            }\n        };\n        return moveProps;\n    }, [\n        state,\n        addGlobalListener,\n        removeGlobalListener,\n        move,\n        end\n    ]);\n    return {\n        moveProps: moveProps\n    };\n}\n\n\n\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nfunction $7d0a636d7a4dcefd$export$2123ff2b87c81ca(props, ref) {\n    let { onScroll: onScroll, isDisabled: isDisabled } = props;\n    let onScrollHandler = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // If the ctrlKey is pressed, this is a zoom event, do nothing.\n        if (e.ctrlKey) return;\n        // stop scrolling the page\n        e.preventDefault();\n        e.stopPropagation();\n        if (onScroll) onScroll({\n            deltaX: e.deltaX,\n            deltaY: e.deltaY\n        });\n    }, [\n        onScroll\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEvent)(ref, \"wheel\", isDisabled ? undefined : onScrollHandler);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nconst $8a26561d2877236e$var$DEFAULT_THRESHOLD = 500;\nfunction $8a26561d2877236e$export$c24ed0104d07eab9(props) {\n    let { isDisabled: isDisabled, onLongPressStart: onLongPressStart, onLongPressEnd: onLongPressEnd, onLongPress: onLongPress, threshold: threshold = $8a26561d2877236e$var$DEFAULT_THRESHOLD, accessibilityDescription: accessibilityDescription } = props;\n    const timeRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    let { addGlobalListener: addGlobalListener, removeGlobalListener: removeGlobalListener } = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useGlobalListeners)();\n    let { pressProps: pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({\n        isDisabled: isDisabled,\n        onPressStart (e) {\n            e.continuePropagation();\n            if (e.pointerType === \"mouse\" || e.pointerType === \"touch\") {\n                if (onLongPressStart) onLongPressStart({\n                    ...e,\n                    type: \"longpressstart\"\n                });\n                timeRef.current = setTimeout(()=>{\n                    // Prevent other usePress handlers from also handling this event.\n                    e.target.dispatchEvent(new PointerEvent(\"pointercancel\", {\n                        bubbles: true\n                    }));\n                    if (onLongPress) onLongPress({\n                        ...e,\n                        type: \"longpress\"\n                    });\n                    timeRef.current = undefined;\n                }, threshold);\n                // Prevent context menu, which may be opened on long press on touch devices\n                if (e.pointerType === \"touch\") {\n                    let onContextMenu = (e)=>{\n                        e.preventDefault();\n                    };\n                    addGlobalListener(e.target, \"contextmenu\", onContextMenu, {\n                        once: true\n                    });\n                    addGlobalListener(window, \"pointerup\", ()=>{\n                        // If no contextmenu event is fired quickly after pointerup, remove the handler\n                        // so future context menu events outside a long press are not prevented.\n                        setTimeout(()=>{\n                            removeGlobalListener(e.target, \"contextmenu\", onContextMenu);\n                        }, 30);\n                    }, {\n                        once: true\n                    });\n                }\n            }\n        },\n        onPressEnd (e) {\n            if (timeRef.current) clearTimeout(timeRef.current);\n            if (onLongPressEnd && (e.pointerType === \"mouse\" || e.pointerType === \"touch\")) onLongPressEnd({\n                ...e,\n                type: \"longpressend\"\n            });\n        }\n    });\n    let descriptionProps = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useDescription)(onLongPress && !isDisabled ? accessibilityDescription : undefined);\n    return {\n        longPressProps: (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(pressProps, descriptionProps)\n    };\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL2ludGVyYWN0aW9ucy9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRyQjtBQUNyZTtBQUNqSjtBQUNFO0FBQ0Q7QUFDWDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFZO0FBQ3hCO0FBQ0E7QUFDQSx1Q0FBdUMsK0RBQXVCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvREFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUVBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywrREFBdUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsa0NBQVk7QUFDbEU7QUFDQSxDQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0Esc0JBQXNCLDZDQUFpQjtBQUN2QztBQUNBLGNBQWMs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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxrQkFBa0IsNkRBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLHdCQUF3QiwwQ0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3QkFBd0I7QUFDdkQ7QUFDQTtBQUNBLDBCQUEwQiw2QkFBNkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3QkFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQXFEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSw2Q0FBNkM7QUFDdkQsOEJBQThCLDhDQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUSx1REFBZTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVUsMk9BQTJPO0FBQ3JQLHdCQUF3Qix5Q0FBYTtBQUNyQyxVQUFVLG1GQUFtRixNQUFNLGlFQUF5QjtBQUM1SCxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLCtCQUErQiw2REFBcUI7QUFDcEQ7QUFDQSw0QkFBNEIseURBQWlCO0FBQzdDO0FBQ0E7Ozs7O0FBS3lsQztBQUN6bEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvaW50ZXJhY3Rpb25zL2Rpc3QvaW1wb3J0Lm1qcz85MGI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlT2JqZWN0UmVmIGFzICRieDdTTCR1c2VPYmplY3RSZWYsIG1lcmdlUHJvcHMgYXMgJGJ4N1NMJG1lcmdlUHJvcHMsIHVzZVN5bmNSZWYgYXMgJGJ4N1NMJHVzZVN5bmNSZWYsIHVzZUdsb2JhbExpc3RlbmVycyBhcyAkYng3U0wkdXNlR2xvYmFsTGlzdGVuZXJzLCB1c2VFZmZlY3RFdmVudCBhcyAkYng3U0wkdXNlRWZmZWN0RXZlbnQsIGdldE93bmVyRG9jdW1lbnQgYXMgJGJ4N1NMJGdldE93bmVyRG9jdW1lbnQsIGlzTWFjIGFzICRieDdTTCRpc01hYywgb3BlbkxpbmsgYXMgJGJ4N1NMJG9wZW5MaW5rLCBpc1ZpcnR1YWxDbGljayBhcyAkYng3U0wkaXNWaXJ0dWFsQ2xpY2ssIGZvY3VzV2l0aG91dFNjcm9sbGluZyBhcyAkYng3U0wkZm9jdXNXaXRob3V0U2Nyb2xsaW5nLCBpc1ZpcnR1YWxQb2ludGVyRXZlbnQgYXMgJGJ4N1NMJGlzVmlydHVhbFBvaW50ZXJFdmVudCwgZ2V0T3duZXJXaW5kb3cgYXMgJGJ4N1NMJGdldE93bmVyV2luZG93LCBpc0lPUyBhcyAkYng3U0wkaXNJT1MsIHJ1bkFmdGVyVHJhbnNpdGlvbiBhcyAkYng3U0wkcnVuQWZ0ZXJUcmFuc2l0aW9uLCB1c2VMYXlvdXRFZmZlY3QgYXMgJGJ4N1NMJHVzZUxheW91dEVmZmVjdCwgdXNlRXZlbnQgYXMgJGJ4N1NMJHVzZUV2ZW50LCB1c2VEZXNjcmlwdGlvbiBhcyAkYng3U0wkdXNlRGVzY3JpcHRpb259IGZyb20gXCJAcmVhY3QtYXJpYS91dGlsc1wiO1xuaW1wb3J0ICRieDdTTCRyZWFjdCwge3VzZUNvbnRleHQgYXMgJGJ4N1NMJHVzZUNvbnRleHQsIHVzZVN0YXRlIGFzICRieDdTTCR1c2VTdGF0ZSwgdXNlUmVmIGFzICRieDdTTCR1c2VSZWYsIHVzZU1lbW8gYXMgJGJ4N1NMJHVzZU1lbW8sIHVzZUVmZmVjdCBhcyAkYng3U0wkdXNlRWZmZWN0LCB1c2VDYWxsYmFjayBhcyAkYng3U0wkdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtfIGFzICRieDdTTCRffSBmcm9tIFwiQHN3Yy9oZWxwZXJzL18vX2NsYXNzX3ByaXZhdGVfZmllbGRfZ2V0XCI7XG5pbXBvcnQge18gYXMgJGJ4N1NMJF8xfSBmcm9tIFwiQHN3Yy9oZWxwZXJzL18vX2NsYXNzX3ByaXZhdGVfZmllbGRfaW5pdFwiO1xuaW1wb3J0IHtfIGFzICRieDdTTCRfMn0gZnJvbSBcIkBzd2MvaGVscGVycy9fL19jbGFzc19wcml2YXRlX2ZpZWxkX3NldFwiO1xuaW1wb3J0IHt1c2VJc1NTUiBhcyAkYng3U0wkdXNlSXNTU1J9IGZyb20gXCJAcmVhY3QtYXJpYS9zc3JcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvLyBQb3J0aW9ucyBvZiB0aGUgY29kZSBpbiB0aGlzIGZpbGUgYXJlIGJhc2VkIG9uIGNvZGUgZnJvbSByZWFjdC5cbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBmb3IgdGhlIGZvbGxvd2luZyBjYW4gYmUgZm91bmQgaW4gdGhlXG4vLyBOT1RJQ0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvdHJlZS9jYzdjMWFlY2U0NmE2YjY5YjQxOTU4ZDczMWUwZmQyN2M5NGJmYzZjL3BhY2thZ2VzL3JlYWN0LWludGVyYWN0aW9uc1xuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuLy8gTm90ZSB0aGF0IHN0YXRlIG9ubHkgbWF0dGVycyBoZXJlIGZvciBpT1MuIE5vbi1pT1MgZ2V0cyB1c2VyLXNlbGVjdDogbm9uZSBhcHBsaWVkIHRvIHRoZSB0YXJnZXQgZWxlbWVudFxuLy8gcmF0aGVyIHRoYW4gYXQgdGhlIGRvY3VtZW50IGxldmVsIHNvIHdlIGp1c3QgbmVlZCB0byBhcHBseS9yZW1vdmUgdXNlci1zZWxlY3Q6IG5vbmUgZm9yIGVhY2ggcHJlc3NlZCBlbGVtZW50IGluZGl2aWR1YWxseVxubGV0ICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzdGF0ZSA9IFwiZGVmYXVsdFwiO1xubGV0ICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzYXZlZFVzZXJTZWxlY3QgPSBcIlwiO1xubGV0ICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRtb2RpZmllZEVsZW1lbnRNYXAgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gJDE0YzBiNzI1MDlkNzAyMjUkZXhwb3J0JDE2YTQ2OTc0NjcxNzU0ODcodGFyZ2V0KSB7XG4gICAgaWYgKCgwLCAkYng3U0wkaXNJT1MpKCkpIHtcbiAgICAgICAgaWYgKCQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzdGF0ZSA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50T2JqZWN0ID0gKDAsICRieDdTTCRnZXRPd25lckRvY3VtZW50KSh0YXJnZXQpO1xuICAgICAgICAgICAgJDE0YzBiNzI1MDlkNzAyMjUkdmFyJHNhdmVkVXNlclNlbGVjdCA9IGRvY3VtZW50T2JqZWN0LmRvY3VtZW50RWxlbWVudC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0O1xuICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QuZG9jdW1lbnRFbGVtZW50LnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSBcIm5vbmVcIjtcbiAgICAgICAgfVxuICAgICAgICAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc3RhdGUgPSBcImRpc2FibGVkXCI7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCB0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgICAgIC8vIElmIG5vdCBpT1MsIHN0b3JlIHRoZSB0YXJnZXQncyBvcmlnaW5hbCB1c2VyLXNlbGVjdCBhbmQgY2hhbmdlIHRvIHVzZXItc2VsZWN0OiBub25lXG4gICAgICAgIC8vIElnbm9yZSBzdGF0ZSBzaW5jZSBpdCBkb2Vzbid0IGFwcGx5IGZvciBub24gaU9TXG4gICAgICAgICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRtb2RpZmllZEVsZW1lbnRNYXAuc2V0KHRhcmdldCwgdGFyZ2V0LnN0eWxlLnVzZXJTZWxlY3QpO1xuICAgICAgICB0YXJnZXQuc3R5bGUudXNlclNlbGVjdCA9IFwibm9uZVwiO1xuICAgIH1cbn1cbmZ1bmN0aW9uICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCRiMGQ2ZmExYWIzMmUzMjk1KHRhcmdldCkge1xuICAgIGlmICgoMCwgJGJ4N1NMJGlzSU9TKSgpKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdGF0ZSBpcyBhbHJlYWR5IGRlZmF1bHQsIHRoZXJlJ3Mgbm90aGluZyB0byBkby5cbiAgICAgICAgLy8gSWYgaXQgaXMgcmVzdG9yaW5nLCB0aGVuIHRoZXJlJ3Mgbm8gbmVlZCB0byBxdWV1ZSBhIHNlY29uZCByZXN0b3JlLlxuICAgICAgICBpZiAoJDE0YzBiNzI1MDlkNzAyMjUkdmFyJHN0YXRlICE9PSBcImRpc2FibGVkXCIpIHJldHVybjtcbiAgICAgICAgJDE0YzBiNzI1MDlkNzAyMjUkdmFyJHN0YXRlID0gXCJyZXN0b3JpbmdcIjtcbiAgICAgICAgLy8gVGhlcmUgYXBwZWFycyB0byBiZSBhIGRlbGF5IG9uIGlPUyB3aGVyZSBzZWxlY3Rpb24gc3RpbGwgbWlnaHQgb2NjdXJcbiAgICAgICAgLy8gYWZ0ZXIgcG9pbnRlciB1cCwgc28gd2FpdCBhIGJpdCBiZWZvcmUgcmVtb3ZpbmcgdXNlci1zZWxlY3QuXG4gICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIGFueSBDU1MgdHJhbnNpdGlvbnMgdG8gY29tcGxldGUgc28gd2UgZG9uJ3QgcmVjb21wdXRlIHN0eWxlXG4gICAgICAgICAgICAvLyBmb3IgdGhlIHdob2xlIHBhZ2UgaW4gdGhlIG1pZGRsZSBvZiB0aGUgYW5pbWF0aW9uIGFuZCBjYXVzZSBqYW5rLlxuICAgICAgICAgICAgKDAsICRieDdTTCRydW5BZnRlclRyYW5zaXRpb24pKCgpPT57XG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgaWYgKCQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzdGF0ZSA9PT0gXCJyZXN0b3JpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50T2JqZWN0ID0gKDAsICRieDdTTCRnZXRPd25lckRvY3VtZW50KSh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnRPYmplY3QuZG9jdW1lbnRFbGVtZW50LnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPT09IFwibm9uZVwiKSBkb2N1bWVudE9iamVjdC5kb2N1bWVudEVsZW1lbnQuc3R5bGUud2Via2l0VXNlclNlbGVjdCA9ICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzYXZlZFVzZXJTZWxlY3QgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgJDE0YzBiNzI1MDlkNzAyMjUkdmFyJHNhdmVkVXNlclNlbGVjdCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzdGF0ZSA9IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCAzMDApO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkgLy8gSWYgbm90IGlPUywgcmVzdG9yZSB0aGUgdGFyZ2V0J3Mgb3JpZ2luYWwgdXNlci1zZWxlY3QgaWYgYW55XG4gICAgLy8gSWdub3JlIHN0YXRlIHNpbmNlIGl0IGRvZXNuJ3QgYXBwbHkgZm9yIG5vbiBpT1NcbiAgICB7XG4gICAgICAgIGlmICh0YXJnZXQgJiYgJDE0YzBiNzI1MDlkNzAyMjUkdmFyJG1vZGlmaWVkRWxlbWVudE1hcC5oYXModGFyZ2V0KSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldE9sZFVzZXJTZWxlY3QgPSAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkbW9kaWZpZWRFbGVtZW50TWFwLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHRhcmdldC5zdHlsZS51c2VyU2VsZWN0ID09PSBcIm5vbmVcIiAmJiB0YXJnZXRPbGRVc2VyU2VsZWN0KSB0YXJnZXQuc3R5bGUudXNlclNlbGVjdCA9IHRhcmdldE9sZFVzZXJTZWxlY3Q7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpID09PSBcIlwiKSB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgICAgICAgICAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkbW9kaWZpZWRFbGVtZW50TWFwLmRlbGV0ZSh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuY29uc3QgJGFlMWVlYmE4YjllYWZkMDgkZXhwb3J0JDUxNjVlY2NiMzVhYWFkYjUgPSAoMCwgJGJ4N1NMJHJlYWN0KS5jcmVhdGVDb250ZXh0KHtcbiAgICByZWdpc3RlcjogKCk9Pnt9XG59KTtcbiRhZTFlZWJhOGI5ZWFmZDA4JGV4cG9ydCQ1MTY1ZWNjYjM1YWFhZGI1LmRpc3BsYXlOYW1lID0gXCJQcmVzc1Jlc3BvbmRlckNvbnRleHRcIjtcblxuXG5cbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJHZhciR1c2VQcmVzc1Jlc3BvbmRlckNvbnRleHQocHJvcHMpIHtcbiAgICAvLyBDb25zdW1lIGNvbnRleHQgZnJvbSA8UHJlc3NSZXNwb25kZXI+IGFuZCBtZXJnZSB3aXRoIHByb3BzLlxuICAgIGxldCBjb250ZXh0ID0gKDAsICRieDdTTCR1c2VDb250ZXh0KSgoMCwgJGFlMWVlYmE4YjllYWZkMDgkZXhwb3J0JDUxNjVlY2NiMzVhYWFkYjUpKTtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBsZXQgeyByZWdpc3RlcjogcmVnaXN0ZXIsIC4uLmNvbnRleHRQcm9wcyB9ID0gY29udGV4dDtcbiAgICAgICAgcHJvcHMgPSAoMCwgJGJ4N1NMJG1lcmdlUHJvcHMpKGNvbnRleHRQcm9wcywgcHJvcHMpO1xuICAgICAgICByZWdpc3RlcigpO1xuICAgIH1cbiAgICAoMCwgJGJ4N1NMJHVzZVN5bmNSZWYpKGNvbnRleHQsIHByb3BzLnJlZik7XG4gICAgcmV0dXJuIHByb3BzO1xufVxudmFyICRmNmMzMWNjZTJhZGY2NTRmJHZhciRfc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gLyojX19QVVJFX18qLyBuZXcgV2Vha01hcCgpO1xuY2xhc3MgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJFByZXNzRXZlbnQge1xuICAgIGNvbnRpbnVlUHJvcGFnYXRpb24oKSB7XG4gICAgICAgICgwLCAkYng3U0wkXzIpKHRoaXMsICRmNmMzMWNjZTJhZGY2NTRmJHZhciRfc2hvdWxkU3RvcFByb3BhZ2F0aW9uLCBmYWxzZSk7XG4gICAgfVxuICAgIGdldCBzaG91bGRTdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIHJldHVybiAoMCwgJGJ4N1NMJF8pKHRoaXMsICRmNmMzMWNjZTJhZGY2NTRmJHZhciRfc2hvdWxkU3RvcFByb3BhZ2F0aW9uKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodHlwZSwgcG9pbnRlclR5cGUsIG9yaWdpbmFsRXZlbnQpe1xuICAgICAgICAoMCwgJGJ4N1NMJF8xKSh0aGlzLCAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkX3Nob3VsZFN0b3BQcm9wYWdhdGlvbiwge1xuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgJGJ4N1NMJF8yKSh0aGlzLCAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkX3Nob3VsZFN0b3BQcm9wYWdhdGlvbiwgdHJ1ZSk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMucG9pbnRlclR5cGUgPSBwb2ludGVyVHlwZTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBvcmlnaW5hbEV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIHRoaXMuc2hpZnRLZXkgPSBvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICB0aGlzLm1ldGFLZXkgPSBvcmlnaW5hbEV2ZW50Lm1ldGFLZXk7XG4gICAgICAgIHRoaXMuY3RybEtleSA9IG9yaWdpbmFsRXZlbnQuY3RybEtleTtcbiAgICAgICAgdGhpcy5hbHRLZXkgPSBvcmlnaW5hbEV2ZW50LmFsdEtleTtcbiAgICB9XG59XG5jb25zdCAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkTElOS19DTElDS0VEID0gU3ltYm9sKFwibGlua0NsaWNrZWRcIik7XG5mdW5jdGlvbiAkZjZjMzFjY2UyYWRmNjU0ZiRleHBvcnQkNDU3MTJlY2VkYTZmYWQyMShwcm9wcykge1xuICAgIGxldCB7IG9uUHJlc3M6IG9uUHJlc3MsIG9uUHJlc3NDaGFuZ2U6IG9uUHJlc3NDaGFuZ2UsIG9uUHJlc3NTdGFydDogb25QcmVzc1N0YXJ0LCBvblByZXNzRW5kOiBvblByZXNzRW5kLCBvblByZXNzVXA6IG9uUHJlc3NVcCwgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCwgaXNQcmVzc2VkOiBpc1ByZXNzZWRQcm9wLCBwcmV2ZW50Rm9jdXNPblByZXNzOiBwcmV2ZW50Rm9jdXNPblByZXNzLCBzaG91bGRDYW5jZWxPblBvaW50ZXJFeGl0OiBzaG91bGRDYW5jZWxPblBvaW50ZXJFeGl0LCBhbGxvd1RleHRTZWxlY3Rpb25PblByZXNzOiBhbGxvd1RleHRTZWxlY3Rpb25PblByZXNzLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgcmVmOiBfLCAuLi5kb21Qcm9wcyB9ID0gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHVzZVByZXNzUmVzcG9uZGVyQ29udGV4dChwcm9wcyk7XG4gICAgbGV0IFtpc1ByZXNzZWQsIHNldFByZXNzZWRdID0gKDAsICRieDdTTCR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGxldCByZWYgPSAoMCwgJGJ4N1NMJHVzZVJlZikoe1xuICAgICAgICBpc1ByZXNzZWQ6IGZhbHNlLFxuICAgICAgICBpZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgaWdub3JlQ2xpY2tBZnRlclByZXNzOiBmYWxzZSxcbiAgICAgICAgZGlkRmlyZVByZXNzU3RhcnQ6IGZhbHNlLFxuICAgICAgICBpc1RyaWdnZXJpbmdFdmVudDogZmFsc2UsXG4gICAgICAgIGFjdGl2ZVBvaW50ZXJJZDogbnVsbCxcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICBpc092ZXJUYXJnZXQ6IGZhbHNlLFxuICAgICAgICBwb2ludGVyVHlwZTogbnVsbFxuICAgIH0pO1xuICAgIGxldCB7IGFkZEdsb2JhbExpc3RlbmVyOiBhZGRHbG9iYWxMaXN0ZW5lciwgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzOiByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMgfSA9ICgwLCAkYng3U0wkdXNlR2xvYmFsTGlzdGVuZXJzKSgpO1xuICAgIGxldCB0cmlnZ2VyUHJlc3NTdGFydCA9ICgwLCAkYng3U0wkdXNlRWZmZWN0RXZlbnQpKChvcmlnaW5hbEV2ZW50LCBwb2ludGVyVHlwZSk9PntcbiAgICAgICAgbGV0IHN0YXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHN0YXRlLmRpZEZpcmVQcmVzc1N0YXJ0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICBzdGF0ZS5pc1RyaWdnZXJpbmdFdmVudCA9IHRydWU7XG4gICAgICAgIGlmIChvblByZXNzU3RhcnQpIHtcbiAgICAgICAgICAgIGxldCBldmVudCA9IG5ldyAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkUHJlc3NFdmVudChcInByZXNzc3RhcnRcIiwgcG9pbnRlclR5cGUsIG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgb25QcmVzc1N0YXJ0KGV2ZW50KTtcbiAgICAgICAgICAgIHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IGV2ZW50LnNob3VsZFN0b3BQcm9wYWdhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25QcmVzc0NoYW5nZSkgb25QcmVzc0NoYW5nZSh0cnVlKTtcbiAgICAgICAgc3RhdGUuaXNUcmlnZ2VyaW5nRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuZGlkRmlyZVByZXNzU3RhcnQgPSB0cnVlO1xuICAgICAgICBzZXRQcmVzc2VkKHRydWUpO1xuICAgICAgICByZXR1cm4gc2hvdWxkU3RvcFByb3BhZ2F0aW9uO1xuICAgIH0pO1xuICAgIGxldCB0cmlnZ2VyUHJlc3NFbmQgPSAoMCwgJGJ4N1NMJHVzZUVmZmVjdEV2ZW50KSgob3JpZ2luYWxFdmVudCwgcG9pbnRlclR5cGUsIHdhc1ByZXNzZWQgPSB0cnVlKT0+e1xuICAgICAgICBsZXQgc3RhdGUgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFzdGF0ZS5kaWRGaXJlUHJlc3NTdGFydCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBzdGF0ZS5pZ25vcmVDbGlja0FmdGVyUHJlc3MgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5kaWRGaXJlUHJlc3NTdGFydCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pc1RyaWdnZXJpbmdFdmVudCA9IHRydWU7XG4gICAgICAgIGxldCBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICBpZiAob25QcmVzc0VuZCkge1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gbmV3ICRmNmMzMWNjZTJhZGY2NTRmJHZhciRQcmVzc0V2ZW50KFwicHJlc3NlbmRcIiwgcG9pbnRlclR5cGUsIG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgb25QcmVzc0VuZChldmVudCk7XG4gICAgICAgICAgICBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSBldmVudC5zaG91bGRTdG9wUHJvcGFnYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUHJlc3NDaGFuZ2UpIG9uUHJlc3NDaGFuZ2UoZmFsc2UpO1xuICAgICAgICBzZXRQcmVzc2VkKGZhbHNlKTtcbiAgICAgICAgaWYgKG9uUHJlc3MgJiYgd2FzUHJlc3NlZCAmJiAhaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gbmV3ICRmNmMzMWNjZTJhZGY2NTRmJHZhciRQcmVzc0V2ZW50KFwicHJlc3NcIiwgcG9pbnRlclR5cGUsIG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgb25QcmVzcyhldmVudCk7XG4gICAgICAgICAgICBzaG91bGRTdG9wUHJvcGFnYXRpb24gJiYgKHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IGV2ZW50LnNob3VsZFN0b3BQcm9wYWdhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuaXNUcmlnZ2VyaW5nRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNob3VsZFN0b3BQcm9wYWdhdGlvbjtcbiAgICB9KTtcbiAgICBsZXQgdHJpZ2dlclByZXNzVXAgPSAoMCwgJGJ4N1NMJHVzZUVmZmVjdEV2ZW50KSgob3JpZ2luYWxFdmVudCwgcG9pbnRlclR5cGUpPT57XG4gICAgICAgIGxldCBzdGF0ZSA9IHJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoaXNEaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob25QcmVzc1VwKSB7XG4gICAgICAgICAgICBzdGF0ZS5pc1RyaWdnZXJpbmdFdmVudCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBuZXcgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJFByZXNzRXZlbnQoXCJwcmVzc3VwXCIsIHBvaW50ZXJUeXBlLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIG9uUHJlc3NVcChldmVudCk7XG4gICAgICAgICAgICBzdGF0ZS5pc1RyaWdnZXJpbmdFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnNob3VsZFN0b3BQcm9wYWdhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBsZXQgY2FuY2VsID0gKDAsICRieDdTTCR1c2VFZmZlY3RFdmVudCkoKGUpPT57XG4gICAgICAgIGxldCBzdGF0ZSA9IHJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoc3RhdGUuaXNQcmVzc2VkICYmIHN0YXRlLnRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmlzT3ZlclRhcmdldCAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSB0cmlnZ2VyUHJlc3NFbmQoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGNyZWF0ZUV2ZW50KHN0YXRlLnRhcmdldCwgZSksIHN0YXRlLnBvaW50ZXJUeXBlLCBmYWxzZSk7XG4gICAgICAgICAgICBzdGF0ZS5pc1ByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhdGUuYWN0aXZlUG9pbnRlcklkID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLnBvaW50ZXJUeXBlID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycygpO1xuICAgICAgICAgICAgaWYgKCFhbGxvd1RleHRTZWxlY3Rpb25PblByZXNzKSAoMCwgJDE0YzBiNzI1MDlkNzAyMjUkZXhwb3J0JGIwZDZmYTFhYjMyZTMyOTUpKHN0YXRlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgY2FuY2VsT25Qb2ludGVyRXhpdCA9ICgwLCAkYng3U0wkdXNlRWZmZWN0RXZlbnQpKChlKT0+e1xuICAgICAgICBpZiAoc2hvdWxkQ2FuY2VsT25Qb2ludGVyRXhpdCkgY2FuY2VsKGUpO1xuICAgIH0pO1xuICAgIGxldCBwcmVzc1Byb3BzID0gKDAsICRieDdTTCR1c2VNZW1vKSgoKT0+e1xuICAgICAgICBsZXQgc3RhdGUgPSByZWYuY3VycmVudDtcbiAgICAgICAgbGV0IHByZXNzUHJvcHMgPSB7XG4gICAgICAgICAgICBvbktleURvd24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzVmFsaWRLZXlib2FyZEV2ZW50KGUubmF0aXZlRXZlbnQsIGUuY3VycmVudFRhcmdldCkgJiYgZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0YXRlX21ldGFLZXlFdmVudHM7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkc2hvdWxkUHJldmVudERlZmF1bHRLZXlib2FyZChlLnRhcmdldCwgZS5rZXkpKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBldmVudCBpcyByZXBlYXRpbmcsIGl0IG1heSBoYXZlIHN0YXJ0ZWQgb24gYSBkaWZmZXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBhZnRlciB3aGljaCBmb2N1cyBtb3ZlZCB0byB0aGUgY3VycmVudCBlbGVtZW50LiBJZ25vcmUgdGhlc2UgZXZlbnRzIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGhhbmRsZSB0aGUgZmlyc3Qga2V5IGRvd24gZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgIGxldCBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlzUHJlc3NlZCAmJiAhZS5yZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzUHJlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cmlnZ2VyUHJlc3NTdGFydChlLCBcImtleWJvYXJkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9jdXMgbWF5IG1vdmUgYmVmb3JlIHRoZSBrZXkgdXAgZXZlbnQsIHNvIHJlZ2lzdGVyIHRoZSBldmVudCBvbiB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgdGhlIHNhbWUgZWxlbWVudCB3aGVyZSB0aGUga2V5IGRvd24gZXZlbnQgb2NjdXJyZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcigoMCwgJGJ4N1NMJGdldE93bmVyRG9jdW1lbnQpKGUuY3VycmVudFRhcmdldCksIFwia2V5dXBcIiwgb25LZXlVcCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGtleWRvd24gZXZlbnRzIHRoYXQgb2NjdXIgd2hpbGUgdGhlIE1ldGEgKGUuZy4gQ29tbWFuZCkga2V5IGlzIGhlbGQuXG4gICAgICAgICAgICAgICAgICAgIC8vIG1hY09TIGhhcyBhIGJ1ZyB3aGVyZSBrZXl1cCBldmVudHMgYXJlIG5vdCBmaXJlZCB3aGlsZSB0aGUgTWV0YSBrZXkgaXMgZG93bi5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgTWV0YSBrZXkgaXRzZWxmIGlzIHJlbGVhc2VkIHdlIHdpbGwgZ2V0IGFuIGV2ZW50IGZvciB0aGF0LCBhbmQgd2UnbGwgYWN0IGFzIGlmXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBvZiB0aGVzZSBvdGhlciBrZXlzIHdlcmUgcmVsZWFzZWQgYXMgd2VsbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTM5MzUyNFxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTUyOTFcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI5OTU1M1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5tZXRhS2V5ICYmICgwLCAkYng3U0wkaXNNYWMpKCkpIChfc3RhdGVfbWV0YUtleUV2ZW50cyA9IHN0YXRlLm1ldGFLZXlFdmVudHMpID09PSBudWxsIHx8IF9zdGF0ZV9tZXRhS2V5RXZlbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVfbWV0YUtleUV2ZW50cy5zZXQoZS5rZXksIGUubmF0aXZlRXZlbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09IFwiTWV0YVwiKSBzdGF0ZS5tZXRhS2V5RXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uS2V5VXAgKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzVmFsaWRLZXlib2FyZEV2ZW50KGUubmF0aXZlRXZlbnQsIGUuY3VycmVudFRhcmdldCkgJiYgIWUucmVwZWF0ICYmIGUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkgJiYgc3RhdGUudGFyZ2V0KSB0cmlnZ2VyUHJlc3NVcCgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkY3JlYXRlRXZlbnQoc3RhdGUudGFyZ2V0LCBlKSwgXCJrZXlib2FyZFwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNsaWNrIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgJiYgIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZSAmJiBlLmJ1dHRvbiA9PT0gMCAmJiAhc3RhdGUuaXNUcmlnZ2VyaW5nRXZlbnQgJiYgISgwLCAkYng3U0wkb3BlbkxpbmspLmlzT3BlbmluZykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdHJpZ2dlcmVkIGZyb20gYSBzY3JlZW4gcmVhZGVyIG9yIGJ5IHVzaW5nIGVsZW1lbnQuY2xpY2soKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBhcyBpZiBpdCB3ZXJlIGEga2V5Ym9hcmQgY2xpY2suXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaWdub3JlQ2xpY2tBZnRlclByZXNzICYmICFzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzICYmICFzdGF0ZS5pc1ByZXNzZWQgJiYgKHN0YXRlLnBvaW50ZXJUeXBlID09PSBcInZpcnR1YWxcIiB8fCAoMCwgJGJ4N1NMJGlzVmlydHVhbENsaWNrKShlLm5hdGl2ZUV2ZW50KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgZWxlbWVudCByZWNlaXZlcyBmb2N1cyAoVm9pY2VPdmVyIG9uIGlPUyBkb2VzIG5vdCBkbyB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Rpc2FibGVkICYmICFwcmV2ZW50Rm9jdXNPblByZXNzKSAoMCwgJGJ4N1NMJGZvY3VzV2l0aG91dFNjcm9sbGluZykoZS5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdG9wUHJlc3NTdGFydCA9IHRyaWdnZXJQcmVzc1N0YXJ0KGUsIFwidmlydHVhbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdG9wUHJlc3NVcCA9IHRyaWdnZXJQcmVzc1VwKGUsIFwidmlydHVhbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdG9wUHJlc3NFbmQgPSB0cmlnZ2VyUHJlc3NFbmQoZSwgXCJ2aXJ0dWFsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gc3RvcFByZXNzU3RhcnQgJiYgc3RvcFByZXNzVXAgJiYgc3RvcFByZXNzRW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaWdub3JlQ2xpY2tBZnRlclByZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgb25LZXlVcCA9IChlKT0+e1xuICAgICAgICAgICAgdmFyIF9zdGF0ZV9tZXRhS2V5RXZlbnRzO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmlzUHJlc3NlZCAmJiBzdGF0ZS50YXJnZXQgJiYgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzVmFsaWRLZXlib2FyZEV2ZW50KGUsIHN0YXRlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3N0YXRlX21ldGFLZXlFdmVudHMxO1xuICAgICAgICAgICAgICAgIGlmICgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkc2hvdWxkUHJldmVudERlZmF1bHRLZXlib2FyZChlLnRhcmdldCwgZS5rZXkpKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGxldCBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cmlnZ2VyUHJlc3NFbmQoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGNyZWF0ZUV2ZW50KHN0YXRlLnRhcmdldCwgZSksIFwia2V5Ym9hcmRcIiwgc3RhdGUudGFyZ2V0LmNvbnRhaW5zKHRhcmdldCkpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBsaW5rIHdhcyB0cmlnZ2VyZWQgd2l0aCBhIGtleSBvdGhlciB0aGFuIEVudGVyLCBvcGVuIHRoZSBVUkwgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhlIGxpbmsgaGFzIGEgcm9sZSBvdmVycmlkZSwgYW5kIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGFwcGxpZXMgd2hlbiB1c2luZyB0aGUgRW50ZXIga2V5LlxuICAgICAgICAgICAgICAgIGlmIChlLmtleSAhPT0gXCJFbnRlclwiICYmICRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc0hUTUxBbmNob3JMaW5rKHN0YXRlLnRhcmdldCkgJiYgc3RhdGUudGFyZ2V0LmNvbnRhaW5zKHRhcmdldCkgJiYgIWVbJGY2YzMxY2NlMmFkZjY1NGYkdmFyJExJTktfQ0xJQ0tFRF0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgYSBoaWRkZW4gcHJvcGVydHkgb24gdGhlIGV2ZW50IHNvIHdlIG9ubHkgdHJpZ2dlciBsaW5rIGNsaWNrIG9uY2UsXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgdGhlcmUgYXJlIG11bHRpcGxlIHVzZVByZXNzIGluc3RhbmNlcyBhdHRhY2hlZCB0byB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgZVskZjZjMzFjY2UyYWRmNjU0ZiR2YXIkTElOS19DTElDS0VEXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICgwLCAkYng3U0wkb3BlbkxpbmspKHN0YXRlLnRhcmdldCwgZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS5pc1ByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAoX3N0YXRlX21ldGFLZXlFdmVudHMxID0gc3RhdGUubWV0YUtleUV2ZW50cykgPT09IG51bGwgfHwgX3N0YXRlX21ldGFLZXlFdmVudHMxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVfbWV0YUtleUV2ZW50czEuZGVsZXRlKGUua2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09IFwiTWV0YVwiICYmICgoX3N0YXRlX21ldGFLZXlFdmVudHMgPSBzdGF0ZS5tZXRhS2V5RXZlbnRzKSA9PT0gbnVsbCB8fCBfc3RhdGVfbWV0YUtleUV2ZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlX21ldGFLZXlFdmVudHMuc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3N0YXRlX3RhcmdldDtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWNvcmRlZCBrZXlkb3duIGV2ZW50cyB0aGF0IG9jY3VycmVkIHdoaWxlIHRoZSBNZXRhIGtleSB3YXMgcHJlc3NlZCxcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhvc2UgaGF2ZW4ndCByZWNlaXZlZCBrZXl1cCBldmVudHMgYWxyZWFkeSwgZmlyZSBrZXl1cCBldmVudHMgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlIGZvciBtb3JlIGluZm8gYWJvdXQgdGhlIG1hY09TIGJ1ZyBjYXVzaW5nIHRoaXMuXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50cyA9IHN0YXRlLm1ldGFLZXlFdmVudHM7XG4gICAgICAgICAgICAgICAgc3RhdGUubWV0YUtleUV2ZW50cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBldmVudCBvZiBldmVudHMudmFsdWVzKCkpKF9zdGF0ZV90YXJnZXQgPSBzdGF0ZS50YXJnZXQpID09PSBudWxsIHx8IF9zdGF0ZV90YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZV90YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgS2V5Ym9hcmRFdmVudChcImtleXVwXCIsIGV2ZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgUG9pbnRlckV2ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBwcmVzc1Byb3BzLm9uUG9pbnRlckRvd24gPSAoZSk9PntcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGhhbmRsZSBsZWZ0IGNsaWNrcywgYW5kIGlnbm9yZSBldmVudHMgdGhhdCBidWJibGVkIHRocm91Z2ggcG9ydGFscy5cbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gIT09IDAgfHwgIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBpT1Mgc2FmYXJpIGZpcmVzIHBvaW50ZXIgZXZlbnRzIGZyb20gVm9pY2VPdmVyIHdpdGggaW5jb3JyZWN0IGNvb3JkaW5hdGVzL3RhcmdldC5cbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYW5kIGxldCB0aGUgb25DbGljayBoYW5kbGVyIHRha2UgY2FyZSBvZiBpdCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMjI2MjdcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjIzMjAyXG4gICAgICAgICAgICAgICAgaWYgKCgwLCAkYng3U0wkaXNWaXJ0dWFsUG9pbnRlckV2ZW50KShlLm5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wb2ludGVyVHlwZSA9IFwidmlydHVhbFwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIER1ZSB0byBicm93c2VyIGluY29uc2lzdGVuY2llcywgZXNwZWNpYWxseSBvbiBtb2JpbGUgYnJvd3NlcnMsIHdlIHByZXZlbnRcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IG9uIHBvaW50ZXIgZG93biBhbmQgaGFuZGxlIGZvY3VzaW5nIHRoZSBwcmVzc2FibGUgZWxlbWVudCBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgaWYgKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRzaG91bGRQcmV2ZW50RGVmYXVsdChlLmN1cnJlbnRUYXJnZXQpKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlclR5cGUgPSBlLnBvaW50ZXJUeXBlO1xuICAgICAgICAgICAgICAgIGxldCBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaXNQcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzUHJlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVBvaW50ZXJJZCA9IGUucG9pbnRlcklkO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS50YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNEaXNhYmxlZCAmJiAhcHJldmVudEZvY3VzT25QcmVzcykgKDAsICRieDdTTCRmb2N1c1dpdGhvdXRTY3JvbGxpbmcpKGUuY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzcykgKDAsICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCQxNmE0Njk3NDY3MTc1NDg3KShzdGF0ZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cmlnZ2VyUHJlc3NTdGFydChlLCBzdGF0ZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKCgwLCAkYng3U0wkZ2V0T3duZXJEb2N1bWVudCkoZS5jdXJyZW50VGFyZ2V0KSwgXCJwb2ludGVybW92ZVwiLCBvblBvaW50ZXJNb3ZlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKCgwLCAkYng3U0wkZ2V0T3duZXJEb2N1bWVudCkoZS5jdXJyZW50VGFyZ2V0KSwgXCJwb2ludGVydXBcIiwgb25Qb2ludGVyVXAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIoKDAsICRieDdTTCRnZXRPd25lckRvY3VtZW50KShlLmN1cnJlbnRUYXJnZXQpLCBcInBvaW50ZXJjYW5jZWxcIiwgb25Qb2ludGVyQ2FuY2VsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vbk1vdXNlRG93biA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWUgYW5kIEZpcmVmb3ggb24gdG91Y2ggV2luZG93cyBkZXZpY2VzIHJlcXVpcmUgbW91c2UgZG93biBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYmUgY2FuY2VsZWQgaW4gYWRkaXRpb24gdG8gcG9pbnRlciBldmVudHMsIG9yIGFuIGV4dHJhIGFzeW5jaHJvbm91c1xuICAgICAgICAgICAgICAgICAgICAvLyBmb2N1cyBldmVudCB3aWxsIGJlIGZpcmVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHNob3VsZFByZXZlbnREZWZhdWx0KGUuY3VycmVudFRhcmdldCkpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vblBvaW50ZXJVcCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIC8vIGlPUyBmaXJlcyBwb2ludGVydXAgd2l0aCB6ZXJvIHdpZHRoIGFuZCBoZWlnaHQsIHNvIGNoZWNrIHRoZSBwb2ludGVyVHlwZSByZWNvcmRlZCBkdXJpbmcgcG9pbnRlcmRvd24uXG4gICAgICAgICAgICAgICAgaWYgKCFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpIHx8IHN0YXRlLnBvaW50ZXJUeXBlID09PSBcInZpcnR1YWxcIikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgaGFuZGxlIGxlZnQgY2xpY2tzXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIG9uIGlPUyBzb21ldGltZXMgZmlyZXMgcG9pbnRlcnVwIGV2ZW50cywgZXZlblxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIHRvdWNoIGlzbid0IG92ZXIgdGhlIHRhcmdldCwgc28gZG91YmxlIGNoZWNrLlxuICAgICAgICAgICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCAmJiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNPdmVyVGFyZ2V0KGUsIGUuY3VycmVudFRhcmdldCkpIHRyaWdnZXJQcmVzc1VwKGUsIHN0YXRlLnBvaW50ZXJUeXBlIHx8IGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFNhZmFyaSBvbiBpT1MgPCAxMy4yIGRvZXMgbm90IGltcGxlbWVudCBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGV2ZW50cyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAvLyBVc2UgcG9pbnRlciBtb3ZlIGV2ZW50cyBpbnN0ZWFkIHRvIGltcGxlbWVudCBvdXIgb3duIGhpdCB0ZXN0aW5nLlxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xOTk4MDNcbiAgICAgICAgICAgIGxldCBvblBvaW50ZXJNb3ZlID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGUucG9pbnRlcklkICE9PSBzdGF0ZS5hY3RpdmVQb2ludGVySWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUudGFyZ2V0ICYmICRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc092ZXJUYXJnZXQoZSwgc3RhdGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlzT3ZlclRhcmdldCAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlclByZXNzU3RhcnQoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGNyZWF0ZUV2ZW50KHN0YXRlLnRhcmdldCwgZSksIHN0YXRlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUudGFyZ2V0ICYmIHN0YXRlLmlzT3ZlclRhcmdldCAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyUHJlc3NFbmQoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGNyZWF0ZUV2ZW50KHN0YXRlLnRhcmdldCwgZSksIHN0YXRlLnBvaW50ZXJUeXBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbE9uUG9pbnRlckV4aXQoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBvblBvaW50ZXJVcCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlLnBvaW50ZXJJZCA9PT0gc3RhdGUuYWN0aXZlUG9pbnRlcklkICYmIHN0YXRlLmlzUHJlc3NlZCAmJiBlLmJ1dHRvbiA9PT0gMCAmJiBzdGF0ZS50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc092ZXJUYXJnZXQoZSwgc3RhdGUudGFyZ2V0KSAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSB0cmlnZ2VyUHJlc3NFbmQoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGNyZWF0ZUV2ZW50KHN0YXRlLnRhcmdldCwgZSksIHN0YXRlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUuaXNPdmVyVGFyZ2V0ICYmIHN0YXRlLnBvaW50ZXJUeXBlICE9IG51bGwpIHRyaWdnZXJQcmVzc0VuZCgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkY3JlYXRlRXZlbnQoc3RhdGUudGFyZ2V0LCBlKSwgc3RhdGUucG9pbnRlclR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVQb2ludGVySWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wb2ludGVyVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93VGV4dFNlbGVjdGlvbk9uUHJlc3MpICgwLCAkMTRjMGI3MjUwOWQ3MDIyNSRleHBvcnQkYjBkNmZhMWFiMzJlMzI5NSkoc3RhdGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IG9uUG9pbnRlckNhbmNlbCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGNhbmNlbChlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmVzc1Byb3BzLm9uRHJhZ1N0YXJ0ID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIGRvZXMgbm90IGNhbGwgb25Qb2ludGVyQ2FuY2VsIHdoZW4gYSBkcmFnIHN0YXJ0cywgd2hlcmVhcyBDaHJvbWUgYW5kIEZpcmVmb3ggZG8uXG4gICAgICAgICAgICAgICAgY2FuY2VsKGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25Nb3VzZURvd24gPSAoZSk9PntcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGhhbmRsZSBsZWZ0IGNsaWNrc1xuICAgICAgICAgICAgICAgIGlmIChlLmJ1dHRvbiAhPT0gMCB8fCAhZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIER1ZSB0byBicm93c2VyIGluY29uc2lzdGVuY2llcywgZXNwZWNpYWxseSBvbiBtb2JpbGUgYnJvd3NlcnMsIHdlIHByZXZlbnRcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IG9uIG1vdXNlIGRvd24gYW5kIGhhbmRsZSBmb2N1c2luZyB0aGUgcHJlc3NhYmxlIGVsZW1lbnQgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgIGlmICgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkc2hvdWxkUHJldmVudERlZmF1bHQoZS5jdXJyZW50VGFyZ2V0KSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNQcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlLnRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wb2ludGVyVHlwZSA9ICgwLCAkYng3U0wkaXNWaXJ0dWFsQ2xpY2spKGUubmF0aXZlRXZlbnQpID8gXCJ2aXJ0dWFsXCIgOiBcIm1vdXNlXCI7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Rpc2FibGVkICYmICFwcmV2ZW50Rm9jdXNPblByZXNzKSAoMCwgJGJ4N1NMJGZvY3VzV2l0aG91dFNjcm9sbGluZykoZS5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJpZ2dlclByZXNzU3RhcnQoZSwgc3RhdGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIoKDAsICRieDdTTCRnZXRPd25lckRvY3VtZW50KShlLmN1cnJlbnRUYXJnZXQpLCBcIm1vdXNldXBcIiwgb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vbk1vdXNlRW50ZXIgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaXNQcmVzc2VkICYmICFzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzICYmIHN0YXRlLnBvaW50ZXJUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNPdmVyVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJpZ2dlclByZXNzU3RhcnQoZSwgc3RhdGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25Nb3VzZUxlYXZlID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzUHJlc3NlZCAmJiAhc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cmlnZ2VyUHJlc3NFbmQoZSwgc3RhdGUucG9pbnRlclR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsT25Qb2ludGVyRXhpdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmVzc1Byb3BzLm9uTW91c2VVcCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyAmJiBlLmJ1dHRvbiA9PT0gMCkgdHJpZ2dlclByZXNzVXAoZSwgc3RhdGUucG9pbnRlclR5cGUgfHwgXCJtb3VzZVwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgb25Nb3VzZVVwID0gKGUpPT57XG4gICAgICAgICAgICAgICAgLy8gT25seSBoYW5kbGUgbGVmdCBjbGlja3NcbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gIT09IDApIHJldHVybjtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc1ByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnRhcmdldCAmJiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNPdmVyVGFyZ2V0KGUsIHN0YXRlLnRhcmdldCkgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkgdHJpZ2dlclByZXNzRW5kKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudChzdGF0ZS50YXJnZXQsIGUpLCBzdGF0ZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUudGFyZ2V0ICYmIHN0YXRlLmlzT3ZlclRhcmdldCAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSB0cmlnZ2VyUHJlc3NFbmQoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGNyZWF0ZUV2ZW50KHN0YXRlLnRhcmdldCwgZSksIHN0YXRlLnBvaW50ZXJUeXBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNPdmVyVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vblRvdWNoU3RhcnQgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBsZXQgdG91Y2ggPSAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkZ2V0VG91Y2hGcm9tRXZlbnQoZS5uYXRpdmVFdmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0b3VjaCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVBvaW50ZXJJZCA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgICAgICAgICAgICAgc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNPdmVyVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc1ByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlLnRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wb2ludGVyVHlwZSA9IFwidG91Y2hcIjtcbiAgICAgICAgICAgICAgICAvLyBEdWUgdG8gYnJvd3NlciBpbmNvbnNpc3RlbmNpZXMsIGVzcGVjaWFsbHkgb24gbW9iaWxlIGJyb3dzZXJzLCB3ZSBwcmV2ZW50IGRlZmF1bHRcbiAgICAgICAgICAgICAgICAvLyBvbiB0aGUgZW11bGF0ZWQgbW91c2UgZXZlbnQgYW5kIGhhbmRsZSBmb2N1c2luZyB0aGUgcHJlc3NhYmxlIGVsZW1lbnQgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgIGlmICghaXNEaXNhYmxlZCAmJiAhcHJldmVudEZvY3VzT25QcmVzcykgKDAsICRieDdTTCRmb2N1c1dpdGhvdXRTY3JvbGxpbmcpKGUuY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxvd1RleHRTZWxlY3Rpb25PblByZXNzKSAoMCwgJDE0YzBiNzI1MDlkNzAyMjUkZXhwb3J0JDE2YTQ2OTc0NjcxNzU0ODcpKHN0YXRlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgbGV0IHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRyaWdnZXJQcmVzc1N0YXJ0KGUsIHN0YXRlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKCgwLCAkYng3U0wkZ2V0T3duZXJXaW5kb3cpKGUuY3VycmVudFRhcmdldCksIFwic2Nyb2xsXCIsIG9uU2Nyb2xsLCB0cnVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmVzc1Byb3BzLm9uVG91Y2hNb3ZlID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc1ByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdG91Y2ggPSAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkZ2V0VG91Y2hCeUlkKGUubmF0aXZlRXZlbnQsIHN0YXRlLmFjdGl2ZVBvaW50ZXJJZCk7XG4gICAgICAgICAgICAgICAgbGV0IHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvdWNoICYmICRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc092ZXJUYXJnZXQodG91Y2gsIGUuY3VycmVudFRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc092ZXJUYXJnZXQgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNPdmVyVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRyaWdnZXJQcmVzc1N0YXJ0KGUsIHN0YXRlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuaXNPdmVyVGFyZ2V0ICYmIHN0YXRlLnBvaW50ZXJUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNPdmVyVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRyaWdnZXJQcmVzc0VuZChlLCBzdGF0ZS5wb2ludGVyVHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxPblBvaW50ZXJFeGl0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25Ub3VjaEVuZCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaXNQcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHRvdWNoID0gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGdldFRvdWNoQnlJZChlLm5hdGl2ZUV2ZW50LCBzdGF0ZS5hY3RpdmVQb2ludGVySWQpO1xuICAgICAgICAgICAgICAgIGxldCBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0b3VjaCAmJiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNPdmVyVGFyZ2V0KHRvdWNoLCBlLmN1cnJlbnRUYXJnZXQpICYmIHN0YXRlLnBvaW50ZXJUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlclByZXNzVXAoZSwgc3RhdGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cmlnZ2VyUHJlc3NFbmQoZSwgc3RhdGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuaXNPdmVyVGFyZ2V0ICYmIHN0YXRlLnBvaW50ZXJUeXBlICE9IG51bGwpIHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRyaWdnZXJQcmVzc0VuZChlLCBzdGF0ZS5wb2ludGVyVHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlUG9pbnRlcklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUudGFyZ2V0ICYmICFhbGxvd1RleHRTZWxlY3Rpb25PblByZXNzKSAoMCwgJDE0YzBiNzI1MDlkNzAyMjUkZXhwb3J0JGIwZDZmYTFhYjMyZTMyOTUpKHN0YXRlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vblRvdWNoQ2FuY2VsID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaXNQcmVzc2VkKSBjYW5jZWwoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IG9uU2Nyb2xsID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzUHJlc3NlZCAmJiBlLnRhcmdldC5jb250YWlucyhzdGF0ZS50YXJnZXQpKSBjYW5jZWwoe1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBzdGF0ZS50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY3RybEtleTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFLZXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbHRLZXk6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vbkRyYWdTdGFydCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhbmNlbChlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXNzUHJvcHM7XG4gICAgfSwgW1xuICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcixcbiAgICAgICAgaXNEaXNhYmxlZCxcbiAgICAgICAgcHJldmVudEZvY3VzT25QcmVzcyxcbiAgICAgICAgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzLFxuICAgICAgICBhbGxvd1RleHRTZWxlY3Rpb25PblByZXNzLFxuICAgICAgICBjYW5jZWwsXG4gICAgICAgIGNhbmNlbE9uUG9pbnRlckV4aXQsXG4gICAgICAgIHRyaWdnZXJQcmVzc0VuZCxcbiAgICAgICAgdHJpZ2dlclByZXNzU3RhcnQsXG4gICAgICAgIHRyaWdnZXJQcmVzc1VwXG4gICAgXSk7XG4gICAgLy8gUmVtb3ZlIHVzZXItc2VsZWN0OiBub25lIGluIGNhc2UgY29tcG9uZW50IHVubW91bnRzIGltbWVkaWF0ZWx5IGFmdGVyIHByZXNzU3RhcnRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyb3ctYm9keS1zdHlsZVxuICAgICgwLCAkYng3U0wkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHZhciBfcmVmX2N1cnJlbnRfdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKCFhbGxvd1RleHRTZWxlY3Rpb25PblByZXNzKSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgICAgICAoMCwgJDE0YzBiNzI1MDlkNzAyMjUkZXhwb3J0JGIwZDZmYTFhYjMyZTMyOTUpKChfcmVmX2N1cnJlbnRfdGFyZ2V0ID0gcmVmLmN1cnJlbnQudGFyZ2V0KSAhPT0gbnVsbCAmJiBfcmVmX2N1cnJlbnRfdGFyZ2V0ICE9PSB2b2lkIDAgPyBfcmVmX2N1cnJlbnRfdGFyZ2V0IDogdW5kZWZpbmVkKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGFsbG93VGV4dFNlbGVjdGlvbk9uUHJlc3NcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc1ByZXNzZWQ6IGlzUHJlc3NlZFByb3AgfHwgaXNQcmVzc2VkLFxuICAgICAgICBwcmVzc1Byb3BzOiAoMCwgJGJ4N1NMJG1lcmdlUHJvcHMpKGRvbVByb3BzLCBwcmVzc1Byb3BzKVxuICAgIH07XG59XG5mdW5jdGlvbiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNIVE1MQW5jaG9yTGluayh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0LnRhZ05hbWUgPT09IFwiQVwiICYmIHRhcmdldC5oYXNBdHRyaWJ1dGUoXCJocmVmXCIpO1xufVxuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzVmFsaWRLZXlib2FyZEV2ZW50KGV2ZW50LCBjdXJyZW50VGFyZ2V0KSB7XG4gICAgY29uc3QgeyBrZXk6IGtleSwgY29kZTogY29kZSB9ID0gZXZlbnQ7XG4gICAgY29uc3QgZWxlbWVudCA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgY29uc3Qgcm9sZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKTtcbiAgICAvLyBBY2Nlc3NpYmlsaXR5IGZvciBrZXlib2FyZHMuIFNwYWNlIGFuZCBFbnRlciBvbmx5LlxuICAgIC8vIFwiU3BhY2ViYXJcIiBpcyBmb3IgSUUgMTFcbiAgICByZXR1cm4gKGtleSA9PT0gXCJFbnRlclwiIHx8IGtleSA9PT0gXCIgXCIgfHwga2V5ID09PSBcIlNwYWNlYmFyXCIgfHwgY29kZSA9PT0gXCJTcGFjZVwiKSAmJiAhKGVsZW1lbnQgaW5zdGFuY2VvZiAoMCwgJGJ4N1NMJGdldE93bmVyV2luZG93KShlbGVtZW50KS5IVE1MSW5wdXRFbGVtZW50ICYmICEkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNWYWxpZElucHV0S2V5KGVsZW1lbnQsIGtleSkgfHwgZWxlbWVudCBpbnN0YW5jZW9mICgwLCAkYng3U0wkZ2V0T3duZXJXaW5kb3cpKGVsZW1lbnQpLkhUTUxUZXh0QXJlYUVsZW1lbnQgfHwgZWxlbWVudC5pc0NvbnRlbnRFZGl0YWJsZSkgJiYgLy8gTGlua3Mgc2hvdWxkIG9ubHkgdHJpZ2dlciB3aXRoIEVudGVyIGtleVxuICAgICEoKHJvbGUgPT09IFwibGlua1wiIHx8ICFyb2xlICYmICRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc0hUTUxBbmNob3JMaW5rKGVsZW1lbnQpKSAmJiBrZXkgIT09IFwiRW50ZXJcIik7XG59XG5mdW5jdGlvbiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkZ2V0VG91Y2hGcm9tRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCB7IHRhcmdldFRvdWNoZXM6IHRhcmdldFRvdWNoZXMgfSA9IGV2ZW50O1xuICAgIGlmICh0YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDApIHJldHVybiB0YXJnZXRUb3VjaGVzWzBdO1xuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGdldFRvdWNoQnlJZChldmVudCwgcG9pbnRlcklkKSB7XG4gICAgY29uc3QgY2hhbmdlZFRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcztcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCB0b3VjaCA9IGNoYW5nZWRUb3VjaGVzW2ldO1xuICAgICAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gcG9pbnRlcklkKSByZXR1cm4gdG91Y2g7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGNyZWF0ZUV2ZW50KHRhcmdldCwgZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGN1cnJlbnRUYXJnZXQ6IHRhcmdldCxcbiAgICAgICAgc2hpZnRLZXk6IGUuc2hpZnRLZXksXG4gICAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcbiAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxuICAgICAgICBhbHRLZXk6IGUuYWx0S2V5XG4gICAgfTtcbn1cbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJHZhciRnZXRQb2ludENsaWVudFJlY3QocG9pbnQpIHtcbiAgICBsZXQgb2Zmc2V0WCA9IDA7XG4gICAgbGV0IG9mZnNldFkgPSAwO1xuICAgIGlmIChwb2ludC53aWR0aCAhPT0gdW5kZWZpbmVkKSBvZmZzZXRYID0gcG9pbnQud2lkdGggLyAyO1xuICAgIGVsc2UgaWYgKHBvaW50LnJhZGl1c1ggIT09IHVuZGVmaW5lZCkgb2Zmc2V0WCA9IHBvaW50LnJhZGl1c1g7XG4gICAgaWYgKHBvaW50LmhlaWdodCAhPT0gdW5kZWZpbmVkKSBvZmZzZXRZID0gcG9pbnQuaGVpZ2h0IC8gMjtcbiAgICBlbHNlIGlmIChwb2ludC5yYWRpdXNZICE9PSB1bmRlZmluZWQpIG9mZnNldFkgPSBwb2ludC5yYWRpdXNZO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogcG9pbnQuY2xpZW50WSAtIG9mZnNldFksXG4gICAgICAgIHJpZ2h0OiBwb2ludC5jbGllbnRYICsgb2Zmc2V0WCxcbiAgICAgICAgYm90dG9tOiBwb2ludC5jbGllbnRZICsgb2Zmc2V0WSxcbiAgICAgICAgbGVmdDogcG9pbnQuY2xpZW50WCAtIG9mZnNldFhcbiAgICB9O1xufVxuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGFyZVJlY3RhbmdsZXNPdmVybGFwcGluZyhhLCBiKSB7XG4gICAgLy8gY2hlY2sgaWYgdGhleSBjYW5ub3Qgb3ZlcmxhcCBvbiB4IGF4aXNcbiAgICBpZiAoYS5sZWZ0ID4gYi5yaWdodCB8fCBiLmxlZnQgPiBhLnJpZ2h0KSByZXR1cm4gZmFsc2U7XG4gICAgLy8gY2hlY2sgaWYgdGhleSBjYW5ub3Qgb3ZlcmxhcCBvbiB5IGF4aXNcbiAgICBpZiAoYS50b3AgPiBiLmJvdHRvbSB8fCBiLnRvcCA+IGEuYm90dG9tKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNPdmVyVGFyZ2V0KHBvaW50LCB0YXJnZXQpIHtcbiAgICBsZXQgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgcG9pbnRSZWN0ID0gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGdldFBvaW50Q2xpZW50UmVjdChwb2ludCk7XG4gICAgcmV0dXJuICRmNmMzMWNjZTJhZGY2NTRmJHZhciRhcmVSZWN0YW5nbGVzT3ZlcmxhcHBpbmcocmVjdCwgcG9pbnRSZWN0KTtcbn1cbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJHZhciRzaG91bGRQcmV2ZW50RGVmYXVsdCh0YXJnZXQpIHtcbiAgICAvLyBXZSBjYW5ub3QgcHJldmVudCBkZWZhdWx0IGlmIHRoZSB0YXJnZXQgaXMgYSBkcmFnZ2FibGUgZWxlbWVudC5cbiAgICByZXR1cm4gISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgfHwgIXRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIik7XG59XG5mdW5jdGlvbiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkc2hvdWxkUHJldmVudERlZmF1bHRLZXlib2FyZCh0YXJnZXQsIGtleSkge1xuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSByZXR1cm4gISRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc1ZhbGlkSW5wdXRLZXkodGFyZ2V0LCBrZXkpO1xuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCkgcmV0dXJuIHRhcmdldC50eXBlICE9PSBcInN1Ym1pdFwiICYmIHRhcmdldC50eXBlICE9PSBcInJlc2V0XCI7XG4gICAgaWYgKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc0hUTUxBbmNob3JMaW5rKHRhcmdldCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0ICRmNmMzMWNjZTJhZGY2NTRmJHZhciRub25UZXh0SW5wdXRUeXBlcyA9IG5ldyBTZXQoW1xuICAgIFwiY2hlY2tib3hcIixcbiAgICBcInJhZGlvXCIsXG4gICAgXCJyYW5nZVwiLFxuICAgIFwiY29sb3JcIixcbiAgICBcImZpbGVcIixcbiAgICBcImltYWdlXCIsXG4gICAgXCJidXR0b25cIixcbiAgICBcInN1Ym1pdFwiLFxuICAgIFwicmVzZXRcIlxuXSk7XG5mdW5jdGlvbiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNWYWxpZElucHV0S2V5KHRhcmdldCwga2V5KSB7XG4gICAgLy8gT25seSBzcGFjZSBzaG91bGQgdG9nZ2xlIGNoZWNrYm94ZXMgYW5kIHJhZGlvcywgbm90IGVudGVyLlxuICAgIHJldHVybiB0YXJnZXQudHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IHRhcmdldC50eXBlID09PSBcInJhZGlvXCIgPyBrZXkgPT09IFwiIFwiIDogJGY2YzMxY2NlMmFkZjY1NGYkdmFyJG5vblRleHRJbnB1dFR5cGVzLmhhcyh0YXJnZXQudHlwZSk7XG59XG5cblxuXG5jb25zdCAkM2IxMTdlNDNkYzBjYTk1ZCRleHBvcnQkMjdjNzAxZWQ5ZTQ0OWU5OSA9IC8qI19fUFVSRV9fKi8gKDAsICRieDdTTCRyZWFjdCkuZm9yd2FyZFJlZigoeyBjaGlsZHJlbjogY2hpbGRyZW4sIC4uLnByb3BzIH0sIHJlZik9PntcbiAgICByZWYgPSAoMCwgJGJ4N1NMJHVzZU9iamVjdFJlZikocmVmKTtcbiAgICBsZXQgeyBwcmVzc1Byb3BzOiBwcmVzc1Byb3BzIH0gPSAoMCwgJGY2YzMxY2NlMmFkZjY1NGYkZXhwb3J0JDQ1NzEyZWNlZGE2ZmFkMjEpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHJlZjogcmVmXG4gICAgfSk7XG4gICAgbGV0IGNoaWxkID0gKDAsICRieDdTTCRyZWFjdCkuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICRieDdTTCRyZWFjdCkuY2xvbmVFbGVtZW50KGNoaWxkLCAvLyBAdHMtaWdub3JlXG4gICAge1xuICAgICAgICByZWY6IHJlZixcbiAgICAgICAgLi4uKDAsICRieDdTTCRtZXJnZVByb3BzKShjaGlsZC5wcm9wcywgcHJlc3NQcm9wcylcbiAgICB9KTtcbn0pO1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5jb25zdCAkZjFhYjhjNzU0NzhjNmY3MyRleHBvcnQkMzM1MTg3MWVlNGIyODhiOCA9IC8qI19fUFVSRV9fKi8gKDAsICRieDdTTCRyZWFjdCkuZm9yd2FyZFJlZigoeyBjaGlsZHJlbjogY2hpbGRyZW4sIC4uLnByb3BzIH0sIHJlZik9PntcbiAgICBsZXQgaXNSZWdpc3RlcmVkID0gKDAsICRieDdTTCR1c2VSZWYpKGZhbHNlKTtcbiAgICBsZXQgcHJldkNvbnRleHQgPSAoMCwgJGJ4N1NMJHVzZUNvbnRleHQpKCgwLCAkYWUxZWViYThiOWVhZmQwOCRleHBvcnQkNTE2NWVjY2IzNWFhYWRiNSkpO1xuICAgIHJlZiA9ICgwLCAkYng3U0wkdXNlT2JqZWN0UmVmKShyZWYgfHwgKHByZXZDb250ZXh0ID09PSBudWxsIHx8IHByZXZDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2Q29udGV4dC5yZWYpKTtcbiAgICBsZXQgY29udGV4dCA9ICgwLCAkYng3U0wkbWVyZ2VQcm9wcykocHJldkNvbnRleHQgfHwge30sIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHJlZjogcmVmLFxuICAgICAgICByZWdpc3RlciAoKSB7XG4gICAgICAgICAgICBpc1JlZ2lzdGVyZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICBpZiAocHJldkNvbnRleHQpIHByZXZDb250ZXh0LnJlZ2lzdGVyKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAoMCwgJGJ4N1NMJHVzZVN5bmNSZWYpKHByZXZDb250ZXh0LCByZWYpO1xuICAgICgwLCAkYng3U0wkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoIWlzUmVnaXN0ZXJlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBIFByZXNzUmVzcG9uZGVyIHdhcyByZW5kZXJlZCB3aXRob3V0IGEgcHJlc3NhYmxlIGNoaWxkLiBFaXRoZXIgY2FsbCB0aGUgdXNlUHJlc3MgaG9vaywgb3Igd3JhcCB5b3VyIERPTSBub2RlIHdpdGggPFByZXNzYWJsZT4gY29tcG9uZW50LlwiKTtcbiAgICAgICAgICAgIGlzUmVnaXN0ZXJlZC5jdXJyZW50ID0gdHJ1ZTsgLy8gb25seSB3YXJuIG9uY2UgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICRieDdTTCRyZWFjdCkuY3JlYXRlRWxlbWVudCgoMCwgJGFlMWVlYmE4YjllYWZkMDgkZXhwb3J0JDUxNjVlY2NiMzVhYWFkYjUpLlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBjb250ZXh0XG4gICAgfSwgY2hpbGRyZW4pO1xufSk7XG5mdW5jdGlvbiAkZjFhYjhjNzU0NzhjNmY3MyRleHBvcnQkY2Y3NTQyOGUwYjllZDFlYSh7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB7XG4gICAgbGV0IGNvbnRleHQgPSAoMCwgJGJ4N1NMJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgcmVnaXN0ZXI6ICgpPT57fVxuICAgICAgICB9KSwgW10pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkYng3U0wkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoKDAsICRhZTFlZWJhOGI5ZWFmZDA4JGV4cG9ydCQ1MTY1ZWNjYjM1YWFhZGI1KS5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogY29udGV4dFxuICAgIH0sIGNoaWxkcmVuKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gcmVhY3QuXG4vLyBPcmlnaW5hbCBsaWNlbnNpbmcgZm9yIHRoZSBmb2xsb3dpbmcgY2FuIGJlIGZvdW5kIGluIHRoZVxuLy8gTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3RyZWUvY2M3YzFhZWNlNDZhNmI2OWI0MTk1OGQ3MzFlMGZkMjdjOTRiZmM2Yy9wYWNrYWdlcy9yZWFjdC1pbnRlcmFjdGlvbnNcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5jbGFzcyAkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkOTA1ZTdmYzU0NGE3MWYzNiB7XG4gICAgaXNEZWZhdWx0UHJldmVudGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkO1xuICAgIH1cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uYXRpdmVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIHRoaXMubmF0aXZlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSAoKT0+dHJ1ZTtcbiAgICB9XG4gICAgaXNQcm9wYWdhdGlvblN0b3BwZWQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcGVyc2lzdCgpIHt9XG4gICAgY29uc3RydWN0b3IodHlwZSwgbmF0aXZlRXZlbnQpe1xuICAgICAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0O1xuICAgICAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBuYXRpdmVFdmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICB0aGlzLnJlbGF0ZWRUYXJnZXQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICB0aGlzLmJ1YmJsZXMgPSBuYXRpdmVFdmVudC5idWJibGVzO1xuICAgICAgICB0aGlzLmNhbmNlbGFibGUgPSBuYXRpdmVFdmVudC5jYW5jZWxhYmxlO1xuICAgICAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkO1xuICAgICAgICB0aGlzLmV2ZW50UGhhc2UgPSBuYXRpdmVFdmVudC5ldmVudFBoYXNlO1xuICAgICAgICB0aGlzLmlzVHJ1c3RlZCA9IG5hdGl2ZUV2ZW50LmlzVHJ1c3RlZDtcbiAgICAgICAgdGhpcy50aW1lU3RhbXAgPSBuYXRpdmVFdmVudC50aW1lU3RhbXA7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxufVxuZnVuY3Rpb24gJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDcxNWM2ODJkMDlkNjM5Y2Mob25CbHVyKSB7XG4gICAgbGV0IHN0YXRlUmVmID0gKDAsICRieDdTTCR1c2VSZWYpKHtcbiAgICAgICAgaXNGb2N1c2VkOiBmYWxzZSxcbiAgICAgICAgb2JzZXJ2ZXI6IG51bGxcbiAgICB9KTtcbiAgICAvLyBDbGVhbiB1cCBNdXRhdGlvbk9ic2VydmVyIG9uIHVubW91bnQuIFNlZSBiZWxvdy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyb3ctYm9keS1zdHlsZVxuICAgICgwLCAkYng3U0wkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaWYgKHN0YXRlLm9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHN0YXRlLm9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgbGV0IGRpc3BhdGNoQmx1ciA9ICgwLCAkYng3U0wkdXNlRWZmZWN0RXZlbnQpKChlKT0+e1xuICAgICAgICBvbkJsdXIgPT09IG51bGwgfHwgb25CbHVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkJsdXIoZSk7XG4gICAgfSk7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZHVyaW5nIGEgUmVhY3Qgb25Gb2N1cyBldmVudC5cbiAgICByZXR1cm4gKDAsICRieDdTTCR1c2VDYWxsYmFjaykoKGUpPT57XG4gICAgICAgIC8vIFJlYWN0IGRvZXMgbm90IGZpcmUgb25CbHVyIHdoZW4gYW4gZWxlbWVudCBpcyBkaXNhYmxlZC4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy85MTQyXG4gICAgICAgIC8vIE1vc3QgYnJvd3NlcnMgZmlyZSBhIG5hdGl2ZSBmb2N1c291dCBldmVudCBpbiB0aGlzIGNhc2UsIGV4Y2VwdCBmb3IgRmlyZWZveC4gSW4gdGhhdCBjYXNlLCB3ZSB1c2UgYVxuICAgICAgICAvLyBNdXRhdGlvbk9ic2VydmVyIHRvIHdhdGNoIGZvciB0aGUgZGlzYWJsZWQgYXR0cmlidXRlLCBhbmQgZGlzcGF0Y2ggdGhlc2UgZXZlbnRzIG91cnNlbHZlcy5cbiAgICAgICAgLy8gRm9yIGJyb3dzZXJzIHRoYXQgZG8sIGZvY3Vzb3V0IGZpcmVzIGJlZm9yZSB0aGUgTXV0YXRpb25PYnNlcnZlciwgc28gb25CbHVyIHNob3VsZCBub3QgZmlyZSB0d2ljZS5cbiAgICAgICAgaWYgKGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQgfHwgZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8IGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTFRleHRBcmVhRWxlbWVudCB8fCBlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50KSB7XG4gICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50LmlzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICBsZXQgb25CbHVySGFuZGxlciA9IChlKT0+e1xuICAgICAgICAgICAgICAgIHN0YXRlUmVmLmN1cnJlbnQuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5kaXNhYmxlZCkgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIGRpc3BhdGNoIGEgKGZha2UpIFJlYWN0IHN5bnRoZXRpYyBldmVudC5cbiAgICAgICAgICAgICAgICBkaXNwYXRjaEJsdXIobmV3ICQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ5MDVlN2ZjNTQ0YTcxZjM2KFwiYmx1clwiLCBlKSk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugbm8gbG9uZ2VyIG5lZWQgdGhlIE11dGF0aW9uT2JzZXJ2ZXIgb25jZSB0aGUgdGFyZ2V0IGlzIGJsdXJyZWQuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlUmVmLmN1cnJlbnQub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVSZWYuY3VycmVudC5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlUmVmLmN1cnJlbnQub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIG9uQmx1ckhhbmRsZXIsIHtcbiAgICAgICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXRlUmVmLmN1cnJlbnQub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZVJlZi5jdXJyZW50LmlzRm9jdXNlZCAmJiB0YXJnZXQuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGF0ZVJlZl9jdXJyZW50X29ic2VydmVyO1xuICAgICAgICAgICAgICAgICAgICAoX3N0YXRlUmVmX2N1cnJlbnRfb2JzZXJ2ZXIgPSBzdGF0ZVJlZi5jdXJyZW50Lm9ic2VydmVyKSA9PT0gbnVsbCB8fCBfc3RhdGVSZWZfY3VycmVudF9vYnNlcnZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlUmVmX2N1cnJlbnRfb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVsYXRlZFRhcmdldEVsID0gdGFyZ2V0ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID8gbnVsbCA6IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBGb2N1c0V2ZW50KFwiYmx1clwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0RWxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRm9jdXNFdmVudChcImZvY3Vzb3V0XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0RWxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdGVSZWYuY3VycmVudC5vYnNlcnZlci5vYnNlcnZlKHRhcmdldCwge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBkaXNwYXRjaEJsdXJcbiAgICBdKTtcbn1cblxuXG5mdW5jdGlvbiAkYTFlYTU5ZDY4MjcwZjBkZCRleHBvcnQkZjgxNjhkOGRkOGZkNjZlNihwcm9wcykge1xuICAgIGxldCB7IGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsIG9uRm9jdXM6IG9uRm9jdXNQcm9wLCBvbkJsdXI6IG9uQmx1clByb3AsIG9uRm9jdXNDaGFuZ2U6IG9uRm9jdXNDaGFuZ2UgfSA9IHByb3BzO1xuICAgIGNvbnN0IG9uQmx1ciA9ICgwLCAkYng3U0wkdXNlQ2FsbGJhY2spKChlKT0+e1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgaWYgKG9uQmx1clByb3ApIG9uQmx1clByb3AoZSk7XG4gICAgICAgICAgICBpZiAob25Gb2N1c0NoYW5nZSkgb25Gb2N1c0NoYW5nZShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgb25CbHVyUHJvcCxcbiAgICAgICAgb25Gb2N1c0NoYW5nZVxuICAgIF0pO1xuICAgIGNvbnN0IG9uU3ludGhldGljRm9jdXMgPSAoMCwgJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDcxNWM2ODJkMDlkNjM5Y2MpKG9uQmx1cik7XG4gICAgY29uc3Qgb25Gb2N1cyA9ICgwLCAkYng3U0wkdXNlQ2FsbGJhY2spKChlKT0+e1xuICAgICAgICAvLyBEb3VibGUgY2hlY2sgdGhhdCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGFjdHVhbGx5IG1hdGNoZXMgZS50YXJnZXQgaW4gY2FzZSBhIHByZXZpb3VzbHkgY2hhaW5lZFxuICAgICAgICAvLyBmb2N1cyBoYW5kbGVyIGFscmVhZHkgbW92ZWQgZm9jdXMgc29tZXdoZXJlIGVsc2UuXG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGUudGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAob25Gb2N1c1Byb3ApIG9uRm9jdXNQcm9wKGUpO1xuICAgICAgICAgICAgaWYgKG9uRm9jdXNDaGFuZ2UpIG9uRm9jdXNDaGFuZ2UodHJ1ZSk7XG4gICAgICAgICAgICBvblN5bnRoZXRpY0ZvY3VzKGUpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBvbkZvY3VzQ2hhbmdlLFxuICAgICAgICBvbkZvY3VzUHJvcCxcbiAgICAgICAgb25TeW50aGV0aWNGb2N1c1xuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvY3VzUHJvcHM6IHtcbiAgICAgICAgICAgIG9uRm9jdXM6ICFpc0Rpc2FibGVkICYmIChvbkZvY3VzUHJvcCB8fCBvbkZvY3VzQ2hhbmdlIHx8IG9uQmx1clByb3ApID8gb25Gb2N1cyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9uQmx1cjogIWlzRGlzYWJsZWQgJiYgKG9uQmx1clByb3AgfHwgb25Gb2N1c0NoYW5nZSkgPyBvbkJsdXIgOiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIHJlYWN0LlxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGZvciB0aGUgZm9sbG93aW5nIGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC90cmVlL2NjN2MxYWVjZTQ2YTZiNjliNDE5NThkNzMxZTBmZDI3Yzk0YmZjNmMvcGFja2FnZXMvcmVhY3QtaW50ZXJhY3Rpb25zXG5cblxuXG5sZXQgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSA9IG51bGw7XG5sZXQgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGNoYW5nZUhhbmRsZXJzID0gbmV3IFNldCgpO1xubGV0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNTZXR1cEdsb2JhbExpc3RlbmVycyA9IGZhbHNlO1xubGV0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNFdmVudEJlZm9yZUZvY3VzID0gZmFsc2U7XG5sZXQgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0JsdXJyZWRXaW5kb3dSZWNlbnRseSA9IGZhbHNlO1xuLy8gT25seSBUYWIgb3IgRXNjIGtleXMgd2lsbCBtYWtlIGZvY3VzIHZpc2libGUgb24gdGV4dCBpbnB1dCBlbGVtZW50c1xuY29uc3QgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJEZPQ1VTX1ZJU0lCTEVfSU5QVVRfS0VZUyA9IHtcbiAgICBUYWI6IHRydWUsXG4gICAgRXNjYXBlOiB0cnVlXG59O1xuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHRyaWdnZXJDaGFuZ2VIYW5kbGVycyhtb2RhbGl0eSwgZSkge1xuICAgIGZvciAobGV0IGhhbmRsZXIgb2YgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGNoYW5nZUhhbmRsZXJzKWhhbmRsZXIobW9kYWxpdHksIGUpO1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIGEgS2V5Ym9hcmRFdmVudCBpcyB1bm1vZGlmaWVkIGFuZCBjb3VsZCBtYWtlIGtleWJvYXJkIGZvY3VzIHN0eWxlcyB2aXNpYmxlLlxuICovIGZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRpc1ZhbGlkS2V5KGUpIHtcbiAgICAvLyBDb250cm9sIGFuZCBTaGlmdCBrZXlzIHRyaWdnZXIgd2hlbiBuYXZpZ2F0aW5nIGJhY2sgdG8gdGhlIHRhYiB3aXRoIGtleWJvYXJkLlxuICAgIHJldHVybiAhKGUubWV0YUtleSB8fCAhKDAsICRieDdTTCRpc01hYykoKSAmJiBlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5rZXkgPT09IFwiQ29udHJvbFwiIHx8IGUua2V5ID09PSBcIlNoaWZ0XCIgfHwgZS5rZXkgPT09IFwiTWV0YVwiKTtcbn1cbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVLZXlib2FyZEV2ZW50KGUpIHtcbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyA9IHRydWU7XG4gICAgaWYgKCQ1MDdmYWJlMTBlNzFjNmZiJHZhciRpc1ZhbGlkS2V5KGUpKSB7XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkgPSBcImtleWJvYXJkXCI7XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0cmlnZ2VyQ2hhbmdlSGFuZGxlcnMoXCJrZXlib2FyZFwiLCBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50KGUpIHtcbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5ID0gXCJwb2ludGVyXCI7XG4gICAgaWYgKGUudHlwZSA9PT0gXCJtb3VzZWRvd25cIiB8fCBlLnR5cGUgPT09IFwicG9pbnRlcmRvd25cIikge1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyA9IHRydWU7XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0cmlnZ2VyQ2hhbmdlSGFuZGxlcnMoXCJwb2ludGVyXCIsIGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVDbGlja0V2ZW50KGUpIHtcbiAgICBpZiAoKDAsICRieDdTTCRpc1ZpcnR1YWxDbGljaykoZSkpIHtcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMgPSB0cnVlO1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5ID0gXCJ2aXJ0dWFsXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUZvY3VzRXZlbnQoZSkge1xuICAgIC8vIEZpcmVmb3ggZmlyZXMgdHdvIGV4dHJhIGZvY3VzIGV2ZW50cyB3aGVuIHRoZSB1c2VyIGZpcnN0IGNsaWNrcyBpbnRvIGFuIGlmcmFtZTpcbiAgICAvLyBmaXJzdCBvbiB0aGUgd2luZG93LCB0aGVuIG9uIHRoZSBkb2N1bWVudC4gV2UgaWdub3JlIHRoZXNlIGV2ZW50cyBzbyB0aGV5IGRvbid0XG4gICAgLy8gY2F1c2Uga2V5Ym9hcmQgZm9jdXMgcmluZ3MgdG8gYXBwZWFyLlxuICAgIGlmIChlLnRhcmdldCA9PT0gd2luZG93IHx8IGUudGFyZ2V0ID09PSBkb2N1bWVudCkgcmV0dXJuO1xuICAgIC8vIElmIGEgZm9jdXMgZXZlbnQgb2NjdXJzIHdpdGhvdXQgYSBwcmVjZWRpbmcga2V5Ym9hcmQgb3IgcG9pbnRlciBldmVudCwgc3dpdGNoIHRvIHZpcnR1YWwgbW9kYWxpdHkuXG4gICAgLy8gVGhpcyBvY2N1cnMsIGZvciBleGFtcGxlLCB3aGVuIG5hdmlnYXRpbmcgYSBmb3JtIHdpdGggdGhlIG5leHQvcHJldmlvdXMgYnV0dG9ucyBvbiBpT1MuXG4gICAgaWYgKCEkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyAmJiAhJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0JsdXJyZWRXaW5kb3dSZWNlbnRseSkge1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5ID0gXCJ2aXJ0dWFsXCI7XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0cmlnZ2VyQ2hhbmdlSGFuZGxlcnMoXCJ2aXJ0dWFsXCIsIGUpO1xuICAgIH1cbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyA9IGZhbHNlO1xuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNCbHVycmVkV2luZG93UmVjZW50bHkgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVXaW5kb3dCbHVyKCkge1xuICAgIC8vIFdoZW4gdGhlIHdpbmRvdyBpcyBibHVycmVkLCByZXNldCBzdGF0ZS4gVGhpcyBpcyBuZWNlc3Nhcnkgd2hlbiB0YWJiaW5nIG91dCBvZiB0aGUgd2luZG93LFxuICAgIC8vIGZvciBleGFtcGxlLCBzaW5jZSBhIHN1YnNlcXVlbnQgZm9jdXMgZXZlbnQgd29uJ3QgYmUgZmlyZWQuXG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMgPSBmYWxzZTtcbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzQmx1cnJlZFdpbmRvd1JlY2VudGx5ID0gdHJ1ZTtcbn1cbi8qKlxuICogU2V0dXAgZ2xvYmFsIGV2ZW50IGxpc3RlbmVycyB0byBjb250cm9sIHdoZW4ga2V5Ym9hcmQgZm9jdXMgc3R5bGUgc2hvdWxkIGJlIHZpc2libGUuXG4gKi8gZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHNldHVwR2xvYmFsRm9jdXNFdmVudHMoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc1NldHVwR2xvYmFsTGlzdGVuZXJzKSByZXR1cm47XG4gICAgLy8gUHJvZ3JhbW1hdGljIGZvY3VzKCkgY2FsbHMgc2hvdWxkbid0IGFmZmVjdCB0aGUgY3VycmVudCBpbnB1dCBtb2RhbGl0eS5cbiAgICAvLyBIb3dldmVyLCB3ZSBuZWVkIHRvIGRldGVjdCBvdGhlciBjYXNlcyB3aGVuIGEgZm9jdXMgZXZlbnQgb2NjdXJzIHdpdGhvdXRcbiAgICAvLyBhIHByZWNlZGluZyB1c2VyIGV2ZW50IChlLmcuIHNjcmVlbiByZWFkZXIgZm9jdXMpLiBPdmVycmlkaW5nIHRoZSBmb2N1c1xuICAgIC8vIG1ldGhvZCBvbiBIVE1MRWxlbWVudC5wcm90b3R5cGUgaXMgYSBiaXQgaGFja3ksIGJ1dCB3b3Jrcy5cbiAgICBsZXQgZm9jdXMgPSBIVE1MRWxlbWVudC5wcm90b3R5cGUuZm9jdXM7XG4gICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNFdmVudEJlZm9yZUZvY3VzID0gdHJ1ZTtcbiAgICAgICAgZm9jdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVLZXlib2FyZEV2ZW50LCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUtleWJvYXJkRXZlbnQsIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlQ2xpY2tFdmVudCwgdHJ1ZSk7XG4gICAgLy8gUmVnaXN0ZXIgZm9jdXMgZXZlbnRzIG9uIHRoZSB3aW5kb3cgc28gdGhleSBhcmUgc3VyZSB0byBoYXBwZW5cbiAgICAvLyBiZWZvcmUgUmVhY3QncyBldmVudCBsaXN0ZW5lcnMgKHJlZ2lzdGVyZWQgb24gdGhlIGRvY3VtZW50KS5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVGb2N1c0V2ZW50LCB0cnVlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVdpbmRvd0JsdXIsIGZhbHNlKTtcbiAgICBpZiAodHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVQb2ludGVyRXZlbnQsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVQb2ludGVyRXZlbnQsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCB0cnVlKTtcbiAgICB9XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc1NldHVwR2xvYmFsTGlzdGVuZXJzID0gdHJ1ZTtcbn1cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIpICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRzZXR1cEdsb2JhbEZvY3VzRXZlbnRzKCk7XG4gICAgZWxzZSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkc2V0dXBHbG9iYWxGb2N1c0V2ZW50cyk7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkYjliM2RmZGRhYjE3ZGIyNygpIHtcbiAgICByZXR1cm4gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSAhPT0gXCJwb2ludGVyXCI7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkNjMwZmY2NTNjNWFkYTZhOSgpIHtcbiAgICByZXR1cm4gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eTtcbn1cbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCQ4Mzk3ZGRmYzUwNGZkYjlhKG1vZGFsaXR5KSB7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSA9IG1vZGFsaXR5O1xuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0cmlnZ2VyQ2hhbmdlSGFuZGxlcnMobW9kYWxpdHksIG51bGwpO1xufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDk4ZTIwZWM5MmY2MTRjZmUoKSB7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHNldHVwR2xvYmFsRm9jdXNFdmVudHMoKTtcbiAgICBsZXQgW21vZGFsaXR5LCBzZXRNb2RhbGl0eV0gPSAoMCwgJGJ4N1NMJHVzZVN0YXRlKSgkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5KTtcbiAgICAoMCwgJGJ4N1NMJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgbGV0IGhhbmRsZXIgPSAoKT0+e1xuICAgICAgICAgICAgc2V0TW9kYWxpdHkoJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSk7XG4gICAgICAgIH07XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjaGFuZ2VIYW5kbGVycy5hZGQoaGFuZGxlcik7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGNoYW5nZUhhbmRsZXJzLmRlbGV0ZShoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuICgwLCAkYng3U0wkdXNlSXNTU1IpKCkgPyBudWxsIDogbW9kYWxpdHk7XG59XG5jb25zdCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkbm9uVGV4dElucHV0VHlwZXMgPSBuZXcgU2V0KFtcbiAgICBcImNoZWNrYm94XCIsXG4gICAgXCJyYWRpb1wiLFxuICAgIFwicmFuZ2VcIixcbiAgICBcImNvbG9yXCIsXG4gICAgXCJmaWxlXCIsXG4gICAgXCJpbWFnZVwiLFxuICAgIFwiYnV0dG9uXCIsXG4gICAgXCJzdWJtaXRcIixcbiAgICBcInJlc2V0XCJcbl0pO1xuLyoqXG4gKiBJZiB0aGlzIGlzIGF0dGFjaGVkIHRvIHRleHQgaW5wdXQgY29tcG9uZW50LCByZXR1cm4gaWYgdGhlIGV2ZW50IGlzIGEgZm9jdXMgZXZlbnQgKFRhYi9Fc2NhcGUga2V5cyBwcmVzc2VkKSBzbyB0aGF0XG4gKiBmb2N1cyB2aXNpYmxlIHN0eWxlIGNhbiBiZSBwcm9wZXJseSBzZXQuXG4gKi8gZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGlzS2V5Ym9hcmRGb2N1c0V2ZW50KGlzVGV4dElucHV0LCBtb2RhbGl0eSwgZSkge1xuICAgIHZhciBfZV90YXJnZXQ7XG4gICAgaXNUZXh0SW5wdXQgPSBpc1RleHRJbnB1dCB8fCAoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnRhcmdldCkgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmICEkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkbm9uVGV4dElucHV0VHlwZXMuaGFzKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9lX3RhcmdldCA9IGUudGFyZ2V0KSA9PT0gbnVsbCB8fCBfZV90YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lX3RhcmdldC50eXBlKSB8fCAoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnRhcmdldCkgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50IHx8IChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUudGFyZ2V0KSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUudGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlKTtcbiAgICByZXR1cm4gIShpc1RleHRJbnB1dCAmJiBtb2RhbGl0eSA9PT0gXCJrZXlib2FyZFwiICYmIGUgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50ICYmICEkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkRk9DVVNfVklTSUJMRV9JTlBVVF9LRVlTW2Uua2V5XSk7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZmZkOWU1MDIxYzFmYjJkNihwcm9wcyA9IHt9KSB7XG4gICAgbGV0IHsgaXNUZXh0SW5wdXQ6IGlzVGV4dElucHV0LCBhdXRvRm9jdXM6IGF1dG9Gb2N1cyB9ID0gcHJvcHM7XG4gICAgbGV0IFtpc0ZvY3VzVmlzaWJsZVN0YXRlLCBzZXRGb2N1c1Zpc2libGVdID0gKDAsICRieDdTTCR1c2VTdGF0ZSkoYXV0b0ZvY3VzIHx8ICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRiOWIzZGZkZGFiMTdkYjI3KCkpO1xuICAgICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRlYzcxYjRiODNhYzA4ZWMzKChpc0ZvY3VzVmlzaWJsZSk9PntcbiAgICAgICAgc2V0Rm9jdXNWaXNpYmxlKGlzRm9jdXNWaXNpYmxlKTtcbiAgICB9LCBbXG4gICAgICAgIGlzVGV4dElucHV0XG4gICAgXSwge1xuICAgICAgICBpc1RleHRJbnB1dDogaXNUZXh0SW5wdXRcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0ZvY3VzVmlzaWJsZTogaXNGb2N1c1Zpc2libGVTdGF0ZVxuICAgIH07XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZWM3MWI0YjgzYWMwOGVjMyhmbiwgZGVwcywgb3B0cykge1xuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRzZXR1cEdsb2JhbEZvY3VzRXZlbnRzKCk7XG4gICAgKDAsICRieDdTTCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCBoYW5kbGVyID0gKG1vZGFsaXR5LCBlKT0+e1xuICAgICAgICAgICAgaWYgKCEkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaXNLZXlib2FyZEZvY3VzRXZlbnQoISEob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmlzVGV4dElucHV0KSwgbW9kYWxpdHksIGUpKSByZXR1cm47XG4gICAgICAgICAgICBmbigkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkYjliM2RmZGRhYjE3ZGIyNygpKTtcbiAgICAgICAgfTtcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGNoYW5nZUhhbmRsZXJzLmFkZChoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY2hhbmdlSGFuZGxlcnMuZGVsZXRlKGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBkZXBzKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gcmVhY3QuXG4vLyBPcmlnaW5hbCBsaWNlbnNpbmcgZm9yIHRoZSBmb2xsb3dpbmcgY2FuIGJlIGZvdW5kIGluIHRoZVxuLy8gTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3RyZWUvY2M3YzFhZWNlNDZhNmI2OWI0MTk1OGQ3MzFlMGZkMjdjOTRiZmM2Yy9wYWNrYWdlcy9yZWFjdC1pbnRlcmFjdGlvbnNcblxuXG5mdW5jdGlvbiAkOWFiOTQyNjJiZDAwNDdjNyRleHBvcnQkNDIwZTY4MjczMTY1ZjRlYyhwcm9wcykge1xuICAgIGxldCB7IGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsIG9uQmx1cldpdGhpbjogb25CbHVyV2l0aGluLCBvbkZvY3VzV2l0aGluOiBvbkZvY3VzV2l0aGluLCBvbkZvY3VzV2l0aGluQ2hhbmdlOiBvbkZvY3VzV2l0aGluQ2hhbmdlIH0gPSBwcm9wcztcbiAgICBsZXQgc3RhdGUgPSAoMCwgJGJ4N1NMJHVzZVJlZikoe1xuICAgICAgICBpc0ZvY3VzV2l0aGluOiBmYWxzZVxuICAgIH0pO1xuICAgIGxldCBvbkJsdXIgPSAoMCwgJGJ4N1NMJHVzZUNhbGxiYWNrKSgoZSk9PntcbiAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIG9uQmx1cldpdGhpbiBhbmQgdGhlbiBpbW1lZGlhdGVseSBvbkZvY3VzV2l0aGluIGFnYWluXG4gICAgICAgIC8vIHdoZW4gbW92aW5nIGZvY3VzIGluc2lkZSB0aGUgZWxlbWVudC4gT25seSB0cmlnZ2VyIGlmIHRoZSBjdXJyZW50VGFyZ2V0IGRvZXNuJ3RcbiAgICAgICAgLy8gaW5jbHVkZSB0aGUgcmVsYXRlZFRhcmdldCAod2hlcmUgZm9jdXMgaXMgbW92aW5nKS5cbiAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnQuaXNGb2N1c1dpdGhpbiAmJiAhZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgICAgIHN0YXRlLmN1cnJlbnQuaXNGb2N1c1dpdGhpbiA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG9uQmx1cldpdGhpbikgb25CbHVyV2l0aGluKGUpO1xuICAgICAgICAgICAgaWYgKG9uRm9jdXNXaXRoaW5DaGFuZ2UpIG9uRm9jdXNXaXRoaW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBvbkJsdXJXaXRoaW4sXG4gICAgICAgIG9uRm9jdXNXaXRoaW5DaGFuZ2UsXG4gICAgICAgIHN0YXRlXG4gICAgXSk7XG4gICAgbGV0IG9uU3ludGhldGljRm9jdXMgPSAoMCwgJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDcxNWM2ODJkMDlkNjM5Y2MpKG9uQmx1cik7XG4gICAgbGV0IG9uRm9jdXMgPSAoMCwgJGJ4N1NMJHVzZUNhbGxiYWNrKSgoZSk9PntcbiAgICAgICAgLy8gRG91YmxlIGNoZWNrIHRoYXQgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhY3R1YWxseSBtYXRjaGVzIGUudGFyZ2V0IGluIGNhc2UgYSBwcmV2aW91c2x5IGNoYWluZWRcbiAgICAgICAgLy8gZm9jdXMgaGFuZGxlciBhbHJlYWR5IG1vdmVkIGZvY3VzIHNvbWV3aGVyZSBlbHNlLlxuICAgICAgICBpZiAoIXN0YXRlLmN1cnJlbnQuaXNGb2N1c1dpdGhpbiAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlLnRhcmdldCkge1xuICAgICAgICAgICAgaWYgKG9uRm9jdXNXaXRoaW4pIG9uRm9jdXNXaXRoaW4oZSk7XG4gICAgICAgICAgICBpZiAob25Gb2N1c1dpdGhpbkNoYW5nZSkgb25Gb2N1c1dpdGhpbkNoYW5nZSh0cnVlKTtcbiAgICAgICAgICAgIHN0YXRlLmN1cnJlbnQuaXNGb2N1c1dpdGhpbiA9IHRydWU7XG4gICAgICAgICAgICBvblN5bnRoZXRpY0ZvY3VzKGUpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBvbkZvY3VzV2l0aGluLFxuICAgICAgICBvbkZvY3VzV2l0aGluQ2hhbmdlLFxuICAgICAgICBvblN5bnRoZXRpY0ZvY3VzXG4gICAgXSk7XG4gICAgaWYgKGlzRGlzYWJsZWQpIHJldHVybiB7XG4gICAgICAgIGZvY3VzV2l0aGluUHJvcHM6IHtcbiAgICAgICAgICAgIC8vIFRoZXNlIHNob3VsZCBub3QgaGF2ZSBiZWVuIG51bGwsIHRoYXQgd291bGQgY29uZmxpY3QgaW4gbWVyZ2VQcm9wc1xuICAgICAgICAgICAgb25Gb2N1czogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb25CbHVyOiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9jdXNXaXRoaW5Qcm9wczoge1xuICAgICAgICAgICAgb25Gb2N1czogb25Gb2N1cyxcbiAgICAgICAgICAgIG9uQmx1cjogb25CbHVyXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvLyBQb3J0aW9ucyBvZiB0aGUgY29kZSBpbiB0aGlzIGZpbGUgYXJlIGJhc2VkIG9uIGNvZGUgZnJvbSByZWFjdC5cbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBmb3IgdGhlIGZvbGxvd2luZyBjYW4gYmUgZm91bmQgaW4gdGhlXG4vLyBOT1RJQ0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvdHJlZS9jYzdjMWFlY2U0NmE2YjY5YjQxOTU4ZDczMWUwZmQyN2M5NGJmYzZjL3BhY2thZ2VzL3JlYWN0LWludGVyYWN0aW9uc1xuXG4vLyBpT1MgZmlyZXMgb25Qb2ludGVyRW50ZXIgdHdpY2U6IG9uY2Ugd2l0aCBwb2ludGVyVHlwZT1cInRvdWNoXCIgYW5kIGFnYWluIHdpdGggcG9pbnRlclR5cGU9XCJtb3VzZVwiLlxuLy8gV2Ugd2FudCB0byBpZ25vcmUgdGhlc2UgZW11bGF0ZWQgZXZlbnRzIHNvIHRoZXkgZG8gbm90IHRyaWdnZXIgaG92ZXIgYmVoYXZpb3IuXG4vLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIxNDYwOS5cbmxldCAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkZ2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IGZhbHNlO1xubGV0ICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRob3ZlckNvdW50ID0gMDtcbmZ1bmN0aW9uICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXRHbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzKCkge1xuICAgICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRnbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gdHJ1ZTtcbiAgICAvLyBDbGVhciBnbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzIGFmdGVyIGEgc2hvcnQgdGltZW91dC4gaU9TIGZpcmVzIG9uUG9pbnRlckVudGVyXG4gICAgLy8gd2l0aCBwb2ludGVyVHlwZT1cIm1vdXNlXCIgaW1tZWRpYXRlbHkgYWZ0ZXIgb25Qb2ludGVyVXAgYW5kIGJlZm9yZSBvbkZvY3VzLiBPbiBvdGhlclxuICAgIC8vIGRldmljZXMgdGhhdCBkb24ndCBoYXZlIHRoaXMgcXVpcmssIHdlIGRvbid0IHdhbnQgdG8gaWdub3JlIGEgbW91c2UgaG92ZXIgc29tZXRpbWUgaW5cbiAgICAvLyB0aGUgZGlzdGFudCBmdXR1cmUgYmVjYXVzZSBhIHVzZXIgcHJldmlvdXNseSB0b3VjaGVkIHRoZSBlbGVtZW50LlxuICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaGFuZGxlR2xvYmFsUG9pbnRlckV2ZW50KGUpIHtcbiAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkc2V0R2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cygpO1xufVxuZnVuY3Rpb24gJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJHNldHVwR2xvYmFsVG91Y2hFdmVudHMoKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgUG9pbnRlckV2ZW50ICE9PSBcInVuZGVmaW5lZFwiKSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRoYW5kbGVHbG9iYWxQb2ludGVyRXZlbnQpO1xuICAgIGVsc2UgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXRHbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzKTtcbiAgICAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaG92ZXJDb3VudCsrO1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaG92ZXJDb3VudC0tO1xuICAgICAgICBpZiAoJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhvdmVyQ291bnQgPiAwKSByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgUG9pbnRlckV2ZW50ICE9PSBcInVuZGVmaW5lZFwiKSBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRoYW5kbGVHbG9iYWxQb2ludGVyRXZlbnQpO1xuICAgICAgICBlbHNlIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkc2V0R2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uICQ2MTc5YjkzNjcwNWU3NmQzJGV4cG9ydCRhZTc4MGRhZjI5ZTZkNDU2KHByb3BzKSB7XG4gICAgbGV0IHsgb25Ib3ZlclN0YXJ0OiBvbkhvdmVyU3RhcnQsIG9uSG92ZXJDaGFuZ2U6IG9uSG92ZXJDaGFuZ2UsIG9uSG92ZXJFbmQ6IG9uSG92ZXJFbmQsIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQgfSA9IHByb3BzO1xuICAgIGxldCBbaXNIb3ZlcmVkLCBzZXRIb3ZlcmVkXSA9ICgwLCAkYng3U0wkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgc3RhdGUgPSAoMCwgJGJ4N1NMJHVzZVJlZikoe1xuICAgICAgICBpc0hvdmVyZWQ6IGZhbHNlLFxuICAgICAgICBpZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgcG9pbnRlclR5cGU6IFwiXCIsXG4gICAgICAgIHRhcmdldDogbnVsbFxuICAgIH0pLmN1cnJlbnQ7XG4gICAgKDAsICRieDdTTCR1c2VFZmZlY3QpKCQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXR1cEdsb2JhbFRvdWNoRXZlbnRzLCBbXSk7XG4gICAgbGV0IHsgaG92ZXJQcm9wczogaG92ZXJQcm9wcywgdHJpZ2dlckhvdmVyRW5kOiB0cmlnZ2VySG92ZXJFbmQgfSA9ICgwLCAkYng3U0wkdXNlTWVtbykoKCk9PntcbiAgICAgICAgbGV0IHRyaWdnZXJIb3ZlclN0YXJ0ID0gKGV2ZW50LCBwb2ludGVyVHlwZSk9PntcbiAgICAgICAgICAgIHN0YXRlLnBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XG4gICAgICAgICAgICBpZiAoaXNEaXNhYmxlZCB8fCBwb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiIHx8IHN0YXRlLmlzSG92ZXJlZCB8fCAhZXZlbnQuY3VycmVudFRhcmdldC5jb250YWlucyhldmVudC50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICBzdGF0ZS5pc0hvdmVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBzdGF0ZS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAob25Ib3ZlclN0YXJ0KSBvbkhvdmVyU3RhcnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaG92ZXJzdGFydFwiLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAob25Ib3ZlckNoYW5nZSkgb25Ib3ZlckNoYW5nZSh0cnVlKTtcbiAgICAgICAgICAgIHNldEhvdmVyZWQodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCB0cmlnZ2VySG92ZXJFbmQgPSAoZXZlbnQsIHBvaW50ZXJUeXBlKT0+e1xuICAgICAgICAgICAgc3RhdGUucG9pbnRlclR5cGUgPSBcIlwiO1xuICAgICAgICAgICAgc3RhdGUudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChwb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiIHx8ICFzdGF0ZS5pc0hvdmVyZWQpIHJldHVybjtcbiAgICAgICAgICAgIHN0YXRlLmlzSG92ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBpZiAob25Ib3ZlckVuZCkgb25Ib3ZlckVuZCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJob3ZlcmVuZFwiLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAob25Ib3ZlckNoYW5nZSkgb25Ib3ZlckNoYW5nZShmYWxzZSk7XG4gICAgICAgICAgICBzZXRIb3ZlcmVkKGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGhvdmVyUHJvcHMgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBQb2ludGVyRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGhvdmVyUHJvcHMub25Qb2ludGVyRW50ZXIgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgJiYgZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdHJpZ2dlckhvdmVyU3RhcnQoZSwgZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaG92ZXJQcm9wcy5vblBvaW50ZXJMZWF2ZSA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghaXNEaXNhYmxlZCAmJiBlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSB0cmlnZ2VySG92ZXJFbmQoZSwgZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG92ZXJQcm9wcy5vblRvdWNoU3RhcnQgPSAoKT0+e1xuICAgICAgICAgICAgICAgIHN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgPSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhvdmVyUHJvcHMub25Nb3VzZUVudGVyID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzICYmICEkNjE3OWI5MzY3MDVlNzZkMyR2YXIkZ2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cykgdHJpZ2dlckhvdmVyU3RhcnQoZSwgXCJtb3VzZVwiKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaG92ZXJQcm9wcy5vbk1vdXNlTGVhdmUgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGlzYWJsZWQgJiYgZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgdHJpZ2dlckhvdmVyRW5kKGUsIFwibW91c2VcIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBob3ZlclByb3BzOiBob3ZlclByb3BzLFxuICAgICAgICAgICAgdHJpZ2dlckhvdmVyRW5kOiB0cmlnZ2VySG92ZXJFbmRcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIG9uSG92ZXJTdGFydCxcbiAgICAgICAgb25Ib3ZlckNoYW5nZSxcbiAgICAgICAgb25Ib3ZlckVuZCxcbiAgICAgICAgaXNEaXNhYmxlZCxcbiAgICAgICAgc3RhdGVcbiAgICBdKTtcbiAgICAoMCwgJGJ4N1NMJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgLy8gQ2FsbCB0aGUgdHJpZ2dlckhvdmVyRW5kIGFzIHNvb24gYXMgaXNEaXNhYmxlZCBjaGFuZ2VzIHRvIHRydWVcbiAgICAgICAgLy8gU2FmZSB0byBjYWxsIHRyaWdnZXJIb3ZlckVuZCwgaXQgd2lsbCBlYXJseSByZXR1cm4gaWYgd2UgYXJlbid0IGN1cnJlbnRseSBob3ZlcmluZ1xuICAgICAgICBpZiAoaXNEaXNhYmxlZCkgdHJpZ2dlckhvdmVyRW5kKHtcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHN0YXRlLnRhcmdldFxuICAgICAgICB9LCBzdGF0ZS5wb2ludGVyVHlwZSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtcbiAgICAgICAgaXNEaXNhYmxlZFxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGhvdmVyUHJvcHM6IGhvdmVyUHJvcHMsXG4gICAgICAgIGlzSG92ZXJlZDogaXNIb3ZlcmVkXG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gcmVhY3QuXG4vLyBPcmlnaW5hbCBsaWNlbnNpbmcgZm9yIHRoZSBmb2xsb3dpbmcgY2FuIGJlIGZvdW5kIGluIHRoZVxuLy8gTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3RyZWUvY2M3YzFhZWNlNDZhNmI2OWI0MTk1OGQ3MzFlMGZkMjdjOTRiZmM2Yy9wYWNrYWdlcy9yZWFjdC1pbnRlcmFjdGlvbnNcblxuXG5mdW5jdGlvbiAkZTBiNmUwYjY4ZWM3ZjUwZiRleHBvcnQkODcyYjY2MGFjNWExZmY5OChwcm9wcykge1xuICAgIGxldCB7IHJlZjogcmVmLCBvbkludGVyYWN0T3V0c2lkZTogb25JbnRlcmFjdE91dHNpZGUsIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsIG9uSW50ZXJhY3RPdXRzaWRlU3RhcnQ6IG9uSW50ZXJhY3RPdXRzaWRlU3RhcnQgfSA9IHByb3BzO1xuICAgIGxldCBzdGF0ZVJlZiA9ICgwLCAkYng3U0wkdXNlUmVmKSh7XG4gICAgICAgIGlzUG9pbnRlckRvd246IGZhbHNlLFxuICAgICAgICBpZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzOiBmYWxzZVxuICAgIH0pO1xuICAgIGxldCBvblBvaW50ZXJEb3duID0gKDAsICRieDdTTCR1c2VFZmZlY3RFdmVudCkoKGUpPT57XG4gICAgICAgIGlmIChvbkludGVyYWN0T3V0c2lkZSAmJiAkZTBiNmUwYjY4ZWM3ZjUwZiR2YXIkaXNWYWxpZEV2ZW50KGUsIHJlZikpIHtcbiAgICAgICAgICAgIGlmIChvbkludGVyYWN0T3V0c2lkZVN0YXJ0KSBvbkludGVyYWN0T3V0c2lkZVN0YXJ0KGUpO1xuICAgICAgICAgICAgc3RhdGVSZWYuY3VycmVudC5pc1BvaW50ZXJEb3duID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCB0cmlnZ2VySW50ZXJhY3RPdXRzaWRlID0gKDAsICRieDdTTCR1c2VFZmZlY3RFdmVudCkoKGUpPT57XG4gICAgICAgIGlmIChvbkludGVyYWN0T3V0c2lkZSkgb25JbnRlcmFjdE91dHNpZGUoZSk7XG4gICAgfSk7XG4gICAgKDAsICRieDdTTCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCBzdGF0ZSA9IHN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChpc0Rpc2FibGVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSByZWYuY3VycmVudDtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRPYmplY3QgPSAoMCwgJGJ4N1NMJGdldE93bmVyRG9jdW1lbnQpKGVsZW1lbnQpO1xuICAgICAgICAvLyBVc2UgcG9pbnRlciBldmVudHMgaWYgYXZhaWxhYmxlLiBPdGhlcndpc2UsIGZhbGwgYmFjayB0byBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzLlxuICAgICAgICBpZiAodHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IG9uUG9pbnRlclVwID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzUG9pbnRlckRvd24gJiYgJGUwYjZlMGI2OGVjN2Y1MGYkdmFyJGlzVmFsaWRFdmVudChlLCByZWYpKSB0cmlnZ2VySW50ZXJhY3RPdXRzaWRlKGUpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBjaGFuZ2luZyB0aGVzZSB0byBjYXB0dXJlIHBoYXNlIGZpeGVkIGNvbWJvYm94XG4gICAgICAgICAgICBkb2N1bWVudE9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICBkb2N1bWVudE9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBvblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwLCB0cnVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgb25Nb3VzZVVwID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMpIHN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZS5pc1BvaW50ZXJEb3duICYmICRlMGI2ZTBiNjhlYzdmNTBmJHZhciRpc1ZhbGlkRXZlbnQoZSwgcmVmKSkgdHJpZ2dlckludGVyYWN0T3V0c2lkZShlKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc1BvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IG9uVG91Y2hFbmQgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaXNQb2ludGVyRG93biAmJiAkZTBiNmUwYjY4ZWM3ZjUwZiR2YXIkaXNWYWxpZEV2ZW50KGUsIHJlZikpIHRyaWdnZXJJbnRlcmFjdE91dHNpZGUoZSk7XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNQb2ludGVyRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICBkb2N1bWVudE9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXAsIHRydWUpO1xuICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICBkb2N1bWVudE9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgb25Ub3VjaEVuZCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICAgICBkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uTW91c2VVcCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIG9uVG91Y2hFbmQsIHRydWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgcmVmLFxuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICBvblBvaW50ZXJEb3duLFxuICAgICAgICB0cmlnZ2VySW50ZXJhY3RPdXRzaWRlXG4gICAgXSk7XG59XG5mdW5jdGlvbiAkZTBiNmUwYjY4ZWM3ZjUwZiR2YXIkaXNWYWxpZEV2ZW50KGV2ZW50LCByZWYpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uID4gMCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChldmVudC50YXJnZXQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGV2ZW50IHRhcmdldCBpcyBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50LCBpZ25vcmVcbiAgICAgICAgY29uc3Qgb3duZXJEb2N1bWVudCA9IGV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgICBpZiAoIW93bmVyRG9jdW1lbnQgfHwgIW93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyB3aXRoaW4gYSB0b3AgbGF5ZXIgZWxlbWVudCAoZS5nLiB0b2FzdHMpLCBpZ25vcmUuXG4gICAgICAgIGlmIChldmVudC50YXJnZXQuY2xvc2VzdChcIltkYXRhLXJlYWN0LWFyaWEtdG9wLWxheWVyXVwiKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcmVmLmN1cnJlbnQgJiYgIXJlZi5jdXJyZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBmdW5jdGlvbiAkOTM5MjUwODNlY2JiMzU4YyRleHBvcnQkNDhkMWVhNjMyMDgzMDI2MChoYW5kbGVyKSB7XG4gICAgaWYgKCFoYW5kbGVyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgIHJldHVybiAoZSk9PntcbiAgICAgICAgbGV0IGV2ZW50ID0ge1xuICAgICAgICAgICAgLi4uZSxcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0ICgpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJzdG9wUHJvcGFnYXRpb24gaXMgbm93IHRoZSBkZWZhdWx0IGJlaGF2aW9yIGZvciBldmVudHMgaW4gUmVhY3QgU3BlY3RydW0uIFlvdSBjYW4gdXNlIGNvbnRpbnVlUHJvcGFnYXRpb24oKSB0byByZXZlcnQgdGhpcyBiZWhhdmlvci5cIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGludWVQcm9wYWdhdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGhhbmRsZXIoZXZlbnQpO1xuICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG59XG5cblxuZnVuY3Rpb24gJDQ2ZDgxOWZjYmFmMzU2NTQkZXhwb3J0JDhmNzE2NTQ4MDFjMmY3Y2QocHJvcHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXlib2FyZFByb3BzOiBwcm9wcy5pc0Rpc2FibGVkID8ge30gOiB7XG4gICAgICAgICAgICBvbktleURvd246ICgwLCAkOTM5MjUwODNlY2JiMzU4YyRleHBvcnQkNDhkMWVhNjMyMDgzMDI2MCkocHJvcHMub25LZXlEb3duKSxcbiAgICAgICAgICAgIG9uS2V5VXA6ICgwLCAkOTM5MjUwODNlY2JiMzU4YyRleHBvcnQkNDhkMWVhNjMyMDgzMDI2MCkocHJvcHMub25LZXlVcClcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbmZ1bmN0aW9uICRlOGE3MDIyY2Y4N2NiYTJhJGV4cG9ydCQzNmRhOTYzNzlmNzlmMjQ1KHByb3BzKSB7XG4gICAgbGV0IHsgb25Nb3ZlU3RhcnQ6IG9uTW92ZVN0YXJ0LCBvbk1vdmU6IG9uTW92ZSwgb25Nb3ZlRW5kOiBvbk1vdmVFbmQgfSA9IHByb3BzO1xuICAgIGxldCBzdGF0ZSA9ICgwLCAkYng3U0wkdXNlUmVmKSh7XG4gICAgICAgIGRpZE1vdmU6IGZhbHNlLFxuICAgICAgICBsYXN0UG9zaXRpb246IG51bGwsXG4gICAgICAgIGlkOiBudWxsXG4gICAgfSk7XG4gICAgbGV0IHsgYWRkR2xvYmFsTGlzdGVuZXI6IGFkZEdsb2JhbExpc3RlbmVyLCByZW1vdmVHbG9iYWxMaXN0ZW5lcjogcmVtb3ZlR2xvYmFsTGlzdGVuZXIgfSA9ICgwLCAkYng3U0wkdXNlR2xvYmFsTGlzdGVuZXJzKSgpO1xuICAgIGxldCBtb3ZlID0gKDAsICRieDdTTCR1c2VFZmZlY3RFdmVudCkoKG9yaWdpbmFsRXZlbnQsIHBvaW50ZXJUeXBlLCBkZWx0YVgsIGRlbHRhWSk9PntcbiAgICAgICAgaWYgKGRlbHRhWCA9PT0gMCAmJiBkZWx0YVkgPT09IDApIHJldHVybjtcbiAgICAgICAgaWYgKCFzdGF0ZS5jdXJyZW50LmRpZE1vdmUpIHtcbiAgICAgICAgICAgIHN0YXRlLmN1cnJlbnQuZGlkTW92ZSA9IHRydWU7XG4gICAgICAgICAgICBvbk1vdmVTdGFydCA9PT0gbnVsbCB8fCBvbk1vdmVTdGFydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Nb3ZlU3RhcnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibW92ZXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgICAgIHNoaWZ0S2V5OiBvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgIG1ldGFLZXk6IG9yaWdpbmFsRXZlbnQubWV0YUtleSxcbiAgICAgICAgICAgICAgICBjdHJsS2V5OiBvcmlnaW5hbEV2ZW50LmN0cmxLZXksXG4gICAgICAgICAgICAgICAgYWx0S2V5OiBvcmlnaW5hbEV2ZW50LmFsdEtleVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgb25Nb3ZlID09PSBudWxsIHx8IG9uTW92ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Nb3ZlKHtcbiAgICAgICAgICAgIHR5cGU6IFwibW92ZVwiLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgZGVsdGFYOiBkZWx0YVgsXG4gICAgICAgICAgICBkZWx0YVk6IGRlbHRhWSxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgbWV0YUtleTogb3JpZ2luYWxFdmVudC5tZXRhS2V5LFxuICAgICAgICAgICAgY3RybEtleTogb3JpZ2luYWxFdmVudC5jdHJsS2V5LFxuICAgICAgICAgICAgYWx0S2V5OiBvcmlnaW5hbEV2ZW50LmFsdEtleVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBsZXQgZW5kID0gKDAsICRieDdTTCR1c2VFZmZlY3RFdmVudCkoKG9yaWdpbmFsRXZlbnQsIHBvaW50ZXJUeXBlKT0+e1xuICAgICAgICAoMCwgJDE0YzBiNzI1MDlkNzAyMjUkZXhwb3J0JGIwZDZmYTFhYjMyZTMyOTUpKCk7XG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50LmRpZE1vdmUpIG9uTW92ZUVuZCA9PT0gbnVsbCB8fCBvbk1vdmVFbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uTW92ZUVuZCh7XG4gICAgICAgICAgICB0eXBlOiBcIm1vdmVlbmRcIixcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgbWV0YUtleTogb3JpZ2luYWxFdmVudC5tZXRhS2V5LFxuICAgICAgICAgICAgY3RybEtleTogb3JpZ2luYWxFdmVudC5jdHJsS2V5LFxuICAgICAgICAgICAgYWx0S2V5OiBvcmlnaW5hbEV2ZW50LmFsdEtleVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBsZXQgbW92ZVByb3BzID0gKDAsICRieDdTTCR1c2VNZW1vKSgoKT0+e1xuICAgICAgICBsZXQgbW92ZVByb3BzID0ge307XG4gICAgICAgIGxldCBzdGFydCA9ICgpPT57XG4gICAgICAgICAgICAoMCwgJDE0YzBiNzI1MDlkNzAyMjUkZXhwb3J0JDE2YTQ2OTc0NjcxNzU0ODcpKCk7XG4gICAgICAgICAgICBzdGF0ZS5jdXJyZW50LmRpZE1vdmUgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBQb2ludGVyRXZlbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBvbk1vdXNlTW92ZSA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uLCBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24xO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYLCBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVk7XG4gICAgICAgICAgICAgICAgICAgIG1vdmUoZSwgXCJtb3VzZVwiLCBlLnBhZ2VYIC0gKChfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVggPSAoX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uID0gc3RhdGUuY3VycmVudC5sYXN0UG9zaXRpb24pID09PSBudWxsIHx8IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uLnBhZ2VYKSAhPT0gbnVsbCAmJiBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVggIT09IHZvaWQgMCA/IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWCA6IDApLCBlLnBhZ2VZIC0gKChfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVkgPSAoX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMSA9IHN0YXRlLmN1cnJlbnQubGFzdFBvc2l0aW9uKSA9PT0gbnVsbCB8fCBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24xLnBhZ2VZKSAhPT0gbnVsbCAmJiBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVkgIT09IHZvaWQgMCA/IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWSA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudC5sYXN0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWDogZS5wYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBlLnBhZ2VZXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBvbk1vdXNlVXAgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kKGUsIFwibW91c2VcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJtb3VzZW1vdmVcIiwgb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXIod2luZG93LCBcIm1vdXNldXBcIiwgb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1vdmVQcm9wcy5vbk1vdXNlRG93biA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnQubGFzdFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVg6IGUucGFnZVgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWTogZS5wYWdlWVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJtb3VzZXVwXCIsIG9uTW91c2VVcCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgb25Ub3VjaE1vdmUgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBsZXQgdG91Y2ggPSBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmUuY2hhbmdlZFRvdWNoZXNcbiAgICAgICAgICAgICAgICBdLmZpbmRJbmRleCgoeyBpZGVudGlmaWVyOiBpZGVudGlmaWVyIH0pPT5pZGVudGlmaWVyID09PSBzdGF0ZS5jdXJyZW50LmlkKTtcbiAgICAgICAgICAgICAgICBpZiAodG91Y2ggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uLCBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24xO1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBwYWdlWDogcGFnZVgsIHBhZ2VZOiBwYWdlWSB9ID0gZS5jaGFuZ2VkVG91Y2hlc1t0b3VjaF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVgsIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZShlLCBcInRvdWNoXCIsIHBhZ2VYIC0gKChfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVggPSAoX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uID0gc3RhdGUuY3VycmVudC5sYXN0UG9zaXRpb24pID09PSBudWxsIHx8IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uLnBhZ2VYKSAhPT0gbnVsbCAmJiBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVggIT09IHZvaWQgMCA/IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWCA6IDApLCBwYWdlWSAtICgoX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZID0gKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjEgPSBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbikgPT09IG51bGwgfHwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMS5wYWdlWSkgIT09IG51bGwgJiYgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZICE9PSB2b2lkIDAgPyBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVkgOiAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnQubGFzdFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVg6IHBhZ2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVk6IHBhZ2VZXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBvblRvdWNoRW5kID0gKGUpPT57XG4gICAgICAgICAgICAgICAgbGV0IHRvdWNoID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5lLmNoYW5nZWRUb3VjaGVzXG4gICAgICAgICAgICAgICAgXS5maW5kSW5kZXgoKHsgaWRlbnRpZmllcjogaWRlbnRpZmllciB9KT0+aWRlbnRpZmllciA9PT0gc3RhdGUuY3VycmVudC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRvdWNoID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kKGUsIFwidG91Y2hcIik7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnQuaWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwidG91Y2htb3ZlXCIsIG9uVG91Y2hNb3ZlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInRvdWNoZW5kXCIsIG9uVG91Y2hFbmQpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwidG91Y2hjYW5jZWxcIiwgb25Ub3VjaEVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1vdmVQcm9wcy5vblRvdWNoU3RhcnQgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPT09IDAgfHwgc3RhdGUuY3VycmVudC5pZCAhPSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IHsgcGFnZVg6IHBhZ2VYLCBwYWdlWTogcGFnZVksIGlkZW50aWZpZXI6IGlkZW50aWZpZXIgfSA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICAgICAgc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZVg6IHBhZ2VYLFxuICAgICAgICAgICAgICAgICAgICBwYWdlWTogcGFnZVlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnQuaWQgPSBpZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJ0b3VjaG1vdmVcIiwgb25Ub3VjaE1vdmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwidG91Y2hlbmRcIiwgb25Ub3VjaEVuZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJ0b3VjaGNhbmNlbFwiLCBvblRvdWNoRW5kLCBmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG9uUG9pbnRlck1vdmUgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoZS5wb2ludGVySWQgPT09IHN0YXRlLmN1cnJlbnQuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbiwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXJUeXBlID0gZS5wb2ludGVyVHlwZSB8fCBcIm1vdXNlXCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVgsIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvYmxlbXMgd2l0aCBQb2ludGVyRXZlbnQjbW92ZW1lbnRYL21vdmVtZW50WTpcbiAgICAgICAgICAgICAgICAgICAgLy8gMS4gaXQgaXMgYWx3YXlzIDAgb24gbWFjT1MgU2FmYXJpLlxuICAgICAgICAgICAgICAgICAgICAvLyAyLiBPbiBDaHJvbWUgQW5kcm9pZCwgaXQncyBzY2FsZWQgYnkgZGV2aWNlUGl4ZWxSYXRpbywgYnV0IG5vdCBvbiBDaHJvbWUgbWFjT1NcbiAgICAgICAgICAgICAgICAgICAgbW92ZShlLCBwb2ludGVyVHlwZSwgZS5wYWdlWCAtICgoX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYID0gKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbiA9IHN0YXRlLmN1cnJlbnQubGFzdFBvc2l0aW9uKSA9PT0gbnVsbCB8fCBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbi5wYWdlWCkgIT09IG51bGwgJiYgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYICE9PSB2b2lkIDAgPyBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVggOiAwKSwgZS5wYWdlWSAtICgoX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZID0gKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjEgPSBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbikgPT09IG51bGwgfHwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMS5wYWdlWSkgIT09IG51bGwgJiYgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZICE9PSB2b2lkIDAgPyBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVkgOiAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnQubGFzdFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVg6IGUucGFnZVgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWTogZS5wYWdlWVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgb25Qb2ludGVyVXAgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoZS5wb2ludGVySWQgPT09IHN0YXRlLmN1cnJlbnQuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXJUeXBlID0gZS5wb2ludGVyVHlwZSB8fCBcIm1vdXNlXCI7XG4gICAgICAgICAgICAgICAgICAgIGVuZChlLCBwb2ludGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnQuaWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwicG9pbnRlcm1vdmVcIiwgb25Qb2ludGVyTW92ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJwb2ludGVyY2FuY2VsXCIsIG9uUG9pbnRlclVwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1vdmVQcm9wcy5vblBvaW50ZXJEb3duID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwICYmIHN0YXRlLmN1cnJlbnQuaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnQubGFzdFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVg6IGUucGFnZVgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWTogZS5wYWdlWVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50LmlkID0gZS5wb2ludGVySWQ7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJwb2ludGVybW92ZVwiLCBvblBvaW50ZXJNb3ZlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJwb2ludGVydXBcIiwgb25Qb2ludGVyVXAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInBvaW50ZXJjYW5jZWxcIiwgb25Qb2ludGVyVXAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCB0cmlnZ2VyS2V5Ym9hcmRNb3ZlID0gKGUsIGRlbHRhWCwgZGVsdGFZKT0+e1xuICAgICAgICAgICAgc3RhcnQoKTtcbiAgICAgICAgICAgIG1vdmUoZSwgXCJrZXlib2FyZFwiLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgICAgICBlbmQoZSwgXCJrZXlib2FyZFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgbW92ZVByb3BzLm9uS2V5RG93biA9IChlKT0+e1xuICAgICAgICAgICAgc3dpdGNoKGUua2V5KXtcbiAgICAgICAgICAgICAgICBjYXNlIFwiTGVmdFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyS2V5Ym9hcmRNb3ZlKGUsIC0xLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyS2V5Ym9hcmRNb3ZlKGUsIDEsIDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiVXBcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJLZXlib2FyZE1vdmUoZSwgMCwgLTEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiRG93blwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyS2V5Ym9hcmRNb3ZlKGUsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1vdmVQcm9wcztcbiAgICB9LCBbXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcixcbiAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXIsXG4gICAgICAgIG1vdmUsXG4gICAgICAgIGVuZFxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1vdmVQcm9wczogbW92ZVByb3BzXG4gICAgfTtcbn1cblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuZnVuY3Rpb24gJDdkMGE2MzZkN2E0ZGNlZmQkZXhwb3J0JDIxMjNmZjJiODdjODFjYShwcm9wcywgcmVmKSB7XG4gICAgbGV0IHsgb25TY3JvbGw6IG9uU2Nyb2xsLCBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkIH0gPSBwcm9wcztcbiAgICBsZXQgb25TY3JvbGxIYW5kbGVyID0gKDAsICRieDdTTCR1c2VDYWxsYmFjaykoKGUpPT57XG4gICAgICAgIC8vIElmIHRoZSBjdHJsS2V5IGlzIHByZXNzZWQsIHRoaXMgaXMgYSB6b29tIGV2ZW50LCBkbyBub3RoaW5nLlxuICAgICAgICBpZiAoZS5jdHJsS2V5KSByZXR1cm47XG4gICAgICAgIC8vIHN0b3Agc2Nyb2xsaW5nIHRoZSBwYWdlXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKG9uU2Nyb2xsKSBvblNjcm9sbCh7XG4gICAgICAgICAgICBkZWx0YVg6IGUuZGVsdGFYLFxuICAgICAgICAgICAgZGVsdGFZOiBlLmRlbHRhWVxuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIG9uU2Nyb2xsXG4gICAgXSk7XG4gICAgKDAsICRieDdTTCR1c2VFdmVudCkocmVmLCBcIndoZWVsXCIsIGlzRGlzYWJsZWQgPyB1bmRlZmluZWQgOiBvblNjcm9sbEhhbmRsZXIpO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5jb25zdCAkOGEyNjU2MWQyODc3MjM2ZSR2YXIkREVGQVVMVF9USFJFU0hPTEQgPSA1MDA7XG5mdW5jdGlvbiAkOGEyNjU2MWQyODc3MjM2ZSRleHBvcnQkYzI0ZWQwMTA0ZDA3ZWFiOShwcm9wcykge1xuICAgIGxldCB7IGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsIG9uTG9uZ1ByZXNzU3RhcnQ6IG9uTG9uZ1ByZXNzU3RhcnQsIG9uTG9uZ1ByZXNzRW5kOiBvbkxvbmdQcmVzc0VuZCwgb25Mb25nUHJlc3M6IG9uTG9uZ1ByZXNzLCB0aHJlc2hvbGQ6IHRocmVzaG9sZCA9ICQ4YTI2NTYxZDI4NzcyMzZlJHZhciRERUZBVUxUX1RIUkVTSE9MRCwgYWNjZXNzaWJpbGl0eURlc2NyaXB0aW9uOiBhY2Nlc3NpYmlsaXR5RGVzY3JpcHRpb24gfSA9IHByb3BzO1xuICAgIGNvbnN0IHRpbWVSZWYgPSAoMCwgJGJ4N1NMJHVzZVJlZikoKTtcbiAgICBsZXQgeyBhZGRHbG9iYWxMaXN0ZW5lcjogYWRkR2xvYmFsTGlzdGVuZXIsIHJlbW92ZUdsb2JhbExpc3RlbmVyOiByZW1vdmVHbG9iYWxMaXN0ZW5lciB9ID0gKDAsICRieDdTTCR1c2VHbG9iYWxMaXN0ZW5lcnMpKCk7XG4gICAgbGV0IHsgcHJlc3NQcm9wczogcHJlc3NQcm9wcyB9ID0gKDAsICRmNmMzMWNjZTJhZGY2NTRmJGV4cG9ydCQ0NTcxMmVjZWRhNmZhZDIxKSh7XG4gICAgICAgIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgICAgIG9uUHJlc3NTdGFydCAoZSkge1xuICAgICAgICAgICAgZS5jb250aW51ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICAgICAgICAgIGlmIChvbkxvbmdQcmVzc1N0YXJ0KSBvbkxvbmdQcmVzc1N0YXJ0KHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJsb25ncHJlc3NzdGFydFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGltZVJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG90aGVyIHVzZVByZXNzIGhhbmRsZXJzIGZyb20gYWxzbyBoYW5kbGluZyB0aGlzIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBQb2ludGVyRXZlbnQoXCJwb2ludGVyY2FuY2VsXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25Mb25nUHJlc3MpIG9uTG9uZ1ByZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImxvbmdwcmVzc1wiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aW1lUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSwgdGhyZXNob2xkKTtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGNvbnRleHQgbWVudSwgd2hpY2ggbWF5IGJlIG9wZW5lZCBvbiBsb25nIHByZXNzIG9uIHRvdWNoIGRldmljZXNcbiAgICAgICAgICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbkNvbnRleHRNZW51ID0gKGUpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKGUudGFyZ2V0LCBcImNvbnRleHRtZW51XCIsIG9uQ29udGV4dE1lbnUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJwb2ludGVydXBcIiwgKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIGNvbnRleHRtZW51IGV2ZW50IGlzIGZpcmVkIHF1aWNrbHkgYWZ0ZXIgcG9pbnRlcnVwLCByZW1vdmUgdGhlIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIGZ1dHVyZSBjb250ZXh0IG1lbnUgZXZlbnRzIG91dHNpZGUgYSBsb25nIHByZXNzIGFyZSBub3QgcHJldmVudGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyKGUudGFyZ2V0LCBcImNvbnRleHRtZW51XCIsIG9uQ29udGV4dE1lbnUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMzApO1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25QcmVzc0VuZCAoZSkge1xuICAgICAgICAgICAgaWYgKHRpbWVSZWYuY3VycmVudCkgY2xlYXJUaW1lb3V0KHRpbWVSZWYuY3VycmVudCk7XG4gICAgICAgICAgICBpZiAob25Mb25nUHJlc3NFbmQgJiYgKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpKSBvbkxvbmdQcmVzc0VuZCh7XG4gICAgICAgICAgICAgICAgLi4uZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImxvbmdwcmVzc2VuZFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBkZXNjcmlwdGlvblByb3BzID0gKDAsICRieDdTTCR1c2VEZXNjcmlwdGlvbikob25Mb25nUHJlc3MgJiYgIWlzRGlzYWJsZWQgPyBhY2Nlc3NpYmlsaXR5RGVzY3JpcHRpb24gOiB1bmRlZmluZWQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxvbmdQcmVzc1Byb3BzOiAoMCwgJGJ4N1NMJG1lcmdlUHJvcHMpKHByZXNzUHJvcHMsIGRlc2NyaXB0aW9uUHJvcHMpXG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskM2IxMTdlNDNkYzBjYTk1ZCRleHBvcnQkMjdjNzAxZWQ5ZTQ0OWU5OSBhcyBQcmVzc2FibGUsICRmMWFiOGM3NTQ3OGM2ZjczJGV4cG9ydCQzMzUxODcxZWU0YjI4OGI4IGFzIFByZXNzUmVzcG9uZGVyLCAkZjFhYjhjNzU0NzhjNmY3MyRleHBvcnQkY2Y3NTQyOGUwYjllZDFlYSBhcyBDbGVhclByZXNzUmVzcG9uZGVyLCAkYTFlYTU5ZDY4MjcwZjBkZCRleHBvcnQkZjgxNjhkOGRkOGZkNjZlNiBhcyB1c2VGb2N1cywgJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGI5YjNkZmRkYWIxN2RiMjcgYXMgaXNGb2N1c1Zpc2libGUsICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCQ2MzBmZjY1M2M1YWRhNmE5IGFzIGdldEludGVyYWN0aW9uTW9kYWxpdHksICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCQ4Mzk3ZGRmYzUwNGZkYjlhIGFzIHNldEludGVyYWN0aW9uTW9kYWxpdHksICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCQ5OGUyMGVjOTJmNjE0Y2ZlIGFzIHVzZUludGVyYWN0aW9uTW9kYWxpdHksICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRmZmQ5ZTUwMjFjMWZiMmQ2IGFzIHVzZUZvY3VzVmlzaWJsZSwgJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGVjNzFiNGI4M2FjMDhlYzMgYXMgdXNlRm9jdXNWaXNpYmxlTGlzdGVuZXIsICQ5YWI5NDI2MmJkMDA0N2M3JGV4cG9ydCQ0MjBlNjgyNzMxNjVmNGVjIGFzIHVzZUZvY3VzV2l0aGluLCAkNjE3OWI5MzY3MDVlNzZkMyRleHBvcnQkYWU3ODBkYWYyOWU2ZDQ1NiBhcyB1c2VIb3ZlciwgJGUwYjZlMGI2OGVjN2Y1MGYkZXhwb3J0JDg3MmI2NjBhYzVhMWZmOTggYXMgdXNlSW50ZXJhY3RPdXRzaWRlLCAkNDZkODE5ZmNiYWYzNTY1NCRleHBvcnQkOGY3MTY1NDgwMWMyZjdjZCBhcyB1c2VLZXlib2FyZCwgJGU4YTcwMjJjZjg3Y2JhMmEkZXhwb3J0JDM2ZGE5NjM3OWY3OWYyNDUgYXMgdXNlTW92ZSwgJGY2YzMxY2NlMmFkZjY1NGYkZXhwb3J0JDQ1NzEyZWNlZGE2ZmFkMjEgYXMgdXNlUHJlc3MsICQ3ZDBhNjM2ZDdhNGRjZWZkJGV4cG9ydCQyMTIzZmYyYjg3YzgxY2EgYXMgdXNlU2Nyb2xsV2hlZWwsICQ4YTI2NTYxZDI4NzcyMzZlJGV4cG9ydCRjMjRlZDAxMDRkMDdlYWI5IGFzIHVzZUxvbmdQcmVzc307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@react-aria/interactions/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@react-aria/overlays/dist/import.mjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@react-aria/overlays/dist/import.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DismissButton: () => (/* binding */ $86ea4cb521eb2e37$export$2317d149ed6f78c4),\n/* harmony export */   ModalProvider: () => (/* binding */ $f57aed4a881a3485$export$178405afcd8c5eb),\n/* harmony export */   Overlay: () => (/* binding */ $337b884510726a0d$export$c6fdb837b070b4ff),\n/* harmony export */   OverlayContainer: () => (/* binding */ $f57aed4a881a3485$export$b47c3594eab58386),\n/* harmony export */   OverlayProvider: () => (/* binding */ $f57aed4a881a3485$export$bf688221f59024e5),\n/* harmony export */   ariaHideOutside: () => (/* binding */ $5e3802645cc19319$export$1c3ebcada18427bf),\n/* harmony export */   useModal: () => (/* binding */ $f57aed4a881a3485$export$33ffd74ebf07f060),\n/* harmony export */   useModalOverlay: () => (/* binding */ $8ac8429251c45e4b$export$dbc0f175b25fb0fb),\n/* harmony export */   useModalProvider: () => (/* binding */ $f57aed4a881a3485$export$d9aaed4c3ece1bc0),\n/* harmony export */   useOverlay: () => (/* binding */ $a11501f3d1d39e6c$export$ea8f71083e90600f),\n/* harmony export */   useOverlayFocusContain: () => (/* binding */ $337b884510726a0d$export$14c98a7594375490),\n/* harmony export */   useOverlayPosition: () => (/* binding */ $2a41e45df1593e64$export$d39e1813b3bdd0e1),\n/* harmony export */   useOverlayTrigger: () => (/* binding */ $628037886ba31236$export$f9d5c8beee7d008d),\n/* harmony export */   usePopover: () => (/* binding */ $f2f8a6077418541e$export$542a6fd13ac93354),\n/* harmony export */   usePreventScroll: () => (/* binding */ $49c51c25361d4cd2$export$ee0f7cc6afcd1c18)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/../../node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/../../node_modules/@react-aria/utils/dist/import.mjs\");\n/* harmony import */ var _react_aria_i18n__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-aria/i18n */ \"(ssr)/../../node_modules/@react-aria/i18n/dist/real-module.mjs\");\n/* harmony import */ var _react_aria_focus__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @react-aria/focus */ \"(ssr)/../../node_modules/@react-aria/focus/dist/import.mjs\");\n/* harmony import */ var _react_aria_interactions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-aria/interactions */ \"(ssr)/../../node_modules/@react-aria/interactions/dist/import.mjs\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _react_aria_ssr__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @react-aria/ssr */ \"(ssr)/../../node_modules/@react-aria/ssr/dist/import.mjs\");\n/* harmony import */ var _react_aria_visually_hidden__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @react-aria/visually-hidden */ \"(ssr)/../../node_modules/@react-aria/visually-hidden/dist/import.mjs\");\n\n\n\n\n\n\n\n\n\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nconst $edcf132a9284368a$var$AXIS = {\n    top: \"top\",\n    bottom: \"top\",\n    left: \"left\",\n    right: \"left\"\n};\nconst $edcf132a9284368a$var$FLIPPED_DIRECTION = {\n    top: \"bottom\",\n    bottom: \"top\",\n    left: \"right\",\n    right: \"left\"\n};\nconst $edcf132a9284368a$var$CROSS_AXIS = {\n    top: \"left\",\n    left: \"top\"\n};\nconst $edcf132a9284368a$var$AXIS_SIZE = {\n    top: \"height\",\n    left: \"width\"\n};\nconst $edcf132a9284368a$var$TOTAL_SIZE = {\n    width: \"totalWidth\",\n    height: \"totalHeight\"\n};\nconst $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE = {};\n// @ts-ignore\nlet $edcf132a9284368a$var$visualViewport = typeof document !== \"undefined\" && window.visualViewport;\nfunction $edcf132a9284368a$var$getContainerDimensions(containerNode) {\n    let width = 0, height = 0, totalWidth = 0, totalHeight = 0, top = 0, left = 0;\n    let scroll = {};\n    if (containerNode.tagName === \"BODY\") {\n        let documentElement = document.documentElement;\n        totalWidth = documentElement.clientWidth;\n        totalHeight = documentElement.clientHeight;\n        var _visualViewport_width;\n        width = (_visualViewport_width = $edcf132a9284368a$var$visualViewport === null || $edcf132a9284368a$var$visualViewport === void 0 ? void 0 : $edcf132a9284368a$var$visualViewport.width) !== null && _visualViewport_width !== void 0 ? _visualViewport_width : totalWidth;\n        var _visualViewport_height;\n        height = (_visualViewport_height = $edcf132a9284368a$var$visualViewport === null || $edcf132a9284368a$var$visualViewport === void 0 ? void 0 : $edcf132a9284368a$var$visualViewport.height) !== null && _visualViewport_height !== void 0 ? _visualViewport_height : totalHeight;\n        scroll.top = documentElement.scrollTop || containerNode.scrollTop;\n        scroll.left = documentElement.scrollLeft || containerNode.scrollLeft;\n    } else {\n        ({ width: width, height: height, top: top, left: left } = $edcf132a9284368a$var$getOffset(containerNode));\n        scroll.top = containerNode.scrollTop;\n        scroll.left = containerNode.scrollLeft;\n        totalWidth = width;\n        totalHeight = height;\n    }\n    return {\n        width: width,\n        height: height,\n        totalWidth: totalWidth,\n        totalHeight: totalHeight,\n        scroll: scroll,\n        top: top,\n        left: left\n    };\n}\nfunction $edcf132a9284368a$var$getScroll(node) {\n    return {\n        top: node.scrollTop,\n        left: node.scrollLeft,\n        width: node.scrollWidth,\n        height: node.scrollHeight\n    };\n}\nfunction $edcf132a9284368a$var$getDelta(axis, offset, size, // The dimensions of the boundary element that the popover is\n// positioned within (most of the time this is the <body>).\nboundaryDimensions, // The dimensions of the containing block element that the popover is\n// positioned relative to (e.g. parent with position: relative).\n// Usually this is the same as the boundary element, but if the popover\n// is portaled somewhere other than the body and has an ancestor with\n// position: relative/absolute, it will be different.\ncontainerDimensions, padding) {\n    let containerScroll = containerDimensions.scroll[axis];\n    let boundaryHeight = boundaryDimensions[$edcf132a9284368a$var$AXIS_SIZE[axis]];\n    let startEdgeOffset = offset - padding - containerScroll;\n    let endEdgeOffset = offset + padding - containerScroll + size;\n    if (startEdgeOffset < 0) return -startEdgeOffset;\n    else if (endEdgeOffset > boundaryHeight) return Math.max(boundaryHeight - endEdgeOffset, -startEdgeOffset);\n    else return 0;\n}\nfunction $edcf132a9284368a$var$getMargins(node) {\n    let style = window.getComputedStyle(node);\n    return {\n        top: parseInt(style.marginTop, 10) || 0,\n        bottom: parseInt(style.marginBottom, 10) || 0,\n        left: parseInt(style.marginLeft, 10) || 0,\n        right: parseInt(style.marginRight, 10) || 0\n    };\n}\nfunction $edcf132a9284368a$var$parsePlacement(input) {\n    if ($edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input]) return $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input];\n    let [placement, crossPlacement] = input.split(\" \");\n    let axis = $edcf132a9284368a$var$AXIS[placement] || \"right\";\n    let crossAxis = $edcf132a9284368a$var$CROSS_AXIS[axis];\n    if (!$edcf132a9284368a$var$AXIS[crossPlacement]) crossPlacement = \"center\";\n    let size = $edcf132a9284368a$var$AXIS_SIZE[axis];\n    let crossSize = $edcf132a9284368a$var$AXIS_SIZE[crossAxis];\n    $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input] = {\n        placement: placement,\n        crossPlacement: crossPlacement,\n        axis: axis,\n        crossAxis: crossAxis,\n        size: size,\n        crossSize: crossSize\n    };\n    return $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input];\n}\nfunction $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset) {\n    let { placement: placement, crossPlacement: crossPlacement, axis: axis, crossAxis: crossAxis, size: size, crossSize: crossSize } = placementInfo;\n    let position = {};\n    // button position\n    position[crossAxis] = childOffset[crossAxis];\n    if (crossPlacement === \"center\") //  + (button size / 2) - (overlay size / 2)\n    // at this point the overlay center should match the button center\n    position[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;\n    else if (crossPlacement !== crossAxis) //  + (button size) - (overlay size)\n    // at this point the overlay bottom should match the button bottom\n    position[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];\n     /* else {\n    the overlay top should match the button top\n  } */ \n    // add the crossOffset from props\n    position[crossAxis] += crossOffset;\n    // overlay top overlapping arrow with button bottom\n    const minPosition = childOffset[crossAxis] - overlaySize[crossSize] + arrowSize + arrowBoundaryOffset;\n    // overlay bottom overlapping arrow with button top\n    const maxPosition = childOffset[crossAxis] + childOffset[crossSize] - arrowSize - arrowBoundaryOffset;\n    position[crossAxis] = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.clamp)(position[crossAxis], minPosition, maxPosition);\n    // Floor these so the position isn't placed on a partial pixel, only whole pixels. Shouldn't matter if it was floored or ceiled, so chose one.\n    if (placement === axis) {\n        // If the container is positioned (non-static), then we use the container's actual\n        // height, as `bottom` will be relative to this height.  But if the container is static,\n        // then it can only be the `document.body`, and `bottom` will be relative to _its_\n        // container, which should be as large as boundaryDimensions.\n        const containerHeight = isContainerPositioned ? containerOffsetWithBoundary[size] : boundaryDimensions[$edcf132a9284368a$var$TOTAL_SIZE[size]];\n        position[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] = Math.floor(containerHeight - childOffset[axis] + offset);\n    } else position[axis] = Math.floor(childOffset[axis] + childOffset[size] + offset);\n    return position;\n}\nfunction $edcf132a9284368a$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding) {\n    return position.top != null ? Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top // this is the bottom of the boundary\n     - (containerOffsetWithBoundary.top + position.top // this is the top of the overlay\n    ) - (margins.top + margins.bottom + padding // save additional space for margin and padding\n    )) : Math.max(0, childOffset.top + containerOffsetWithBoundary.top // this is the top of the trigger\n     - (boundaryDimensions.top + boundaryDimensions.scroll.top // this is the top of the boundary\n    ) - (margins.top + margins.bottom + padding // save additional space for margin and padding\n    ));\n}\nfunction $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding, placementInfo) {\n    let { placement: placement, axis: axis, size: size } = placementInfo;\n    if (placement === axis) return Math.max(0, childOffset[axis] - boundaryDimensions[axis] - boundaryDimensions.scroll[axis] + containerOffsetWithBoundary[axis] - margins[axis] - margins[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] - padding);\n    return Math.max(0, boundaryDimensions[size] + boundaryDimensions[axis] + boundaryDimensions.scroll[axis] - containerOffsetWithBoundary[axis] - childOffset[axis] - childOffset[size] - margins[axis] - margins[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] - padding);\n}\nfunction $edcf132a9284368a$export$6839422d1f33cee9(placementInput, childOffset, overlaySize, scrollSize, margins, padding, flip, boundaryDimensions, containerDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, userSetMaxHeight, arrowSize, arrowBoundaryOffset) {\n    let placementInfo = $edcf132a9284368a$var$parsePlacement(placementInput);\n    let { size: size, crossAxis: crossAxis, crossSize: crossSize, placement: placement, crossPlacement: crossPlacement } = placementInfo;\n    let position = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);\n    let normalizedOffset = offset;\n    let space = $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, placementInfo);\n    // Check if the scroll size of the overlay is greater than the available space to determine if we need to flip\n    if (flip && scrollSize[size] > space) {\n        let flippedPlacementInfo = $edcf132a9284368a$var$parsePlacement(`${$edcf132a9284368a$var$FLIPPED_DIRECTION[placement]} ${crossPlacement}`);\n        let flippedPosition = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);\n        let flippedSpace = $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, flippedPlacementInfo);\n        // If the available space for the flipped position is greater than the original available space, flip.\n        if (flippedSpace > space) {\n            placementInfo = flippedPlacementInfo;\n            position = flippedPosition;\n            normalizedOffset = offset;\n        }\n    }\n    let delta = $edcf132a9284368a$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, containerDimensions, padding);\n    position[crossAxis] += delta;\n    let maxHeight = $edcf132a9284368a$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding);\n    if (userSetMaxHeight && userSetMaxHeight < maxHeight) maxHeight = userSetMaxHeight;\n    overlaySize.height = Math.min(overlaySize.height, maxHeight);\n    position = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);\n    delta = $edcf132a9284368a$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, containerDimensions, padding);\n    position[crossAxis] += delta;\n    let arrowPosition = {};\n    // All values are transformed so that 0 is at the top/left of the overlay depending on the orientation\n    // Prefer the arrow being in the center of the trigger/overlay anchor element\n    let preferredArrowPosition = childOffset[crossAxis] + .5 * childOffset[crossSize] - overlaySize[crossAxis];\n    // Min/Max position limits for the arrow with respect to the overlay\n    const arrowMinPosition = arrowSize / 2 + arrowBoundaryOffset;\n    const arrowMaxPosition = overlaySize[crossSize] - arrowSize / 2 - arrowBoundaryOffset;\n    // Min/Max position limits for the arrow with respect to the trigger/overlay anchor element\n    const arrowOverlappingChildMinEdge = childOffset[crossAxis] - overlaySize[crossAxis] + arrowSize / 2;\n    const arrowOverlappingChildMaxEdge = childOffset[crossAxis] + childOffset[crossSize] - overlaySize[crossAxis] - arrowSize / 2;\n    // Clamp the arrow positioning so that it always is within the bounds of the anchor and the overlay\n    const arrowPositionOverlappingChild = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.clamp)(preferredArrowPosition, arrowOverlappingChildMinEdge, arrowOverlappingChildMaxEdge);\n    arrowPosition[crossAxis] = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.clamp)(arrowPositionOverlappingChild, arrowMinPosition, arrowMaxPosition);\n    return {\n        position: position,\n        maxHeight: maxHeight,\n        arrowOffsetLeft: arrowPosition.left,\n        arrowOffsetTop: arrowPosition.top,\n        placement: placementInfo.placement\n    };\n}\nfunction $edcf132a9284368a$export$b3ceb0cbf1056d98(opts) {\n    let { placement: placement, targetNode: targetNode, overlayNode: overlayNode, scrollNode: scrollNode, padding: padding, shouldFlip: shouldFlip, boundaryElement: boundaryElement, offset: offset, crossOffset: crossOffset, maxHeight: maxHeight, arrowSize: arrowSize = 0, arrowBoundaryOffset: arrowBoundaryOffset = 0 } = opts;\n    let container = overlayNode instanceof HTMLElement ? $edcf132a9284368a$var$getContainingBlock(overlayNode) : document.documentElement;\n    let isViewportContainer = container === document.documentElement;\n    const containerPositionStyle = window.getComputedStyle(container).position;\n    let isContainerPositioned = !!containerPositionStyle && containerPositionStyle !== \"static\";\n    let childOffset = isViewportContainer ? $edcf132a9284368a$var$getOffset(targetNode) : $edcf132a9284368a$var$getPosition(targetNode, container);\n    if (!isViewportContainer) {\n        let { marginTop: marginTop, marginLeft: marginLeft } = window.getComputedStyle(targetNode);\n        childOffset.top += parseInt(marginTop, 10) || 0;\n        childOffset.left += parseInt(marginLeft, 10) || 0;\n    }\n    let overlaySize = $edcf132a9284368a$var$getOffset(overlayNode);\n    let margins = $edcf132a9284368a$var$getMargins(overlayNode);\n    overlaySize.width += margins.left + margins.right;\n    overlaySize.height += margins.top + margins.bottom;\n    let scrollSize = $edcf132a9284368a$var$getScroll(scrollNode);\n    let boundaryDimensions = $edcf132a9284368a$var$getContainerDimensions(boundaryElement);\n    let containerDimensions = $edcf132a9284368a$var$getContainerDimensions(container);\n    let containerOffsetWithBoundary = boundaryElement.tagName === \"BODY\" ? $edcf132a9284368a$var$getOffset(container) : $edcf132a9284368a$var$getPosition(container, boundaryElement);\n    return $edcf132a9284368a$export$6839422d1f33cee9(placement, childOffset, overlaySize, scrollSize, margins, padding, shouldFlip, boundaryDimensions, containerDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, maxHeight, arrowSize, arrowBoundaryOffset);\n}\nfunction $edcf132a9284368a$var$getOffset(node) {\n    let { top: top, left: left, width: width, height: height } = node.getBoundingClientRect();\n    let { scrollTop: scrollTop, scrollLeft: scrollLeft, clientTop: clientTop, clientLeft: clientLeft } = document.documentElement;\n    return {\n        top: top + scrollTop - clientTop,\n        left: left + scrollLeft - clientLeft,\n        width: width,\n        height: height\n    };\n}\nfunction $edcf132a9284368a$var$getPosition(node, parent) {\n    let style = window.getComputedStyle(node);\n    let offset;\n    if (style.position === \"fixed\") {\n        let { top: top, left: left, width: width, height: height } = node.getBoundingClientRect();\n        offset = {\n            top: top,\n            left: left,\n            width: width,\n            height: height\n        };\n    } else {\n        offset = $edcf132a9284368a$var$getOffset(node);\n        let parentOffset = $edcf132a9284368a$var$getOffset(parent);\n        let parentStyle = window.getComputedStyle(parent);\n        parentOffset.top += (parseInt(parentStyle.borderTopWidth, 10) || 0) - parent.scrollTop;\n        parentOffset.left += (parseInt(parentStyle.borderLeftWidth, 10) || 0) - parent.scrollLeft;\n        offset.top -= parentOffset.top;\n        offset.left -= parentOffset.left;\n    }\n    offset.top -= parseInt(style.marginTop, 10) || 0;\n    offset.left -= parseInt(style.marginLeft, 10) || 0;\n    return offset;\n}\n// Returns the containing block of an element, which is the element that\n// this element will be positioned relative to.\n// https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block\nfunction $edcf132a9284368a$var$getContainingBlock(node) {\n    // The offsetParent of an element in most cases equals the containing block.\n    // https://w3c.github.io/csswg-drafts/cssom-view/#dom-htmlelement-offsetparent\n    let offsetParent = node.offsetParent;\n    // The offsetParent algorithm terminates at the document body,\n    // even if the body is not a containing block. Double check that\n    // and use the documentElement if so.\n    if (offsetParent && offsetParent === document.body && window.getComputedStyle(offsetParent).position === \"static\" && !$edcf132a9284368a$var$isContainingBlock(offsetParent)) offsetParent = document.documentElement;\n    // TODO(later): handle table elements?\n    // The offsetParent can be null if the element has position: fixed, or a few other cases.\n    // We have to walk up the tree manually in this case because fixed positioned elements\n    // are still positioned relative to their containing block, which is not always the viewport.\n    if (offsetParent == null) {\n        offsetParent = node.parentElement;\n        while(offsetParent && !$edcf132a9284368a$var$isContainingBlock(offsetParent))offsetParent = offsetParent.parentElement;\n    }\n    // Fall back to the viewport.\n    return offsetParent || document.documentElement;\n}\n// https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\nfunction $edcf132a9284368a$var$isContainingBlock(node) {\n    let style = window.getComputedStyle(node);\n    return style.transform !== \"none\" || /transform|perspective/.test(style.willChange) || style.filter !== \"none\" || style.contain === \"paint\" || // @ts-ignore\n    \"backdropFilter\" in style && style.backdropFilter !== \"none\" || // @ts-ignore\n    \"WebkitBackdropFilter\" in style && style.WebkitBackdropFilter !== \"none\";\n}\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nconst $dd149f63282afbbf$export$f6211563215e3b37 = new WeakMap();\nfunction $dd149f63282afbbf$export$18fc8428861184da(opts) {\n    let { triggerRef: triggerRef, isOpen: isOpen, onClose: onClose } = opts;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isOpen || onClose === null) return;\n        let onScroll = (e)=>{\n            // Ignore if scrolling an scrollable region outside the trigger's tree.\n            let target = e.target;\n            // window is not a Node and doesn't have contain, but window contains everything\n            if (!triggerRef.current || target instanceof Node && !target.contains(triggerRef.current)) return;\n            let onCloseHandler = onClose || $dd149f63282afbbf$export$f6211563215e3b37.get(triggerRef.current);\n            if (onCloseHandler) onCloseHandler();\n        };\n        window.addEventListener(\"scroll\", onScroll, true);\n        return ()=>{\n            window.removeEventListener(\"scroll\", onScroll, true);\n        };\n    }, [\n        isOpen,\n        onClose,\n        triggerRef\n    ]);\n}\n\n\n\n\n// @ts-ignore\nlet $2a41e45df1593e64$var$visualViewport = typeof document !== \"undefined\" && window.visualViewport;\nfunction $2a41e45df1593e64$export$d39e1813b3bdd0e1(props) {\n    let { direction: direction } = (0, _react_aria_i18n__WEBPACK_IMPORTED_MODULE_3__.useLocale)();\n    let { arrowSize: arrowSize = 0, targetRef: targetRef, overlayRef: overlayRef, scrollRef: scrollRef = overlayRef, placement: placement = \"bottom\", containerPadding: containerPadding = 12, shouldFlip: shouldFlip = true, boundaryElement: boundaryElement = typeof document !== \"undefined\" ? document.body : null, offset: offset = 0, crossOffset: crossOffset = 0, shouldUpdatePosition: shouldUpdatePosition = true, isOpen: isOpen = true, onClose: onClose, maxHeight: maxHeight, arrowBoundaryOffset: arrowBoundaryOffset = 0 } = props;\n    let [position, setPosition] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        position: {},\n        arrowOffsetLeft: undefined,\n        arrowOffsetTop: undefined,\n        maxHeight: undefined,\n        placement: undefined\n    });\n    let deps = [\n        shouldUpdatePosition,\n        placement,\n        overlayRef.current,\n        targetRef.current,\n        scrollRef.current,\n        containerPadding,\n        shouldFlip,\n        boundaryElement,\n        offset,\n        crossOffset,\n        isOpen,\n        direction,\n        maxHeight,\n        arrowBoundaryOffset,\n        arrowSize\n    ];\n    let updatePosition = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current || !boundaryElement) return;\n        let position = (0, $edcf132a9284368a$export$b3ceb0cbf1056d98)({\n            placement: $2a41e45df1593e64$var$translateRTL(placement, direction),\n            overlayNode: overlayRef.current,\n            targetNode: targetRef.current,\n            scrollNode: scrollRef.current,\n            padding: containerPadding,\n            shouldFlip: shouldFlip,\n            boundaryElement: boundaryElement,\n            offset: offset,\n            crossOffset: crossOffset,\n            maxHeight: maxHeight,\n            arrowSize: arrowSize,\n            arrowBoundaryOffset: arrowBoundaryOffset\n        });\n        // Modify overlay styles directly so positioning happens immediately without the need of a second render\n        // This is so we don't have to delay autoFocus scrolling or delay applying preventScroll for popovers\n        Object.keys(position.position).forEach((key)=>overlayRef.current.style[key] = position.position[key] + \"px\");\n        overlayRef.current.style.maxHeight = position.maxHeight != null ? position.maxHeight + \"px\" : undefined;\n        // Trigger a set state for a second render anyway for arrow positioning\n        setPosition(position);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, deps);\n    // Update position when anything changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.useLayoutEffect)(updatePosition, deps);\n    // Update position on window resize\n    $2a41e45df1593e64$var$useResize(updatePosition);\n    // Update position when the overlay changes size (might need to flip).\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.useResizeObserver)({\n        ref: overlayRef,\n        onResize: updatePosition\n    });\n    // Reposition the overlay and do not close on scroll while the visual viewport is resizing.\n    // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.\n    let isResizing = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.useLayoutEffect)(()=>{\n        let timeout;\n        let onResize = ()=>{\n            isResizing.current = true;\n            clearTimeout(timeout);\n            timeout = setTimeout(()=>{\n                isResizing.current = false;\n            }, 500);\n            updatePosition();\n        };\n        $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.addEventListener(\"resize\", onResize);\n        $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.addEventListener(\"scroll\", onResize);\n        return ()=>{\n            $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.removeEventListener(\"resize\", onResize);\n            $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.removeEventListener(\"scroll\", onResize);\n        };\n    }, [\n        updatePosition\n    ]);\n    let close = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!isResizing.current) onClose();\n    }, [\n        onClose,\n        isResizing\n    ]);\n    // When scrolling a parent scrollable region of the trigger (other than the body),\n    // we hide the popover. Otherwise, its position would be incorrect.\n    (0, $dd149f63282afbbf$export$18fc8428861184da)({\n        triggerRef: targetRef,\n        isOpen: isOpen,\n        onClose: onClose && close\n    });\n    return {\n        overlayProps: {\n            style: {\n                position: \"absolute\",\n                zIndex: 100000,\n                ...position.position,\n                maxHeight: position.maxHeight\n            }\n        },\n        placement: position.placement,\n        arrowProps: {\n            \"aria-hidden\": \"true\",\n            role: \"presentation\",\n            style: {\n                left: position.arrowOffsetLeft,\n                top: position.arrowOffsetTop\n            }\n        },\n        updatePosition: updatePosition\n    };\n}\nfunction $2a41e45df1593e64$var$useResize(onResize) {\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.useLayoutEffect)(()=>{\n        window.addEventListener(\"resize\", onResize, false);\n        return ()=>{\n            window.removeEventListener(\"resize\", onResize, false);\n        };\n    }, [\n        onResize\n    ]);\n}\nfunction $2a41e45df1593e64$var$translateRTL(position, direction) {\n    if (direction === \"rtl\") return position.replace(\"start\", \"right\").replace(\"end\", \"left\");\n    return position.replace(\"start\", \"left\").replace(\"end\", \"right\");\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nconst $a11501f3d1d39e6c$var$visibleOverlays = [];\nfunction $a11501f3d1d39e6c$export$ea8f71083e90600f(props, ref) {\n    let { onClose: onClose, shouldCloseOnBlur: shouldCloseOnBlur, isOpen: isOpen, isDismissable: isDismissable = false, isKeyboardDismissDisabled: isKeyboardDismissDisabled = false, shouldCloseOnInteractOutside: shouldCloseOnInteractOutside } = props;\n    // Add the overlay ref to the stack of visible overlays on mount, and remove on unmount.\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isOpen) $a11501f3d1d39e6c$var$visibleOverlays.push(ref);\n        return ()=>{\n            let index = $a11501f3d1d39e6c$var$visibleOverlays.indexOf(ref);\n            if (index >= 0) $a11501f3d1d39e6c$var$visibleOverlays.splice(index, 1);\n        };\n    }, [\n        isOpen,\n        ref\n    ]);\n    // Only hide the overlay when it is the topmost visible overlay in the stack.\n    let onHide = ()=>{\n        if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref && onClose) onClose();\n    };\n    let onInteractOutsideStart = (e)=>{\n        if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.target)) {\n            if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref) {\n                e.stopPropagation();\n                e.preventDefault();\n            }\n        }\n    };\n    let onInteractOutside = (e)=>{\n        if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.target)) {\n            if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref) {\n                e.stopPropagation();\n                e.preventDefault();\n            }\n            onHide();\n        }\n    };\n    // Handle the escape key\n    let onKeyDown = (e)=>{\n        if (e.key === \"Escape\" && !isKeyboardDismissDisabled) {\n            e.stopPropagation();\n            e.preventDefault();\n            onHide();\n        }\n    };\n    // Handle clicking outside the overlay to close it\n    (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_5__.useInteractOutside)({\n        ref: ref,\n        onInteractOutside: isDismissable && isOpen ? onInteractOutside : null,\n        onInteractOutsideStart: onInteractOutsideStart\n    });\n    let { focusWithinProps: focusWithinProps } = (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_5__.useFocusWithin)({\n        isDisabled: !shouldCloseOnBlur,\n        onBlurWithin: (e)=>{\n            // Do not close if relatedTarget is null, which means focus is lost to the body.\n            // That can happen when switching tabs, or due to a VoiceOver/Chrome bug with Control+Option+Arrow navigation.\n            // Clicking on the body to close the overlay should already be handled by useInteractOutside.\n            // https://github.com/adobe/react-spectrum/issues/4130\n            // https://github.com/adobe/react-spectrum/issues/4922\n            //\n            // If focus is moving into a child focus scope (e.g. menu inside a dialog),\n            // do not close the outer overlay. At this point, the active scope should\n            // still be the outer overlay, since blur events run before focus.\n            if (!e.relatedTarget || (0, _react_aria_focus__WEBPACK_IMPORTED_MODULE_6__.isElementInChildOfActiveScope)(e.relatedTarget)) return;\n            if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.relatedTarget)) onClose();\n        }\n    });\n    let onPointerDownUnderlay = (e)=>{\n        // fixes a firefox issue that starts text selection https://bugzilla.mozilla.org/show_bug.cgi?id=1675846\n        if (e.target === e.currentTarget) e.preventDefault();\n    };\n    return {\n        overlayProps: {\n            onKeyDown: onKeyDown,\n            ...focusWithinProps\n        },\n        underlayProps: {\n            onPointerDown: onPointerDownUnderlay\n        }\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nfunction $628037886ba31236$export$f9d5c8beee7d008d(props, state, ref) {\n    let { type: type } = props;\n    let { isOpen: isOpen } = state;\n    // Backward compatibility. Share state close function with useOverlayPosition so it can close on scroll\n    // without forcing users to pass onClose.\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (ref && ref.current) (0, $dd149f63282afbbf$export$f6211563215e3b37).set(ref.current, state.close);\n    });\n    // Aria 1.1 supports multiple values for aria-haspopup other than just menus.\n    // https://www.w3.org/TR/wai-aria-1.1/#aria-haspopup\n    // However, we only add it for menus for now because screen readers often\n    // announce it as a menu even for other values.\n    let ariaHasPopup = undefined;\n    if (type === \"menu\") ariaHasPopup = true;\n    else if (type === \"listbox\") ariaHasPopup = \"listbox\";\n    let overlayId = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.useId)();\n    return {\n        triggerProps: {\n            \"aria-haspopup\": ariaHasPopup,\n            \"aria-expanded\": isOpen,\n            \"aria-controls\": isOpen ? overlayId : null,\n            onPress: state.toggle\n        },\n        overlayProps: {\n            id: overlayId\n        }\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n// @ts-ignore\nconst $49c51c25361d4cd2$var$visualViewport = typeof document !== \"undefined\" && window.visualViewport;\n// HTML input types that do not cause the software keyboard to appear.\nconst $49c51c25361d4cd2$var$nonTextInputTypes = new Set([\n    \"checkbox\",\n    \"radio\",\n    \"range\",\n    \"color\",\n    \"file\",\n    \"image\",\n    \"button\",\n    \"submit\",\n    \"reset\"\n]);\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet $49c51c25361d4cd2$var$preventScrollCount = 0;\nlet $49c51c25361d4cd2$var$restore;\nfunction $49c51c25361d4cd2$export$ee0f7cc6afcd1c18(options = {}) {\n    let { isDisabled: isDisabled } = options;\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.useLayoutEffect)(()=>{\n        if (isDisabled) return;\n        $49c51c25361d4cd2$var$preventScrollCount++;\n        if ($49c51c25361d4cd2$var$preventScrollCount === 1) {\n            if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.isIOS)()) $49c51c25361d4cd2$var$restore = $49c51c25361d4cd2$var$preventScrollMobileSafari();\n            else $49c51c25361d4cd2$var$restore = $49c51c25361d4cd2$var$preventScrollStandard();\n        }\n        return ()=>{\n            $49c51c25361d4cd2$var$preventScrollCount--;\n            if ($49c51c25361d4cd2$var$preventScrollCount === 0) $49c51c25361d4cd2$var$restore();\n        };\n    }, [\n        isDisabled\n    ]);\n}\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction $49c51c25361d4cd2$var$preventScrollStandard() {\n    return (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.chain)($49c51c25361d4cd2$var$setStyle(document.documentElement, \"paddingRight\", `${window.innerWidth - document.documentElement.clientWidth}px`), $49c51c25361d4cd2$var$setStyle(document.documentElement, \"overflow\", \"hidden\"));\n}\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Prevent default on `touchmove` events inside a scrollable element when the scroll position is at the\n//    top or bottom. This avoids the whole page scrolling instead, but does prevent overscrolling.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction $49c51c25361d4cd2$var$preventScrollMobileSafari() {\n    let scrollable;\n    let lastY = 0;\n    let onTouchStart = (e)=>{\n        // Store the nearest scrollable parent element from the element that the user touched.\n        scrollable = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.getScrollParent)(e.target);\n        if (scrollable === document.documentElement && scrollable === document.body) return;\n        lastY = e.changedTouches[0].pageY;\n    };\n    let onTouchMove = (e)=>{\n        // Prevent scrolling the window.\n        if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n            e.preventDefault();\n            return;\n        }\n        // Prevent scrolling up when at the top and scrolling down when at the bottom\n        // of a nested scrollable area, otherwise mobile Safari will start scrolling\n        // the window instead. Unfortunately, this disables bounce scrolling when at\n        // the top but it's the best we can do.\n        let y = e.changedTouches[0].pageY;\n        let scrollTop = scrollable.scrollTop;\n        let bottom = scrollable.scrollHeight - scrollable.clientHeight;\n        if (bottom === 0) return;\n        if (scrollTop <= 0 && y > lastY || scrollTop >= bottom && y < lastY) e.preventDefault();\n        lastY = y;\n    };\n    let onTouchEnd = (e)=>{\n        let target = e.target;\n        // Apply this change if we're not already focused on the target element\n        if ($49c51c25361d4cd2$var$willOpenKeyboard(target) && target !== document.activeElement) {\n            e.preventDefault();\n            // Apply a transform to trick Safari into thinking the input is at the top of the page\n            // so it doesn't try to scroll it into view. When tapping on an input, this needs to\n            // be done before the \"focus\" event, so we have to focus the element ourselves.\n            target.style.transform = \"translateY(-2000px)\";\n            target.focus();\n            requestAnimationFrame(()=>{\n                target.style.transform = \"\";\n            });\n        }\n    };\n    let onFocus = (e)=>{\n        let target = e.target;\n        if ($49c51c25361d4cd2$var$willOpenKeyboard(target)) {\n            // Transform also needs to be applied in the focus event in cases where focus moves\n            // other than tapping on an input directly, e.g. the next/previous buttons in the\n            // software keyboard. In these cases, it seems applying the transform in the focus event\n            // is good enough, whereas when tapping an input, it must be done before the focus event. 🤷‍♂️\n            target.style.transform = \"translateY(-2000px)\";\n            requestAnimationFrame(()=>{\n                target.style.transform = \"\";\n                // This will have prevented the browser from scrolling the focused element into view,\n                // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n                if ($49c51c25361d4cd2$var$visualViewport) {\n                    if ($49c51c25361d4cd2$var$visualViewport.height < window.innerHeight) // If the keyboard is already visible, do this after one additional frame\n                    // to wait for the transform to be removed.\n                    requestAnimationFrame(()=>{\n                        $49c51c25361d4cd2$var$scrollIntoView(target);\n                    });\n                    else // Otherwise, wait for the visual viewport to resize before scrolling so we can\n                    // measure the correct position to scroll to.\n                    $49c51c25361d4cd2$var$visualViewport.addEventListener(\"resize\", ()=>$49c51c25361d4cd2$var$scrollIntoView(target), {\n                        once: true\n                    });\n                }\n            });\n        }\n    };\n    let onWindowScroll = ()=>{\n        // Last resort. If the window scrolled, scroll it back to the top.\n        // It should always be at the top because the body will have a negative margin (see below).\n        window.scrollTo(0, 0);\n    };\n    // Record the original scroll position so we can restore it.\n    // Then apply a negative margin to the body to offset it by the scroll position. This will\n    // enable us to scroll the window to the top, which is required for the rest of this to work.\n    let scrollX = window.pageXOffset;\n    let scrollY = window.pageYOffset;\n    let restoreStyles = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.chain)($49c51c25361d4cd2$var$setStyle(document.documentElement, \"paddingRight\", `${window.innerWidth - document.documentElement.clientWidth}px`), $49c51c25361d4cd2$var$setStyle(document.documentElement, \"overflow\", \"hidden\"), $49c51c25361d4cd2$var$setStyle(document.body, \"marginTop\", `-${scrollY}px`));\n    // Scroll to the top. The negative margin on the body will make this appear the same.\n    window.scrollTo(0, 0);\n    let removeEvents = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.chain)($49c51c25361d4cd2$var$addEvent(document, \"touchstart\", onTouchStart, {\n        passive: false,\n        capture: true\n    }), $49c51c25361d4cd2$var$addEvent(document, \"touchmove\", onTouchMove, {\n        passive: false,\n        capture: true\n    }), $49c51c25361d4cd2$var$addEvent(document, \"touchend\", onTouchEnd, {\n        passive: false,\n        capture: true\n    }), $49c51c25361d4cd2$var$addEvent(document, \"focus\", onFocus, true), $49c51c25361d4cd2$var$addEvent(window, \"scroll\", onWindowScroll));\n    return ()=>{\n        // Restore styles and scroll the page back to where it was.\n        restoreStyles();\n        removeEvents();\n        window.scrollTo(scrollX, scrollY);\n    };\n}\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction $49c51c25361d4cd2$var$setStyle(element, style, value) {\n    let cur = element.style[style];\n    element.style[style] = value;\n    return ()=>{\n        element.style[style] = cur;\n    };\n}\n// Adds an event listener to an element, and returns a function to remove it.\nfunction $49c51c25361d4cd2$var$addEvent(target, event, handler, options) {\n    target.addEventListener(event, handler, options);\n    return ()=>{\n        target.removeEventListener(event, handler, options);\n    };\n}\nfunction $49c51c25361d4cd2$var$scrollIntoView(target) {\n    let root = document.scrollingElement || document.documentElement;\n    while(target && target !== root){\n        // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n        let scrollable = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.getScrollParent)(target);\n        if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {\n            let scrollableTop = scrollable.getBoundingClientRect().top;\n            let targetTop = target.getBoundingClientRect().top;\n            if (targetTop > scrollableTop + target.clientHeight) scrollable.scrollTop += targetTop - scrollableTop;\n        }\n        target = scrollable.parentElement;\n    }\n}\nfunction $49c51c25361d4cd2$var$willOpenKeyboard(target) {\n    return target instanceof HTMLInputElement && !$49c51c25361d4cd2$var$nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nconst $f57aed4a881a3485$var$Context = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext(null);\nfunction $f57aed4a881a3485$export$178405afcd8c5eb(props) {\n    let { children: children } = props;\n    let parent = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($f57aed4a881a3485$var$Context);\n    let [modalCount, setModalCount] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            parent: parent,\n            modalCount: modalCount,\n            addModal () {\n                setModalCount((count)=>count + 1);\n                if (parent) parent.addModal();\n            },\n            removeModal () {\n                setModalCount((count)=>count - 1);\n                if (parent) parent.removeModal();\n            }\n        }), [\n        parent,\n        modalCount\n    ]);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($f57aed4a881a3485$var$Context.Provider, {\n        value: context\n    }, children);\n}\nfunction $f57aed4a881a3485$export$d9aaed4c3ece1bc0() {\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($f57aed4a881a3485$var$Context);\n    return {\n        modalProviderProps: {\n            \"aria-hidden\": context && context.modalCount > 0 ? true : null\n        }\n    };\n}\n/**\n * Creates a root node that will be aria-hidden if there are other modals open.\n */ function $f57aed4a881a3485$var$OverlayContainerDOM(props) {\n    let { modalProviderProps: modalProviderProps } = $f57aed4a881a3485$export$d9aaed4c3ece1bc0();\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement(\"div\", {\n        \"data-overlay-container\": true,\n        ...props,\n        ...modalProviderProps\n    });\n}\nfunction $f57aed4a881a3485$export$bf688221f59024e5(props) {\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($f57aed4a881a3485$export$178405afcd8c5eb, null, /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($f57aed4a881a3485$var$OverlayContainerDOM, props));\n}\nfunction $f57aed4a881a3485$export$b47c3594eab58386(props) {\n    let isSSR = (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_7__.useIsSSR)();\n    let { portalContainer: portalContainer = isSSR ? null : document.body, ...rest } = props;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__).useEffect(()=>{\n        if (portalContainer === null || portalContainer === void 0 ? void 0 : portalContainer.closest(\"[data-overlay-container]\")) throw new Error(\"An OverlayContainer must not be inside another container. Please change the portalContainer prop.\");\n    }, [\n        portalContainer\n    ]);\n    if (!portalContainer) return null;\n    let contents = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($f57aed4a881a3485$export$bf688221f59024e5, rest);\n    return /*#__PURE__*/ (0, react_dom__WEBPACK_IMPORTED_MODULE_1__).createPortal(contents, portalContainer);\n}\nfunction $f57aed4a881a3485$export$33ffd74ebf07f060(options) {\n    // Add aria-hidden to all parent providers on mount, and restore on unmount.\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($f57aed4a881a3485$var$Context);\n    if (!context) throw new Error(\"Modal is not contained within a provider\");\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if ((options === null || options === void 0 ? void 0 : options.isDisabled) || !context || !context.parent) return;\n        // The immediate context is from the provider containing this modal, so we only\n        // want to trigger aria-hidden on its parents not on the modal provider itself.\n        context.parent.addModal();\n        return ()=>{\n            if (context && context.parent) context.parent.removeModal();\n        };\n    }, [\n        context,\n        context.parent,\n        options === null || options === void 0 ? void 0 : options.isDisabled\n    ]);\n    return {\n        modalProps: {\n            \"data-ismodal\": !(options === null || options === void 0 ? void 0 : options.isDisabled)\n        }\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ var $a2f21f5f14f60553$exports = {};\nvar $773d5888b972f1cf$exports = {};\n$773d5888b972f1cf$exports = {\n    \"dismiss\": `\\u{62A}\\u{62C}\\u{627}\\u{647}\\u{644}`\n};\n\n\nvar $d11f19852b941573$exports = {};\n$d11f19852b941573$exports = {\n    \"dismiss\": `\\u{41E}\\u{442}\\u{445}\\u{432}\\u{44A}\\u{440}\\u{43B}\\u{44F}\\u{43D}\\u{435}`\n};\n\n\nvar $b983974c2ee1efb3$exports = {};\n$b983974c2ee1efb3$exports = {\n    \"dismiss\": `Odstranit`\n};\n\n\nvar $5809cc9d4e92de73$exports = {};\n$5809cc9d4e92de73$exports = {\n    \"dismiss\": `Luk`\n};\n\n\nvar $c68c2e4fc74398d1$exports = {};\n$c68c2e4fc74398d1$exports = {\n    \"dismiss\": `Schlie\\xdfen`\n};\n\n\nvar $0898b4c153db2b77$exports = {};\n$0898b4c153db2b77$exports = {\n    \"dismiss\": `\\u{391}\\u{3C0}\\u{3CC}\\u{3C1}\\u{3C1}\\u{3B9}\\u{3C8}\\u{3B7}`\n};\n\n\nvar $6d74810286a15183$exports = {};\n$6d74810286a15183$exports = {\n    \"dismiss\": `Dismiss`\n};\n\n\nvar $309d73dc65f78055$exports = {};\n$309d73dc65f78055$exports = {\n    \"dismiss\": `Descartar`\n};\n\n\nvar $44ad94f7205cf593$exports = {};\n$44ad94f7205cf593$exports = {\n    \"dismiss\": `L\\xf5peta`\n};\n\n\nvar $7c28f5687f0779a9$exports = {};\n$7c28f5687f0779a9$exports = {\n    \"dismiss\": `Hylk\\xe4\\xe4`\n};\n\n\nvar $e6d75df4b68bd73a$exports = {};\n$e6d75df4b68bd73a$exports = {\n    \"dismiss\": `Rejeter`\n};\n\n\nvar $87505c9dab186d0f$exports = {};\n$87505c9dab186d0f$exports = {\n    \"dismiss\": `\\u{5D4}\\u{5EA}\\u{5E2}\\u{5DC}\\u{5DD}`\n};\n\n\nvar $553439c3ffb3e492$exports = {};\n$553439c3ffb3e492$exports = {\n    \"dismiss\": `Odbaci`\n};\n\n\nvar $74cf411061b983a2$exports = {};\n$74cf411061b983a2$exports = {\n    \"dismiss\": `Elutas\\xedt\\xe1s`\n};\n\n\nvar $e933f298574dc435$exports = {};\n$e933f298574dc435$exports = {\n    \"dismiss\": `Ignora`\n};\n\n\nvar $ac91fc9fe02f71f6$exports = {};\n$ac91fc9fe02f71f6$exports = {\n    \"dismiss\": `\\u{9589}\\u{3058}\\u{308B}`\n};\n\n\nvar $52b96f86422025af$exports = {};\n$52b96f86422025af$exports = {\n    \"dismiss\": `\\u{BB34}\\u{C2DC}`\n};\n\n\nvar $c0d724c3e51dafa6$exports = {};\n$c0d724c3e51dafa6$exports = {\n    \"dismiss\": `Atmesti`\n};\n\n\nvar $c92899672a3fe72e$exports = {};\n$c92899672a3fe72e$exports = {\n    \"dismiss\": `Ner\\u{101}d\\u{12B}t`\n};\n\n\nvar $9f576b39d8e7a9d6$exports = {};\n$9f576b39d8e7a9d6$exports = {\n    \"dismiss\": `Lukk`\n};\n\n\nvar $9d025808aeec81a7$exports = {};\n$9d025808aeec81a7$exports = {\n    \"dismiss\": `Negeren`\n};\n\n\nvar $fce709921e2c0fa6$exports = {};\n$fce709921e2c0fa6$exports = {\n    \"dismiss\": `Zignoruj`\n};\n\n\nvar $2599cf0c4ab37f59$exports = {};\n$2599cf0c4ab37f59$exports = {\n    \"dismiss\": `Descartar`\n};\n\n\nvar $3c220ae7ef8a35fd$exports = {};\n$3c220ae7ef8a35fd$exports = {\n    \"dismiss\": `Dispensar`\n};\n\n\nvar $93562b5094072f54$exports = {};\n$93562b5094072f54$exports = {\n    \"dismiss\": `Revocare`\n};\n\n\nvar $cd9e2abd0d06c7b4$exports = {};\n$cd9e2abd0d06c7b4$exports = {\n    \"dismiss\": `\\u{41F}\\u{440}\\u{43E}\\u{43F}\\u{443}\\u{441}\\u{442}\\u{438}\\u{442}\\u{44C}`\n};\n\n\nvar $45375701f409adf1$exports = {};\n$45375701f409adf1$exports = {\n    \"dismiss\": `Zru\\u{161}i\\u{165}`\n};\n\n\nvar $27fab53a576de9dd$exports = {};\n$27fab53a576de9dd$exports = {\n    \"dismiss\": `Opusti`\n};\n\n\nvar $4438748d9952e7c7$exports = {};\n$4438748d9952e7c7$exports = {\n    \"dismiss\": `Odbaci`\n};\n\n\nvar $0936d7347ef4da4c$exports = {};\n$0936d7347ef4da4c$exports = {\n    \"dismiss\": `Avvisa`\n};\n\n\nvar $29700c92185d38f8$exports = {};\n$29700c92185d38f8$exports = {\n    \"dismiss\": `Kapat`\n};\n\n\nvar $662ccaf2be4c25b3$exports = {};\n$662ccaf2be4c25b3$exports = {\n    \"dismiss\": `\\u{421}\\u{43A}\\u{430}\\u{441}\\u{443}\\u{432}\\u{430}\\u{442}\\u{438}`\n};\n\n\nvar $d80a27deda7cdb3c$exports = {};\n$d80a27deda7cdb3c$exports = {\n    \"dismiss\": `\\u{53D6}\\u{6D88}`\n};\n\n\nvar $2b2734393847c884$exports = {};\n$2b2734393847c884$exports = {\n    \"dismiss\": `\\u{95DC}\\u{9589}`\n};\n\n\n$a2f21f5f14f60553$exports = {\n    \"ar-AE\": $773d5888b972f1cf$exports,\n    \"bg-BG\": $d11f19852b941573$exports,\n    \"cs-CZ\": $b983974c2ee1efb3$exports,\n    \"da-DK\": $5809cc9d4e92de73$exports,\n    \"de-DE\": $c68c2e4fc74398d1$exports,\n    \"el-GR\": $0898b4c153db2b77$exports,\n    \"en-US\": $6d74810286a15183$exports,\n    \"es-ES\": $309d73dc65f78055$exports,\n    \"et-EE\": $44ad94f7205cf593$exports,\n    \"fi-FI\": $7c28f5687f0779a9$exports,\n    \"fr-FR\": $e6d75df4b68bd73a$exports,\n    \"he-IL\": $87505c9dab186d0f$exports,\n    \"hr-HR\": $553439c3ffb3e492$exports,\n    \"hu-HU\": $74cf411061b983a2$exports,\n    \"it-IT\": $e933f298574dc435$exports,\n    \"ja-JP\": $ac91fc9fe02f71f6$exports,\n    \"ko-KR\": $52b96f86422025af$exports,\n    \"lt-LT\": $c0d724c3e51dafa6$exports,\n    \"lv-LV\": $c92899672a3fe72e$exports,\n    \"nb-NO\": $9f576b39d8e7a9d6$exports,\n    \"nl-NL\": $9d025808aeec81a7$exports,\n    \"pl-PL\": $fce709921e2c0fa6$exports,\n    \"pt-BR\": $2599cf0c4ab37f59$exports,\n    \"pt-PT\": $3c220ae7ef8a35fd$exports,\n    \"ro-RO\": $93562b5094072f54$exports,\n    \"ru-RU\": $cd9e2abd0d06c7b4$exports,\n    \"sk-SK\": $45375701f409adf1$exports,\n    \"sl-SI\": $27fab53a576de9dd$exports,\n    \"sr-SP\": $4438748d9952e7c7$exports,\n    \"sv-SE\": $0936d7347ef4da4c$exports,\n    \"tr-TR\": $29700c92185d38f8$exports,\n    \"uk-UA\": $662ccaf2be4c25b3$exports,\n    \"zh-CN\": $d80a27deda7cdb3c$exports,\n    \"zh-TW\": $2b2734393847c884$exports\n};\n\n\n\n\n\n\nfunction $86ea4cb521eb2e37$export$2317d149ed6f78c4(props) {\n    let { onDismiss: onDismiss, ...otherProps } = props;\n    let stringFormatter = (0, _react_aria_i18n__WEBPACK_IMPORTED_MODULE_3__.useLocalizedStringFormatter)((0, (/*@__PURE__*/$parcel$interopDefault($a2f21f5f14f60553$exports))));\n    let labels = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.useLabels)(otherProps, stringFormatter.format(\"dismiss\"));\n    let onClick = ()=>{\n        if (onDismiss) onDismiss();\n    };\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, _react_aria_visually_hidden__WEBPACK_IMPORTED_MODULE_8__.VisuallyHidden), null, /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement(\"button\", {\n        ...labels,\n        tabIndex: -1,\n        onClick: onClick\n    }));\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Keeps a ref count of all hidden elements. Added to when hiding an element, and\n// subtracted from when showing it again. When it reaches zero, aria-hidden is removed.\nlet $5e3802645cc19319$var$refCountMap = new WeakMap();\nlet $5e3802645cc19319$var$observerStack = [];\nfunction $5e3802645cc19319$export$1c3ebcada18427bf(targets, root = document.body) {\n    let visibleNodes = new Set(targets);\n    let hiddenNodes = new Set();\n    let walk = (root)=>{\n        // Keep live announcer and top layer elements (e.g. toasts) visible.\n        for (let element of root.querySelectorAll(\"[data-live-announcer], [data-react-aria-top-layer]\"))visibleNodes.add(element);\n        let acceptNode = (node)=>{\n            // Skip this node and its children if it is one of the target nodes, or a live announcer.\n            // Also skip children of already hidden nodes, as aria-hidden is recursive. An exception is\n            // made for elements with role=\"row\" since VoiceOver on iOS has issues hiding elements with role=\"row\".\n            // For that case we want to hide the cells inside as well (https://bugs.webkit.org/show_bug.cgi?id=222623).\n            if (visibleNodes.has(node) || hiddenNodes.has(node.parentElement) && node.parentElement.getAttribute(\"role\") !== \"row\") return NodeFilter.FILTER_REJECT;\n            // Skip this node but continue to children if one of the targets is inside the node.\n            for (let target of visibleNodes){\n                if (node.contains(target)) return NodeFilter.FILTER_SKIP;\n            }\n            return NodeFilter.FILTER_ACCEPT;\n        };\n        let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {\n            acceptNode: acceptNode\n        });\n        // TreeWalker does not include the root.\n        let acceptRoot = acceptNode(root);\n        if (acceptRoot === NodeFilter.FILTER_ACCEPT) hide(root);\n        if (acceptRoot !== NodeFilter.FILTER_REJECT) {\n            let node = walker.nextNode();\n            while(node != null){\n                hide(node);\n                node = walker.nextNode();\n            }\n        }\n    };\n    let hide = (node)=>{\n        var _refCountMap_get;\n        let refCount = (_refCountMap_get = $5e3802645cc19319$var$refCountMap.get(node)) !== null && _refCountMap_get !== void 0 ? _refCountMap_get : 0;\n        // If already aria-hidden, and the ref count is zero, then this element\n        // was already hidden and there's nothing for us to do.\n        if (node.getAttribute(\"aria-hidden\") === \"true\" && refCount === 0) return;\n        if (refCount === 0) node.setAttribute(\"aria-hidden\", \"true\");\n        hiddenNodes.add(node);\n        $5e3802645cc19319$var$refCountMap.set(node, refCount + 1);\n    };\n    // If there is already a MutationObserver listening from a previous call,\n    // disconnect it so the new on takes over.\n    if ($5e3802645cc19319$var$observerStack.length) $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1].disconnect();\n    walk(root);\n    let observer = new MutationObserver((changes)=>{\n        for (let change of changes){\n            if (change.type !== \"childList\" || change.addedNodes.length === 0) continue;\n            // If the parent element of the added nodes is not within one of the targets,\n            // and not already inside a hidden node, hide all of the new children.\n            if (![\n                ...visibleNodes,\n                ...hiddenNodes\n            ].some((node)=>node.contains(change.target))) {\n                for (let node of change.removedNodes)if (node instanceof Element) {\n                    visibleNodes.delete(node);\n                    hiddenNodes.delete(node);\n                }\n                for (let node of change.addedNodes){\n                    if ((node instanceof HTMLElement || node instanceof SVGElement) && (node.dataset.liveAnnouncer === \"true\" || node.dataset.reactAriaTopLayer === \"true\")) visibleNodes.add(node);\n                    else if (node instanceof Element) walk(node);\n                }\n            }\n        }\n    });\n    observer.observe(root, {\n        childList: true,\n        subtree: true\n    });\n    let observerWrapper = {\n        observe () {\n            observer.observe(root, {\n                childList: true,\n                subtree: true\n            });\n        },\n        disconnect () {\n            observer.disconnect();\n        }\n    };\n    $5e3802645cc19319$var$observerStack.push(observerWrapper);\n    return ()=>{\n        observer.disconnect();\n        for (let node of hiddenNodes){\n            let count = $5e3802645cc19319$var$refCountMap.get(node);\n            if (count === 1) {\n                node.removeAttribute(\"aria-hidden\");\n                $5e3802645cc19319$var$refCountMap.delete(node);\n            } else $5e3802645cc19319$var$refCountMap.set(node, count - 1);\n        }\n        // Remove this observer from the stack, and start the previous one.\n        if (observerWrapper === $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1]) {\n            $5e3802645cc19319$var$observerStack.pop();\n            if ($5e3802645cc19319$var$observerStack.length) $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1].observe();\n        } else $5e3802645cc19319$var$observerStack.splice($5e3802645cc19319$var$observerStack.indexOf(observerWrapper), 1);\n    };\n}\n\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\n\nfunction $f2f8a6077418541e$export$542a6fd13ac93354(props, state) {\n    let { triggerRef: triggerRef, popoverRef: popoverRef, isNonModal: isNonModal, isKeyboardDismissDisabled: isKeyboardDismissDisabled, ...otherProps } = props;\n    let { overlayProps: overlayProps, underlayProps: underlayProps } = (0, $a11501f3d1d39e6c$export$ea8f71083e90600f)({\n        isOpen: state.isOpen,\n        onClose: state.close,\n        shouldCloseOnBlur: true,\n        isDismissable: !isNonModal,\n        isKeyboardDismissDisabled: isKeyboardDismissDisabled\n    }, popoverRef);\n    let { overlayProps: positionProps, arrowProps: arrowProps, placement: placement } = (0, $2a41e45df1593e64$export$d39e1813b3bdd0e1)({\n        ...otherProps,\n        targetRef: triggerRef,\n        overlayRef: popoverRef,\n        isOpen: state.isOpen,\n        onClose: null\n    });\n    (0, $49c51c25361d4cd2$export$ee0f7cc6afcd1c18)({\n        isDisabled: isNonModal\n    });\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.useLayoutEffect)(()=>{\n        if (state.isOpen && !isNonModal && popoverRef.current) return (0, $5e3802645cc19319$export$1c3ebcada18427bf)([\n            popoverRef.current\n        ]);\n    }, [\n        isNonModal,\n        state.isOpen,\n        popoverRef\n    ]);\n    return {\n        popoverProps: (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.mergeProps)(overlayProps, positionProps),\n        arrowProps: arrowProps,\n        underlayProps: underlayProps,\n        placement: placement\n    };\n}\n\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\n\n\nconst $337b884510726a0d$export$a2200b96afd16271 = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext(null);\nfunction $337b884510726a0d$export$c6fdb837b070b4ff(props) {\n    let isSSR = (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_7__.useIsSSR)();\n    let { portalContainer: portalContainer = isSSR ? null : document.body, isExiting: isExiting } = props;\n    let [contain, setContain] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let contextValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            contain: contain,\n            setContain: setContain\n        }), [\n        contain,\n        setContain\n    ]);\n    if (!portalContainer) return null;\n    let contents = props.children;\n    if (!props.disableFocusManagement) contents = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, _react_aria_focus__WEBPACK_IMPORTED_MODULE_6__.FocusScope), {\n        restoreFocus: true,\n        contain: contain && !isExiting\n    }, contents);\n    contents = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($337b884510726a0d$export$a2200b96afd16271.Provider, {\n        value: contextValue\n    }, /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_5__.ClearPressResponder), null, contents));\n    return /*#__PURE__*/ (0, react_dom__WEBPACK_IMPORTED_MODULE_1__).createPortal(contents, portalContainer);\n}\nfunction $337b884510726a0d$export$14c98a7594375490() {\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($337b884510726a0d$export$a2200b96afd16271);\n    let setContain = ctx === null || ctx === void 0 ? void 0 : ctx.setContain;\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.useLayoutEffect)(()=>{\n        setContain === null || setContain === void 0 ? void 0 : setContain(true);\n    }, [\n        setContain\n    ]);\n}\n\n\n\nfunction $8ac8429251c45e4b$export$dbc0f175b25fb0fb(props, state, ref) {\n    let { overlayProps: overlayProps, underlayProps: underlayProps } = (0, $a11501f3d1d39e6c$export$ea8f71083e90600f)({\n        ...props,\n        isOpen: state.isOpen,\n        onClose: state.close\n    }, ref);\n    (0, $49c51c25361d4cd2$export$ee0f7cc6afcd1c18)({\n        isDisabled: !state.isOpen\n    });\n    (0, $337b884510726a0d$export$14c98a7594375490)();\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (state.isOpen) return (0, $5e3802645cc19319$export$1c3ebcada18427bf)([\n            ref.current\n        ]);\n    }, [\n        state.isOpen,\n        ref\n    ]);\n    return {\n        modalProps: (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.mergeProps)(overlayProps),\n        underlayProps: underlayProps\n    };\n}\n\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL292ZXJsYXlzL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdU47QUFDMkc7QUFDaE07QUFDTztBQUM0QztBQUM3STtBQUNvQjtBQUN3Qjs7O0FBR3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sV0FBVyxxREFBcUQ7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtQkFBbUIsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDbkQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQ3hDOzs7QUFHQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUssR0FBRyxLQUFLO0FBQ2hDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJLElBQUksSUFBSTtBQUNsQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJO0FBQ3RGOzs7QUFHQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUksSUFBSSxJQUFJO0FBQ2xDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDL0U7OztBQUdB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QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBLFVBQVUsMkRBQTJEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsUUFBUSw0Q0FBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlEQUFpQjtBQUN6QztBQUNBO0FBQ0E7Ozs7OztBQU0yNUI7QUFDMzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL292ZXJsYXlzL2Rpc3QvaW1wb3J0Lm1qcz80ZDIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAkazdRT3MkcmVhY3QsIHt1c2VTdGF0ZSBhcyAkazdRT3MkdXNlU3RhdGUsIHVzZUNhbGxiYWNrIGFzICRrN1FPcyR1c2VDYWxsYmFjaywgdXNlUmVmIGFzICRrN1FPcyR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkazdRT3MkdXNlRWZmZWN0LCB1c2VDb250ZXh0IGFzICRrN1FPcyR1c2VDb250ZXh0LCB1c2VNZW1vIGFzICRrN1FPcyR1c2VNZW1vfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlTGF5b3V0RWZmZWN0IGFzICRrN1FPcyR1c2VMYXlvdXRFZmZlY3QsIHVzZVJlc2l6ZU9ic2VydmVyIGFzICRrN1FPcyR1c2VSZXNpemVPYnNlcnZlciwgY2xhbXAgYXMgJGs3UU9zJGNsYW1wLCB1c2VJZCBhcyAkazdRT3MkdXNlSWQsIGlzSU9TIGFzICRrN1FPcyRpc0lPUywgY2hhaW4gYXMgJGs3UU9zJGNoYWluLCBnZXRTY3JvbGxQYXJlbnQgYXMgJGs3UU9zJGdldFNjcm9sbFBhcmVudCwgdXNlTGFiZWxzIGFzICRrN1FPcyR1c2VMYWJlbHMsIG1lcmdlUHJvcHMgYXMgJGs3UU9zJG1lcmdlUHJvcHN9IGZyb20gXCJAcmVhY3QtYXJpYS91dGlsc1wiO1xuaW1wb3J0IHt1c2VMb2NhbGUgYXMgJGs3UU9zJHVzZUxvY2FsZSwgdXNlTG9jYWxpemVkU3RyaW5nRm9ybWF0dGVyIGFzICRrN1FPcyR1c2VMb2NhbGl6ZWRTdHJpbmdGb3JtYXR0ZXJ9IGZyb20gXCJAcmVhY3QtYXJpYS9pMThuXCI7XG5pbXBvcnQge2lzRWxlbWVudEluQ2hpbGRPZkFjdGl2ZVNjb3BlIGFzICRrN1FPcyRpc0VsZW1lbnRJbkNoaWxkT2ZBY3RpdmVTY29wZSwgRm9jdXNTY29wZSBhcyAkazdRT3MkRm9jdXNTY29wZX0gZnJvbSBcIkByZWFjdC1hcmlhL2ZvY3VzXCI7XG5pbXBvcnQge3VzZUludGVyYWN0T3V0c2lkZSBhcyAkazdRT3MkdXNlSW50ZXJhY3RPdXRzaWRlLCB1c2VGb2N1c1dpdGhpbiBhcyAkazdRT3MkdXNlRm9jdXNXaXRoaW4sIENsZWFyUHJlc3NSZXNwb25kZXIgYXMgJGs3UU9zJENsZWFyUHJlc3NSZXNwb25kZXJ9IGZyb20gXCJAcmVhY3QtYXJpYS9pbnRlcmFjdGlvbnNcIjtcbmltcG9ydCAkazdRT3MkcmVhY3Rkb20gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHt1c2VJc1NTUiBhcyAkazdRT3MkdXNlSXNTU1J9IGZyb20gXCJAcmVhY3QtYXJpYS9zc3JcIjtcbmltcG9ydCB7VmlzdWFsbHlIaWRkZW4gYXMgJGs3UU9zJFZpc3VhbGx5SGlkZGVufSBmcm9tIFwiQHJlYWN0LWFyaWEvdmlzdWFsbHktaGlkZGVuXCI7XG5cblxuZnVuY3Rpb24gJHBhcmNlbCRpbnRlcm9wRGVmYXVsdChhKSB7XG4gIHJldHVybiBhICYmIGEuX19lc01vZHVsZSA/IGEuZGVmYXVsdCA6IGE7XG59XG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmNvbnN0ICRlZGNmMTMyYTkyODQzNjhhJHZhciRBWElTID0ge1xuICAgIHRvcDogXCJ0b3BcIixcbiAgICBib3R0b206IFwidG9wXCIsXG4gICAgbGVmdDogXCJsZWZ0XCIsXG4gICAgcmlnaHQ6IFwibGVmdFwiXG59O1xuY29uc3QgJGVkY2YxMzJhOTI4NDM2OGEkdmFyJEZMSVBQRURfRElSRUNUSU9OID0ge1xuICAgIHRvcDogXCJib3R0b21cIixcbiAgICBib3R0b206IFwidG9wXCIsXG4gICAgbGVmdDogXCJyaWdodFwiLFxuICAgIHJpZ2h0OiBcImxlZnRcIlxufTtcbmNvbnN0ICRlZGNmMTMyYTkyODQzNjhhJHZhciRDUk9TU19BWElTID0ge1xuICAgIHRvcDogXCJsZWZ0XCIsXG4gICAgbGVmdDogXCJ0b3BcIlxufTtcbmNvbnN0ICRlZGNmMTMyYTkyODQzNjhhJHZhciRBWElTX1NJWkUgPSB7XG4gICAgdG9wOiBcImhlaWdodFwiLFxuICAgIGxlZnQ6IFwid2lkdGhcIlxufTtcbmNvbnN0ICRlZGNmMTMyYTkyODQzNjhhJHZhciRUT1RBTF9TSVpFID0ge1xuICAgIHdpZHRoOiBcInRvdGFsV2lkdGhcIixcbiAgICBoZWlnaHQ6IFwidG90YWxIZWlnaHRcIlxufTtcbmNvbnN0ICRlZGNmMTMyYTkyODQzNjhhJHZhciRQQVJTRURfUExBQ0VNRU5UX0NBQ0hFID0ge307XG4vLyBAdHMtaWdub3JlXG5sZXQgJGVkY2YxMzJhOTI4NDM2OGEkdmFyJHZpc3VhbFZpZXdwb3J0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy52aXN1YWxWaWV3cG9ydDtcbmZ1bmN0aW9uICRlZGNmMTMyYTkyODQzNjhhJHZhciRnZXRDb250YWluZXJEaW1lbnNpb25zKGNvbnRhaW5lck5vZGUpIHtcbiAgICBsZXQgd2lkdGggPSAwLCBoZWlnaHQgPSAwLCB0b3RhbFdpZHRoID0gMCwgdG90YWxIZWlnaHQgPSAwLCB0b3AgPSAwLCBsZWZ0ID0gMDtcbiAgICBsZXQgc2Nyb2xsID0ge307XG4gICAgaWYgKGNvbnRhaW5lck5vZGUudGFnTmFtZSA9PT0gXCJCT0RZXCIpIHtcbiAgICAgICAgbGV0IGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgdG90YWxXaWR0aCA9IGRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgdG90YWxIZWlnaHQgPSBkb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgX3Zpc3VhbFZpZXdwb3J0X3dpZHRoO1xuICAgICAgICB3aWR0aCA9IChfdmlzdWFsVmlld3BvcnRfd2lkdGggPSAkZWRjZjEzMmE5Mjg0MzY4YSR2YXIkdmlzdWFsVmlld3BvcnQgPT09IG51bGwgfHwgJGVkY2YxMzJhOTI4NDM2OGEkdmFyJHZpc3VhbFZpZXdwb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAkZWRjZjEzMmE5Mjg0MzY4YSR2YXIkdmlzdWFsVmlld3BvcnQud2lkdGgpICE9PSBudWxsICYmIF92aXN1YWxWaWV3cG9ydF93aWR0aCAhPT0gdm9pZCAwID8gX3Zpc3VhbFZpZXdwb3J0X3dpZHRoIDogdG90YWxXaWR0aDtcbiAgICAgICAgdmFyIF92aXN1YWxWaWV3cG9ydF9oZWlnaHQ7XG4gICAgICAgIGhlaWdodCA9IChfdmlzdWFsVmlld3BvcnRfaGVpZ2h0ID0gJGVkY2YxMzJhOTI4NDM2OGEkdmFyJHZpc3VhbFZpZXdwb3J0ID09PSBudWxsIHx8ICRlZGNmMTMyYTkyODQzNjhhJHZhciR2aXN1YWxWaWV3cG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogJGVkY2YxMzJhOTI4NDM2OGEkdmFyJHZpc3VhbFZpZXdwb3J0LmhlaWdodCkgIT09IG51bGwgJiYgX3Zpc3VhbFZpZXdwb3J0X2hlaWdodCAhPT0gdm9pZCAwID8gX3Zpc3VhbFZpZXdwb3J0X2hlaWdodCA6IHRvdGFsSGVpZ2h0O1xuICAgICAgICBzY3JvbGwudG9wID0gZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBjb250YWluZXJOb2RlLnNjcm9sbFRvcDtcbiAgICAgICAgc2Nyb2xsLmxlZnQgPSBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBjb250YWluZXJOb2RlLnNjcm9sbExlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgKHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSA9ICRlZGNmMTMyYTkyODQzNjhhJHZhciRnZXRPZmZzZXQoY29udGFpbmVyTm9kZSkpO1xuICAgICAgICBzY3JvbGwudG9wID0gY29udGFpbmVyTm9kZS5zY3JvbGxUb3A7XG4gICAgICAgIHNjcm9sbC5sZWZ0ID0gY29udGFpbmVyTm9kZS5zY3JvbGxMZWZ0O1xuICAgICAgICB0b3RhbFdpZHRoID0gd2lkdGg7XG4gICAgICAgIHRvdGFsSGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICB0b3RhbFdpZHRoOiB0b3RhbFdpZHRoLFxuICAgICAgICB0b3RhbEhlaWdodDogdG90YWxIZWlnaHQsXG4gICAgICAgIHNjcm9sbDogc2Nyb2xsLFxuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgbGVmdDogbGVmdFxuICAgIH07XG59XG5mdW5jdGlvbiAkZWRjZjEzMmE5Mjg0MzY4YSR2YXIkZ2V0U2Nyb2xsKG5vZGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IG5vZGUuc2Nyb2xsVG9wLFxuICAgICAgICBsZWZ0OiBub2RlLnNjcm9sbExlZnQsXG4gICAgICAgIHdpZHRoOiBub2RlLnNjcm9sbFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IG5vZGUuc2Nyb2xsSGVpZ2h0XG4gICAgfTtcbn1cbmZ1bmN0aW9uICRlZGNmMTMyYTkyODQzNjhhJHZhciRnZXREZWx0YShheGlzLCBvZmZzZXQsIHNpemUsIC8vIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBib3VuZGFyeSBlbGVtZW50IHRoYXQgdGhlIHBvcG92ZXIgaXNcbi8vIHBvc2l0aW9uZWQgd2l0aGluIChtb3N0IG9mIHRoZSB0aW1lIHRoaXMgaXMgdGhlIDxib2R5PikuXG5ib3VuZGFyeURpbWVuc2lvbnMsIC8vIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBjb250YWluaW5nIGJsb2NrIGVsZW1lbnQgdGhhdCB0aGUgcG9wb3ZlciBpc1xuLy8gcG9zaXRpb25lZCByZWxhdGl2ZSB0byAoZS5nLiBwYXJlbnQgd2l0aCBwb3NpdGlvbjogcmVsYXRpdmUpLlxuLy8gVXN1YWxseSB0aGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBib3VuZGFyeSBlbGVtZW50LCBidXQgaWYgdGhlIHBvcG92ZXJcbi8vIGlzIHBvcnRhbGVkIHNvbWV3aGVyZSBvdGhlciB0aGFuIHRoZSBib2R5IGFuZCBoYXMgYW4gYW5jZXN0b3Igd2l0aFxuLy8gcG9zaXRpb246IHJlbGF0aXZlL2Fic29sdXRlLCBpdCB3aWxsIGJlIGRpZmZlcmVudC5cbmNvbnRhaW5lckRpbWVuc2lvbnMsIHBhZGRpbmcpIHtcbiAgICBsZXQgY29udGFpbmVyU2Nyb2xsID0gY29udGFpbmVyRGltZW5zaW9ucy5zY3JvbGxbYXhpc107XG4gICAgbGV0IGJvdW5kYXJ5SGVpZ2h0ID0gYm91bmRhcnlEaW1lbnNpb25zWyRlZGNmMTMyYTkyODQzNjhhJHZhciRBWElTX1NJWkVbYXhpc11dO1xuICAgIGxldCBzdGFydEVkZ2VPZmZzZXQgPSBvZmZzZXQgLSBwYWRkaW5nIC0gY29udGFpbmVyU2Nyb2xsO1xuICAgIGxldCBlbmRFZGdlT2Zmc2V0ID0gb2Zmc2V0ICsgcGFkZGluZyAtIGNvbnRhaW5lclNjcm9sbCArIHNpemU7XG4gICAgaWYgKHN0YXJ0RWRnZU9mZnNldCA8IDApIHJldHVybiAtc3RhcnRFZGdlT2Zmc2V0O1xuICAgIGVsc2UgaWYgKGVuZEVkZ2VPZmZzZXQgPiBib3VuZGFyeUhlaWdodCkgcmV0dXJuIE1hdGgubWF4KGJvdW5kYXJ5SGVpZ2h0IC0gZW5kRWRnZU9mZnNldCwgLXN0YXJ0RWRnZU9mZnNldCk7XG4gICAgZWxzZSByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uICRlZGNmMTMyYTkyODQzNjhhJHZhciRnZXRNYXJnaW5zKG5vZGUpIHtcbiAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHBhcnNlSW50KHN0eWxlLm1hcmdpblRvcCwgMTApIHx8IDAsXG4gICAgICAgIGJvdHRvbTogcGFyc2VJbnQoc3R5bGUubWFyZ2luQm90dG9tLCAxMCkgfHwgMCxcbiAgICAgICAgbGVmdDogcGFyc2VJbnQoc3R5bGUubWFyZ2luTGVmdCwgMTApIHx8IDAsXG4gICAgICAgIHJpZ2h0OiBwYXJzZUludChzdHlsZS5tYXJnaW5SaWdodCwgMTApIHx8IDBcbiAgICB9O1xufVxuZnVuY3Rpb24gJGVkY2YxMzJhOTI4NDM2OGEkdmFyJHBhcnNlUGxhY2VtZW50KGlucHV0KSB7XG4gICAgaWYgKCRlZGNmMTMyYTkyODQzNjhhJHZhciRQQVJTRURfUExBQ0VNRU5UX0NBQ0hFW2lucHV0XSkgcmV0dXJuICRlZGNmMTMyYTkyODQzNjhhJHZhciRQQVJTRURfUExBQ0VNRU5UX0NBQ0hFW2lucHV0XTtcbiAgICBsZXQgW3BsYWNlbWVudCwgY3Jvc3NQbGFjZW1lbnRdID0gaW5wdXQuc3BsaXQoXCIgXCIpO1xuICAgIGxldCBheGlzID0gJGVkY2YxMzJhOTI4NDM2OGEkdmFyJEFYSVNbcGxhY2VtZW50XSB8fCBcInJpZ2h0XCI7XG4gICAgbGV0IGNyb3NzQXhpcyA9ICRlZGNmMTMyYTkyODQzNjhhJHZhciRDUk9TU19BWElTW2F4aXNdO1xuICAgIGlmICghJGVkY2YxMzJhOTI4NDM2OGEkdmFyJEFYSVNbY3Jvc3NQbGFjZW1lbnRdKSBjcm9zc1BsYWNlbWVudCA9IFwiY2VudGVyXCI7XG4gICAgbGV0IHNpemUgPSAkZWRjZjEzMmE5Mjg0MzY4YSR2YXIkQVhJU19TSVpFW2F4aXNdO1xuICAgIGxldCBjcm9zc1NpemUgPSAkZWRjZjEzMmE5Mjg0MzY4YSR2YXIkQVhJU19TSVpFW2Nyb3NzQXhpc107XG4gICAgJGVkY2YxMzJhOTI4NDM2OGEkdmFyJFBBUlNFRF9QTEFDRU1FTlRfQ0FDSEVbaW5wdXRdID0ge1xuICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgICAgY3Jvc3NQbGFjZW1lbnQ6IGNyb3NzUGxhY2VtZW50LFxuICAgICAgICBheGlzOiBheGlzLFxuICAgICAgICBjcm9zc0F4aXM6IGNyb3NzQXhpcyxcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgY3Jvc3NTaXplOiBjcm9zc1NpemVcbiAgICB9O1xuICAgIHJldHVybiAkZWRjZjEzMmE5Mjg0MzY4YSR2YXIkUEFSU0VEX1BMQUNFTUVOVF9DQUNIRVtpbnB1dF07XG59XG5mdW5jdGlvbiAkZWRjZjEzMmE5Mjg0MzY4YSR2YXIkY29tcHV0ZVBvc2l0aW9uKGNoaWxkT2Zmc2V0LCBib3VuZGFyeURpbWVuc2lvbnMsIG92ZXJsYXlTaXplLCBwbGFjZW1lbnRJbmZvLCBvZmZzZXQsIGNyb3NzT2Zmc2V0LCBjb250YWluZXJPZmZzZXRXaXRoQm91bmRhcnksIGlzQ29udGFpbmVyUG9zaXRpb25lZCwgYXJyb3dTaXplLCBhcnJvd0JvdW5kYXJ5T2Zmc2V0KSB7XG4gICAgbGV0IHsgcGxhY2VtZW50OiBwbGFjZW1lbnQsIGNyb3NzUGxhY2VtZW50OiBjcm9zc1BsYWNlbWVudCwgYXhpczogYXhpcywgY3Jvc3NBeGlzOiBjcm9zc0F4aXMsIHNpemU6IHNpemUsIGNyb3NzU2l6ZTogY3Jvc3NTaXplIH0gPSBwbGFjZW1lbnRJbmZvO1xuICAgIGxldCBwb3NpdGlvbiA9IHt9O1xuICAgIC8vIGJ1dHRvbiBwb3NpdGlvblxuICAgIHBvc2l0aW9uW2Nyb3NzQXhpc10gPSBjaGlsZE9mZnNldFtjcm9zc0F4aXNdO1xuICAgIGlmIChjcm9zc1BsYWNlbWVudCA9PT0gXCJjZW50ZXJcIikgLy8gICsgKGJ1dHRvbiBzaXplIC8gMikgLSAob3ZlcmxheSBzaXplIC8gMilcbiAgICAvLyBhdCB0aGlzIHBvaW50IHRoZSBvdmVybGF5IGNlbnRlciBzaG91bGQgbWF0Y2ggdGhlIGJ1dHRvbiBjZW50ZXJcbiAgICBwb3NpdGlvbltjcm9zc0F4aXNdICs9IChjaGlsZE9mZnNldFtjcm9zc1NpemVdIC0gb3ZlcmxheVNpemVbY3Jvc3NTaXplXSkgLyAyO1xuICAgIGVsc2UgaWYgKGNyb3NzUGxhY2VtZW50ICE9PSBjcm9zc0F4aXMpIC8vICArIChidXR0b24gc2l6ZSkgLSAob3ZlcmxheSBzaXplKVxuICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIG92ZXJsYXkgYm90dG9tIHNob3VsZCBtYXRjaCB0aGUgYnV0dG9uIGJvdHRvbVxuICAgIHBvc2l0aW9uW2Nyb3NzQXhpc10gKz0gY2hpbGRPZmZzZXRbY3Jvc3NTaXplXSAtIG92ZXJsYXlTaXplW2Nyb3NzU2l6ZV07XG4gICAgIC8qIGVsc2Uge1xuICAgIHRoZSBvdmVybGF5IHRvcCBzaG91bGQgbWF0Y2ggdGhlIGJ1dHRvbiB0b3BcbiAgfSAqLyBcbiAgICAvLyBhZGQgdGhlIGNyb3NzT2Zmc2V0IGZyb20gcHJvcHNcbiAgICBwb3NpdGlvbltjcm9zc0F4aXNdICs9IGNyb3NzT2Zmc2V0O1xuICAgIC8vIG92ZXJsYXkgdG9wIG92ZXJsYXBwaW5nIGFycm93IHdpdGggYnV0dG9uIGJvdHRvbVxuICAgIGNvbnN0IG1pblBvc2l0aW9uID0gY2hpbGRPZmZzZXRbY3Jvc3NBeGlzXSAtIG92ZXJsYXlTaXplW2Nyb3NzU2l6ZV0gKyBhcnJvd1NpemUgKyBhcnJvd0JvdW5kYXJ5T2Zmc2V0O1xuICAgIC8vIG92ZXJsYXkgYm90dG9tIG92ZXJsYXBwaW5nIGFycm93IHdpdGggYnV0dG9uIHRvcFxuICAgIGNvbnN0IG1heFBvc2l0aW9uID0gY2hpbGRPZmZzZXRbY3Jvc3NBeGlzXSArIGNoaWxkT2Zmc2V0W2Nyb3NzU2l6ZV0gLSBhcnJvd1NpemUgLSBhcnJvd0JvdW5kYXJ5T2Zmc2V0O1xuICAgIHBvc2l0aW9uW2Nyb3NzQXhpc10gPSAoMCwgJGs3UU9zJGNsYW1wKShwb3NpdGlvbltjcm9zc0F4aXNdLCBtaW5Qb3NpdGlvbiwgbWF4UG9zaXRpb24pO1xuICAgIC8vIEZsb29yIHRoZXNlIHNvIHRoZSBwb3NpdGlvbiBpc24ndCBwbGFjZWQgb24gYSBwYXJ0aWFsIHBpeGVsLCBvbmx5IHdob2xlIHBpeGVscy4gU2hvdWxkbid0IG1hdHRlciBpZiBpdCB3YXMgZmxvb3JlZCBvciBjZWlsZWQsIHNvIGNob3NlIG9uZS5cbiAgICBpZiAocGxhY2VtZW50ID09PSBheGlzKSB7XG4gICAgICAgIC8vIElmIHRoZSBjb250YWluZXIgaXMgcG9zaXRpb25lZCAobm9uLXN0YXRpYyksIHRoZW4gd2UgdXNlIHRoZSBjb250YWluZXIncyBhY3R1YWxcbiAgICAgICAgLy8gaGVpZ2h0LCBhcyBgYm90dG9tYCB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMgaGVpZ2h0LiAgQnV0IGlmIHRoZSBjb250YWluZXIgaXMgc3RhdGljLFxuICAgICAgICAvLyB0aGVuIGl0IGNhbiBvbmx5IGJlIHRoZSBgZG9jdW1lbnQuYm9keWAsIGFuZCBgYm90dG9tYCB3aWxsIGJlIHJlbGF0aXZlIHRvIF9pdHNfXG4gICAgICAgIC8vIGNvbnRhaW5lciwgd2hpY2ggc2hvdWxkIGJlIGFzIGxhcmdlIGFzIGJvdW5kYXJ5RGltZW5zaW9ucy5cbiAgICAgICAgY29uc3QgY29udGFpbmVySGVpZ2h0ID0gaXNDb250YWluZXJQb3NpdGlvbmVkID8gY29udGFpbmVyT2Zmc2V0V2l0aEJvdW5kYXJ5W3NpemVdIDogYm91bmRhcnlEaW1lbnNpb25zWyRlZGNmMTMyYTkyODQzNjhhJHZhciRUT1RBTF9TSVpFW3NpemVdXTtcbiAgICAgICAgcG9zaXRpb25bJGVkY2YxMzJhOTI4NDM2OGEkdmFyJEZMSVBQRURfRElSRUNUSU9OW2F4aXNdXSA9IE1hdGguZmxvb3IoY29udGFpbmVySGVpZ2h0IC0gY2hpbGRPZmZzZXRbYXhpc10gKyBvZmZzZXQpO1xuICAgIH0gZWxzZSBwb3NpdGlvbltheGlzXSA9IE1hdGguZmxvb3IoY2hpbGRPZmZzZXRbYXhpc10gKyBjaGlsZE9mZnNldFtzaXplXSArIG9mZnNldCk7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xufVxuZnVuY3Rpb24gJGVkY2YxMzJhOTI4NDM2OGEkdmFyJGdldE1heEhlaWdodChwb3NpdGlvbiwgYm91bmRhcnlEaW1lbnNpb25zLCBjb250YWluZXJPZmZzZXRXaXRoQm91bmRhcnksIGNoaWxkT2Zmc2V0LCBtYXJnaW5zLCBwYWRkaW5nKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uLnRvcCAhPSBudWxsID8gTWF0aC5tYXgoMCwgYm91bmRhcnlEaW1lbnNpb25zLmhlaWdodCArIGJvdW5kYXJ5RGltZW5zaW9ucy50b3AgKyBib3VuZGFyeURpbWVuc2lvbnMuc2Nyb2xsLnRvcCAvLyB0aGlzIGlzIHRoZSBib3R0b20gb2YgdGhlIGJvdW5kYXJ5XG4gICAgIC0gKGNvbnRhaW5lck9mZnNldFdpdGhCb3VuZGFyeS50b3AgKyBwb3NpdGlvbi50b3AgLy8gdGhpcyBpcyB0aGUgdG9wIG9mIHRoZSBvdmVybGF5XG4gICAgKSAtIChtYXJnaW5zLnRvcCArIG1hcmdpbnMuYm90dG9tICsgcGFkZGluZyAvLyBzYXZlIGFkZGl0aW9uYWwgc3BhY2UgZm9yIG1hcmdpbiBhbmQgcGFkZGluZ1xuICAgICkpIDogTWF0aC5tYXgoMCwgY2hpbGRPZmZzZXQudG9wICsgY29udGFpbmVyT2Zmc2V0V2l0aEJvdW5kYXJ5LnRvcCAvLyB0aGlzIGlzIHRoZSB0b3Agb2YgdGhlIHRyaWdnZXJcbiAgICAgLSAoYm91bmRhcnlEaW1lbnNpb25zLnRvcCArIGJvdW5kYXJ5RGltZW5zaW9ucy5zY3JvbGwudG9wIC8vIHRoaXMgaXMgdGhlIHRvcCBvZiB0aGUgYm91bmRhcnlcbiAgICApIC0gKG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b20gKyBwYWRkaW5nIC8vIHNhdmUgYWRkaXRpb25hbCBzcGFjZSBmb3IgbWFyZ2luIGFuZCBwYWRkaW5nXG4gICAgKSk7XG59XG5mdW5jdGlvbiAkZWRjZjEzMmE5Mjg0MzY4YSR2YXIkZ2V0QXZhaWxhYmxlU3BhY2UoYm91bmRhcnlEaW1lbnNpb25zLCBjb250YWluZXJPZmZzZXRXaXRoQm91bmRhcnksIGNoaWxkT2Zmc2V0LCBtYXJnaW5zLCBwYWRkaW5nLCBwbGFjZW1lbnRJbmZvKSB7XG4gICAgbGV0IHsgcGxhY2VtZW50OiBwbGFjZW1lbnQsIGF4aXM6IGF4aXMsIHNpemU6IHNpemUgfSA9IHBsYWNlbWVudEluZm87XG4gICAgaWYgKHBsYWNlbWVudCA9PT0gYXhpcykgcmV0dXJuIE1hdGgubWF4KDAsIGNoaWxkT2Zmc2V0W2F4aXNdIC0gYm91bmRhcnlEaW1lbnNpb25zW2F4aXNdIC0gYm91bmRhcnlEaW1lbnNpb25zLnNjcm9sbFtheGlzXSArIGNvbnRhaW5lck9mZnNldFdpdGhCb3VuZGFyeVtheGlzXSAtIG1hcmdpbnNbYXhpc10gLSBtYXJnaW5zWyRlZGNmMTMyYTkyODQzNjhhJHZhciRGTElQUEVEX0RJUkVDVElPTltheGlzXV0gLSBwYWRkaW5nKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgYm91bmRhcnlEaW1lbnNpb25zW3NpemVdICsgYm91bmRhcnlEaW1lbnNpb25zW2F4aXNdICsgYm91bmRhcnlEaW1lbnNpb25zLnNjcm9sbFtheGlzXSAtIGNvbnRhaW5lck9mZnNldFdpdGhCb3VuZGFyeVtheGlzXSAtIGNoaWxkT2Zmc2V0W2F4aXNdIC0gY2hpbGRPZmZzZXRbc2l6ZV0gLSBtYXJnaW5zW2F4aXNdIC0gbWFyZ2luc1skZWRjZjEzMmE5Mjg0MzY4YSR2YXIkRkxJUFBFRF9ESVJFQ1RJT05bYXhpc11dIC0gcGFkZGluZyk7XG59XG5mdW5jdGlvbiAkZWRjZjEzMmE5Mjg0MzY4YSRleHBvcnQkNjgzOTQyMmQxZjMzY2VlOShwbGFjZW1lbnRJbnB1dCwgY2hpbGRPZmZzZXQsIG92ZXJsYXlTaXplLCBzY3JvbGxTaXplLCBtYXJnaW5zLCBwYWRkaW5nLCBmbGlwLCBib3VuZGFyeURpbWVuc2lvbnMsIGNvbnRhaW5lckRpbWVuc2lvbnMsIGNvbnRhaW5lck9mZnNldFdpdGhCb3VuZGFyeSwgb2Zmc2V0LCBjcm9zc09mZnNldCwgaXNDb250YWluZXJQb3NpdGlvbmVkLCB1c2VyU2V0TWF4SGVpZ2h0LCBhcnJvd1NpemUsIGFycm93Qm91bmRhcnlPZmZzZXQpIHtcbiAgICBsZXQgcGxhY2VtZW50SW5mbyA9ICRlZGNmMTMyYTkyODQzNjhhJHZhciRwYXJzZVBsYWNlbWVudChwbGFjZW1lbnRJbnB1dCk7XG4gICAgbGV0IHsgc2l6ZTogc2l6ZSwgY3Jvc3NBeGlzOiBjcm9zc0F4aXMsIGNyb3NzU2l6ZTogY3Jvc3NTaXplLCBwbGFjZW1lbnQ6IHBsYWNlbWVudCwgY3Jvc3NQbGFjZW1lbnQ6IGNyb3NzUGxhY2VtZW50IH0gPSBwbGFjZW1lbnRJbmZvO1xuICAgIGxldCBwb3NpdGlvbiA9ICRlZGNmMTMyYTkyODQzNjhhJHZhciRjb21wdXRlUG9zaXRpb24oY2hpbGRPZmZzZXQsIGJvdW5kYXJ5RGltZW5zaW9ucywgb3ZlcmxheVNpemUsIHBsYWNlbWVudEluZm8sIG9mZnNldCwgY3Jvc3NPZmZzZXQsIGNvbnRhaW5lck9mZnNldFdpdGhCb3VuZGFyeSwgaXNDb250YWluZXJQb3NpdGlvbmVkLCBhcnJvd1NpemUsIGFycm93Qm91bmRhcnlPZmZzZXQpO1xuICAgIGxldCBub3JtYWxpemVkT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIGxldCBzcGFjZSA9ICRlZGNmMTMyYTkyODQzNjhhJHZhciRnZXRBdmFpbGFibGVTcGFjZShib3VuZGFyeURpbWVuc2lvbnMsIGNvbnRhaW5lck9mZnNldFdpdGhCb3VuZGFyeSwgY2hpbGRPZmZzZXQsIG1hcmdpbnMsIHBhZGRpbmcgKyBvZmZzZXQsIHBsYWNlbWVudEluZm8pO1xuICAgIC8vIENoZWNrIGlmIHRoZSBzY3JvbGwgc2l6ZSBvZiB0aGUgb3ZlcmxheSBpcyBncmVhdGVyIHRoYW4gdGhlIGF2YWlsYWJsZSBzcGFjZSB0byBkZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBmbGlwXG4gICAgaWYgKGZsaXAgJiYgc2Nyb2xsU2l6ZVtzaXplXSA+IHNwYWNlKSB7XG4gICAgICAgIGxldCBmbGlwcGVkUGxhY2VtZW50SW5mbyA9ICRlZGNmMTMyYTkyODQzNjhhJHZhciRwYXJzZVBsYWNlbWVudChgJHskZWRjZjEzMmE5Mjg0MzY4YSR2YXIkRkxJUFBFRF9ESVJFQ1RJT05bcGxhY2VtZW50XX0gJHtjcm9zc1BsYWNlbWVudH1gKTtcbiAgICAgICAgbGV0IGZsaXBwZWRQb3NpdGlvbiA9ICRlZGNmMTMyYTkyODQzNjhhJHZhciRjb21wdXRlUG9zaXRpb24oY2hpbGRPZmZzZXQsIGJvdW5kYXJ5RGltZW5zaW9ucywgb3ZlcmxheVNpemUsIGZsaXBwZWRQbGFjZW1lbnRJbmZvLCBvZmZzZXQsIGNyb3NzT2Zmc2V0LCBjb250YWluZXJPZmZzZXRXaXRoQm91bmRhcnksIGlzQ29udGFpbmVyUG9zaXRpb25lZCwgYXJyb3dTaXplLCBhcnJvd0JvdW5kYXJ5T2Zmc2V0KTtcbiAgICAgICAgbGV0IGZsaXBwZWRTcGFjZSA9ICRlZGNmMTMyYTkyODQzNjhhJHZhciRnZXRBdmFpbGFibGVTcGFjZShib3VuZGFyeURpbWVuc2lvbnMsIGNvbnRhaW5lck9mZnNldFdpdGhCb3VuZGFyeSwgY2hpbGRPZmZzZXQsIG1hcmdpbnMsIHBhZGRpbmcgKyBvZmZzZXQsIGZsaXBwZWRQbGFjZW1lbnRJbmZvKTtcbiAgICAgICAgLy8gSWYgdGhlIGF2YWlsYWJsZSBzcGFjZSBmb3IgdGhlIGZsaXBwZWQgcG9zaXRpb24gaXMgZ3JlYXRlciB0aGFuIHRoZSBvcmlnaW5hbCBhdmFpbGFibGUgc3BhY2UsIGZsaXAuXG4gICAgICAgIGlmIChmbGlwcGVkU3BhY2UgPiBzcGFjZSkge1xuICAgICAgICAgICAgcGxhY2VtZW50SW5mbyA9IGZsaXBwZWRQbGFjZW1lbnRJbmZvO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBmbGlwcGVkUG9zaXRpb247XG4gICAgICAgICAgICBub3JtYWxpemVkT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBkZWx0YSA9ICRlZGNmMTMyYTkyODQzNjhhJHZhciRnZXREZWx0YShjcm9zc0F4aXMsIHBvc2l0aW9uW2Nyb3NzQXhpc10sIG92ZXJsYXlTaXplW2Nyb3NzU2l6ZV0sIGJvdW5kYXJ5RGltZW5zaW9ucywgY29udGFpbmVyRGltZW5zaW9ucywgcGFkZGluZyk7XG4gICAgcG9zaXRpb25bY3Jvc3NBeGlzXSArPSBkZWx0YTtcbiAgICBsZXQgbWF4SGVpZ2h0ID0gJGVkY2YxMzJhOTI4NDM2OGEkdmFyJGdldE1heEhlaWdodChwb3NpdGlvbiwgYm91bmRhcnlEaW1lbnNpb25zLCBjb250YWluZXJPZmZzZXRXaXRoQm91bmRhcnksIGNoaWxkT2Zmc2V0LCBtYXJnaW5zLCBwYWRkaW5nKTtcbiAgICBpZiAodXNlclNldE1heEhlaWdodCAmJiB1c2VyU2V0TWF4SGVpZ2h0IDwgbWF4SGVpZ2h0KSBtYXhIZWlnaHQgPSB1c2VyU2V0TWF4SGVpZ2h0O1xuICAgIG92ZXJsYXlTaXplLmhlaWdodCA9IE1hdGgubWluKG92ZXJsYXlTaXplLmhlaWdodCwgbWF4SGVpZ2h0KTtcbiAgICBwb3NpdGlvbiA9ICRlZGNmMTMyYTkyODQzNjhhJHZhciRjb21wdXRlUG9zaXRpb24oY2hpbGRPZmZzZXQsIGJvdW5kYXJ5RGltZW5zaW9ucywgb3ZlcmxheVNpemUsIHBsYWNlbWVudEluZm8sIG5vcm1hbGl6ZWRPZmZzZXQsIGNyb3NzT2Zmc2V0LCBjb250YWluZXJPZmZzZXRXaXRoQm91bmRhcnksIGlzQ29udGFpbmVyUG9zaXRpb25lZCwgYXJyb3dTaXplLCBhcnJvd0JvdW5kYXJ5T2Zmc2V0KTtcbiAgICBkZWx0YSA9ICRlZGNmMTMyYTkyODQzNjhhJHZhciRnZXREZWx0YShjcm9zc0F4aXMsIHBvc2l0aW9uW2Nyb3NzQXhpc10sIG92ZXJsYXlTaXplW2Nyb3NzU2l6ZV0sIGJvdW5kYXJ5RGltZW5zaW9ucywgY29udGFpbmVyRGltZW5zaW9ucywgcGFkZGluZyk7XG4gICAgcG9zaXRpb25bY3Jvc3NBeGlzXSArPSBkZWx0YTtcbiAgICBsZXQgYXJyb3dQb3NpdGlvbiA9IHt9O1xuICAgIC8vIEFsbCB2YWx1ZXMgYXJlIHRyYW5zZm9ybWVkIHNvIHRoYXQgMCBpcyBhdCB0aGUgdG9wL2xlZnQgb2YgdGhlIG92ZXJsYXkgZGVwZW5kaW5nIG9uIHRoZSBvcmllbnRhdGlvblxuICAgIC8vIFByZWZlciB0aGUgYXJyb3cgYmVpbmcgaW4gdGhlIGNlbnRlciBvZiB0aGUgdHJpZ2dlci9vdmVybGF5IGFuY2hvciBlbGVtZW50XG4gICAgbGV0IHByZWZlcnJlZEFycm93UG9zaXRpb24gPSBjaGlsZE9mZnNldFtjcm9zc0F4aXNdICsgLjUgKiBjaGlsZE9mZnNldFtjcm9zc1NpemVdIC0gb3ZlcmxheVNpemVbY3Jvc3NBeGlzXTtcbiAgICAvLyBNaW4vTWF4IHBvc2l0aW9uIGxpbWl0cyBmb3IgdGhlIGFycm93IHdpdGggcmVzcGVjdCB0byB0aGUgb3ZlcmxheVxuICAgIGNvbnN0IGFycm93TWluUG9zaXRpb24gPSBhcnJvd1NpemUgLyAyICsgYXJyb3dCb3VuZGFyeU9mZnNldDtcbiAgICBjb25zdCBhcnJvd01heFBvc2l0aW9uID0gb3ZlcmxheVNpemVbY3Jvc3NTaXplXSAtIGFycm93U2l6ZSAvIDIgLSBhcnJvd0JvdW5kYXJ5T2Zmc2V0O1xuICAgIC8vIE1pbi9NYXggcG9zaXRpb24gbGltaXRzIGZvciB0aGUgYXJyb3cgd2l0aCByZXNwZWN0IHRvIHRoZSB0cmlnZ2VyL292ZXJsYXkgYW5jaG9yIGVsZW1lbnRcbiAgICBjb25zdCBhcnJvd092ZXJsYXBwaW5nQ2hpbGRNaW5FZGdlID0gY2hpbGRPZmZzZXRbY3Jvc3NBeGlzXSAtIG92ZXJsYXlTaXplW2Nyb3NzQXhpc10gKyBhcnJvd1NpemUgLyAyO1xuICAgIGNvbnN0IGFycm93T3ZlcmxhcHBpbmdDaGlsZE1heEVkZ2UgPSBjaGlsZE9mZnNldFtjcm9zc0F4aXNdICsgY2hpbGRPZmZzZXRbY3Jvc3NTaXplXSAtIG92ZXJsYXlTaXplW2Nyb3NzQXhpc10gLSBhcnJvd1NpemUgLyAyO1xuICAgIC8vIENsYW1wIHRoZSBhcnJvdyBwb3NpdGlvbmluZyBzbyB0aGF0IGl0IGFsd2F5cyBpcyB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgYW5jaG9yIGFuZCB0aGUgb3ZlcmxheVxuICAgIGNvbnN0IGFycm93UG9zaXRpb25PdmVybGFwcGluZ0NoaWxkID0gKDAsICRrN1FPcyRjbGFtcCkocHJlZmVycmVkQXJyb3dQb3NpdGlvbiwgYXJyb3dPdmVybGFwcGluZ0NoaWxkTWluRWRnZSwgYXJyb3dPdmVybGFwcGluZ0NoaWxkTWF4RWRnZSk7XG4gICAgYXJyb3dQb3NpdGlvbltjcm9zc0F4aXNdID0gKDAsICRrN1FPcyRjbGFtcCkoYXJyb3dQb3NpdGlvbk92ZXJsYXBwaW5nQ2hpbGQsIGFycm93TWluUG9zaXRpb24sIGFycm93TWF4UG9zaXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQsXG4gICAgICAgIGFycm93T2Zmc2V0TGVmdDogYXJyb3dQb3NpdGlvbi5sZWZ0LFxuICAgICAgICBhcnJvd09mZnNldFRvcDogYXJyb3dQb3NpdGlvbi50b3AsXG4gICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50SW5mby5wbGFjZW1lbnRcbiAgICB9O1xufVxuZnVuY3Rpb24gJGVkY2YxMzJhOTI4NDM2OGEkZXhwb3J0JGIzY2ViMGNiZjEwNTZkOTgob3B0cykge1xuICAgIGxldCB7IHBsYWNlbWVudDogcGxhY2VtZW50LCB0YXJnZXROb2RlOiB0YXJnZXROb2RlLCBvdmVybGF5Tm9kZTogb3ZlcmxheU5vZGUsIHNjcm9sbE5vZGU6IHNjcm9sbE5vZGUsIHBhZGRpbmc6IHBhZGRpbmcsIHNob3VsZEZsaXA6IHNob3VsZEZsaXAsIGJvdW5kYXJ5RWxlbWVudDogYm91bmRhcnlFbGVtZW50LCBvZmZzZXQ6IG9mZnNldCwgY3Jvc3NPZmZzZXQ6IGNyb3NzT2Zmc2V0LCBtYXhIZWlnaHQ6IG1heEhlaWdodCwgYXJyb3dTaXplOiBhcnJvd1NpemUgPSAwLCBhcnJvd0JvdW5kYXJ5T2Zmc2V0OiBhcnJvd0JvdW5kYXJ5T2Zmc2V0ID0gMCB9ID0gb3B0cztcbiAgICBsZXQgY29udGFpbmVyID0gb3ZlcmxheU5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/ICRlZGNmMTMyYTkyODQzNjhhJHZhciRnZXRDb250YWluaW5nQmxvY2sob3ZlcmxheU5vZGUpIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIGxldCBpc1ZpZXdwb3J0Q29udGFpbmVyID0gY29udGFpbmVyID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgY29uc3QgY29udGFpbmVyUG9zaXRpb25TdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcikucG9zaXRpb247XG4gICAgbGV0IGlzQ29udGFpbmVyUG9zaXRpb25lZCA9ICEhY29udGFpbmVyUG9zaXRpb25TdHlsZSAmJiBjb250YWluZXJQb3NpdGlvblN0eWxlICE9PSBcInN0YXRpY1wiO1xuICAgIGxldCBjaGlsZE9mZnNldCA9IGlzVmlld3BvcnRDb250YWluZXIgPyAkZWRjZjEzMmE5Mjg0MzY4YSR2YXIkZ2V0T2Zmc2V0KHRhcmdldE5vZGUpIDogJGVkY2YxMzJhOTI4NDM2OGEkdmFyJGdldFBvc2l0aW9uKHRhcmdldE5vZGUsIGNvbnRhaW5lcik7XG4gICAgaWYgKCFpc1ZpZXdwb3J0Q29udGFpbmVyKSB7XG4gICAgICAgIGxldCB7IG1hcmdpblRvcDogbWFyZ2luVG9wLCBtYXJnaW5MZWZ0OiBtYXJnaW5MZWZ0IH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXROb2RlKTtcbiAgICAgICAgY2hpbGRPZmZzZXQudG9wICs9IHBhcnNlSW50KG1hcmdpblRvcCwgMTApIHx8IDA7XG4gICAgICAgIGNoaWxkT2Zmc2V0LmxlZnQgKz0gcGFyc2VJbnQobWFyZ2luTGVmdCwgMTApIHx8IDA7XG4gICAgfVxuICAgIGxldCBvdmVybGF5U2l6ZSA9ICRlZGNmMTMyYTkyODQzNjhhJHZhciRnZXRPZmZzZXQob3ZlcmxheU5vZGUpO1xuICAgIGxldCBtYXJnaW5zID0gJGVkY2YxMzJhOTI4NDM2OGEkdmFyJGdldE1hcmdpbnMob3ZlcmxheU5vZGUpO1xuICAgIG92ZXJsYXlTaXplLndpZHRoICs9IG1hcmdpbnMubGVmdCArIG1hcmdpbnMucmlnaHQ7XG4gICAgb3ZlcmxheVNpemUuaGVpZ2h0ICs9IG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b207XG4gICAgbGV0IHNjcm9sbFNpemUgPSAkZWRjZjEzMmE5Mjg0MzY4YSR2YXIkZ2V0U2Nyb2xsKHNjcm9sbE5vZGUpO1xuICAgIGxldCBib3VuZGFyeURpbWVuc2lvbnMgPSAkZWRjZjEzMmE5Mjg0MzY4YSR2YXIkZ2V0Q29udGFpbmVyRGltZW5zaW9ucyhib3VuZGFyeUVsZW1lbnQpO1xuICAgIGxldCBjb250YWluZXJEaW1lbnNpb25zID0gJGVkY2YxMzJhOTI4NDM2OGEkdmFyJGdldENvbnRhaW5lckRpbWVuc2lvbnMoY29udGFpbmVyKTtcbiAgICBsZXQgY29udGFpbmVyT2Zmc2V0V2l0aEJvdW5kYXJ5ID0gYm91bmRhcnlFbGVtZW50LnRhZ05hbWUgPT09IFwiQk9EWVwiID8gJGVkY2YxMzJhOTI4NDM2OGEkdmFyJGdldE9mZnNldChjb250YWluZXIpIDogJGVkY2YxMzJhOTI4NDM2OGEkdmFyJGdldFBvc2l0aW9uKGNvbnRhaW5lciwgYm91bmRhcnlFbGVtZW50KTtcbiAgICByZXR1cm4gJGVkY2YxMzJhOTI4NDM2OGEkZXhwb3J0JDY4Mzk0MjJkMWYzM2NlZTkocGxhY2VtZW50LCBjaGlsZE9mZnNldCwgb3ZlcmxheVNpemUsIHNjcm9sbFNpemUsIG1hcmdpbnMsIHBhZGRpbmcsIHNob3VsZEZsaXAsIGJvdW5kYXJ5RGltZW5zaW9ucywgY29udGFpbmVyRGltZW5zaW9ucywgY29udGFpbmVyT2Zmc2V0V2l0aEJvdW5kYXJ5LCBvZmZzZXQsIGNyb3NzT2Zmc2V0LCBpc0NvbnRhaW5lclBvc2l0aW9uZWQsIG1heEhlaWdodCwgYXJyb3dTaXplLCBhcnJvd0JvdW5kYXJ5T2Zmc2V0KTtcbn1cbmZ1bmN0aW9uICRlZGNmMTMyYTkyODQzNjhhJHZhciRnZXRPZmZzZXQobm9kZSkge1xuICAgIGxldCB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCB7IHNjcm9sbFRvcDogc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LCBjbGllbnRUb3A6IGNsaWVudFRvcCwgY2xpZW50TGVmdDogY2xpZW50TGVmdCB9ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdG9wICsgc2Nyb2xsVG9wIC0gY2xpZW50VG9wLFxuICAgICAgICBsZWZ0OiBsZWZ0ICsgc2Nyb2xsTGVmdCAtIGNsaWVudExlZnQsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xufVxuZnVuY3Rpb24gJGVkY2YxMzJhOTI4NDM2OGEkdmFyJGdldFBvc2l0aW9uKG5vZGUsIHBhcmVudCkge1xuICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGxldCBvZmZzZXQ7XG4gICAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSBcImZpeGVkXCIpIHtcbiAgICAgICAgbGV0IHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIG9mZnNldCA9IHtcbiAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gJGVkY2YxMzJhOTI4NDM2OGEkdmFyJGdldE9mZnNldChub2RlKTtcbiAgICAgICAgbGV0IHBhcmVudE9mZnNldCA9ICRlZGNmMTMyYTkyODQzNjhhJHZhciRnZXRPZmZzZXQocGFyZW50KTtcbiAgICAgICAgbGV0IHBhcmVudFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50KTtcbiAgICAgICAgcGFyZW50T2Zmc2V0LnRvcCArPSAocGFyc2VJbnQocGFyZW50U3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKSB8fCAwKSAtIHBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgIHBhcmVudE9mZnNldC5sZWZ0ICs9IChwYXJzZUludChwYXJlbnRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSB8fCAwKSAtIHBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgICBvZmZzZXQudG9wIC09IHBhcmVudE9mZnNldC50b3A7XG4gICAgICAgIG9mZnNldC5sZWZ0IC09IHBhcmVudE9mZnNldC5sZWZ0O1xuICAgIH1cbiAgICBvZmZzZXQudG9wIC09IHBhcnNlSW50KHN0eWxlLm1hcmdpblRvcCwgMTApIHx8IDA7XG4gICAgb2Zmc2V0LmxlZnQgLT0gcGFyc2VJbnQoc3R5bGUubWFyZ2luTGVmdCwgMTApIHx8IDA7XG4gICAgcmV0dXJuIG9mZnNldDtcbn1cbi8vIFJldHVybnMgdGhlIGNvbnRhaW5pbmcgYmxvY2sgb2YgYW4gZWxlbWVudCwgd2hpY2ggaXMgdGhlIGVsZW1lbnQgdGhhdFxuLy8gdGhpcyBlbGVtZW50IHdpbGwgYmUgcG9zaXRpb25lZCByZWxhdGl2ZSB0by5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrXG5mdW5jdGlvbiAkZWRjZjEzMmE5Mjg0MzY4YSR2YXIkZ2V0Q29udGFpbmluZ0Jsb2NrKG5vZGUpIHtcbiAgICAvLyBUaGUgb2Zmc2V0UGFyZW50IG9mIGFuIGVsZW1lbnQgaW4gbW9zdCBjYXNlcyBlcXVhbHMgdGhlIGNvbnRhaW5pbmcgYmxvY2suXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL2Nzc3dnLWRyYWZ0cy9jc3NvbS12aWV3LyNkb20taHRtbGVsZW1lbnQtb2Zmc2V0cGFyZW50XG4gICAgbGV0IG9mZnNldFBhcmVudCA9IG5vZGUub2Zmc2V0UGFyZW50O1xuICAgIC8vIFRoZSBvZmZzZXRQYXJlbnQgYWxnb3JpdGhtIHRlcm1pbmF0ZXMgYXQgdGhlIGRvY3VtZW50IGJvZHksXG4gICAgLy8gZXZlbiBpZiB0aGUgYm9keSBpcyBub3QgYSBjb250YWluaW5nIGJsb2NrLiBEb3VibGUgY2hlY2sgdGhhdFxuICAgIC8vIGFuZCB1c2UgdGhlIGRvY3VtZW50RWxlbWVudCBpZiBzby5cbiAgICBpZiAob2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCA9PT0gZG9jdW1lbnQuYm9keSAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiICYmICEkZWRjZjEzMmE5Mjg0MzY4YSR2YXIkaXNDb250YWluaW5nQmxvY2sob2Zmc2V0UGFyZW50KSkgb2Zmc2V0UGFyZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIC8vIFRPRE8obGF0ZXIpOiBoYW5kbGUgdGFibGUgZWxlbWVudHM/XG4gICAgLy8gVGhlIG9mZnNldFBhcmVudCBjYW4gYmUgbnVsbCBpZiB0aGUgZWxlbWVudCBoYXMgcG9zaXRpb246IGZpeGVkLCBvciBhIGZldyBvdGhlciBjYXNlcy5cbiAgICAvLyBXZSBoYXZlIHRvIHdhbGsgdXAgdGhlIHRyZWUgbWFudWFsbHkgaW4gdGhpcyBjYXNlIGJlY2F1c2UgZml4ZWQgcG9zaXRpb25lZCBlbGVtZW50c1xuICAgIC8vIGFyZSBzdGlsbCBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvIHRoZWlyIGNvbnRhaW5pbmcgYmxvY2ssIHdoaWNoIGlzIG5vdCBhbHdheXMgdGhlIHZpZXdwb3J0LlxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICBvZmZzZXRQYXJlbnQgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIHdoaWxlKG9mZnNldFBhcmVudCAmJiAhJGVkY2YxMzJhOTI4NDM2OGEkdmFyJGlzQ29udGFpbmluZ0Jsb2NrKG9mZnNldFBhcmVudCkpb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIC8vIEZhbGwgYmFjayB0byB0aGUgdmlld3BvcnQuXG4gICAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuZnVuY3Rpb24gJGVkY2YxMzJhOTI4NDM2OGEkdmFyJGlzQ29udGFpbmluZ0Jsb2NrKG5vZGUpIHtcbiAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICByZXR1cm4gc3R5bGUudHJhbnNmb3JtICE9PSBcIm5vbmVcIiB8fCAvdHJhbnNmb3JtfHBlcnNwZWN0aXZlLy50ZXN0KHN0eWxlLndpbGxDaGFuZ2UpIHx8IHN0eWxlLmZpbHRlciAhPT0gXCJub25lXCIgfHwgc3R5bGUuY29udGFpbiA9PT0gXCJwYWludFwiIHx8IC8vIEB0cy1pZ25vcmVcbiAgICBcImJhY2tkcm9wRmlsdGVyXCIgaW4gc3R5bGUgJiYgc3R5bGUuYmFja2Ryb3BGaWx0ZXIgIT09IFwibm9uZVwiIHx8IC8vIEB0cy1pZ25vcmVcbiAgICBcIldlYmtpdEJhY2tkcm9wRmlsdGVyXCIgaW4gc3R5bGUgJiYgc3R5bGUuV2Via2l0QmFja2Ryb3BGaWx0ZXIgIT09IFwibm9uZVwiO1xufVxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuY29uc3QgJGRkMTQ5ZjYzMjgyYWZiYmYkZXhwb3J0JGY2MjExNTYzMjE1ZTNiMzcgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gJGRkMTQ5ZjYzMjgyYWZiYmYkZXhwb3J0JDE4ZmM4NDI4ODYxMTg0ZGEob3B0cykge1xuICAgIGxldCB7IHRyaWdnZXJSZWY6IHRyaWdnZXJSZWYsIGlzT3BlbjogaXNPcGVuLCBvbkNsb3NlOiBvbkNsb3NlIH0gPSBvcHRzO1xuICAgICgwLCAkazdRT3MkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoIWlzT3BlbiB8fCBvbkNsb3NlID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIGxldCBvblNjcm9sbCA9IChlKT0+e1xuICAgICAgICAgICAgLy8gSWdub3JlIGlmIHNjcm9sbGluZyBhbiBzY3JvbGxhYmxlIHJlZ2lvbiBvdXRzaWRlIHRoZSB0cmlnZ2VyJ3MgdHJlZS5cbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIC8vIHdpbmRvdyBpcyBub3QgYSBOb2RlIGFuZCBkb2Vzbid0IGhhdmUgY29udGFpbiwgYnV0IHdpbmRvdyBjb250YWlucyBldmVyeXRoaW5nXG4gICAgICAgICAgICBpZiAoIXRyaWdnZXJSZWYuY3VycmVudCB8fCB0YXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmICF0YXJnZXQuY29udGFpbnModHJpZ2dlclJlZi5jdXJyZW50KSkgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IG9uQ2xvc2VIYW5kbGVyID0gb25DbG9zZSB8fCAkZGQxNDlmNjMyODJhZmJiZiRleHBvcnQkZjYyMTE1NjMyMTVlM2IzNy5nZXQodHJpZ2dlclJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIGlmIChvbkNsb3NlSGFuZGxlcikgb25DbG9zZUhhbmRsZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgb25TY3JvbGwsIHRydWUpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIG9uU2Nyb2xsLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGlzT3BlbixcbiAgICAgICAgb25DbG9zZSxcbiAgICAgICAgdHJpZ2dlclJlZlxuICAgIF0pO1xufVxuXG5cblxuXG4vLyBAdHMtaWdub3JlXG5sZXQgJDJhNDFlNDVkZjE1OTNlNjQkdmFyJHZpc3VhbFZpZXdwb3J0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy52aXN1YWxWaWV3cG9ydDtcbmZ1bmN0aW9uICQyYTQxZTQ1ZGYxNTkzZTY0JGV4cG9ydCRkMzllMTgxM2IzYmRkMGUxKHByb3BzKSB7XG4gICAgbGV0IHsgZGlyZWN0aW9uOiBkaXJlY3Rpb24gfSA9ICgwLCAkazdRT3MkdXNlTG9jYWxlKSgpO1xuICAgIGxldCB7IGFycm93U2l6ZTogYXJyb3dTaXplID0gMCwgdGFyZ2V0UmVmOiB0YXJnZXRSZWYsIG92ZXJsYXlSZWY6IG92ZXJsYXlSZWYsIHNjcm9sbFJlZjogc2Nyb2xsUmVmID0gb3ZlcmxheVJlZiwgcGxhY2VtZW50OiBwbGFjZW1lbnQgPSBcImJvdHRvbVwiLCBjb250YWluZXJQYWRkaW5nOiBjb250YWluZXJQYWRkaW5nID0gMTIsIHNob3VsZEZsaXA6IHNob3VsZEZsaXAgPSB0cnVlLCBib3VuZGFyeUVsZW1lbnQ6IGJvdW5kYXJ5RWxlbWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50LmJvZHkgOiBudWxsLCBvZmZzZXQ6IG9mZnNldCA9IDAsIGNyb3NzT2Zmc2V0OiBjcm9zc09mZnNldCA9IDAsIHNob3VsZFVwZGF0ZVBvc2l0aW9uOiBzaG91bGRVcGRhdGVQb3NpdGlvbiA9IHRydWUsIGlzT3BlbjogaXNPcGVuID0gdHJ1ZSwgb25DbG9zZTogb25DbG9zZSwgbWF4SGVpZ2h0OiBtYXhIZWlnaHQsIGFycm93Qm91bmRhcnlPZmZzZXQ6IGFycm93Qm91bmRhcnlPZmZzZXQgPSAwIH0gPSBwcm9wcztcbiAgICBsZXQgW3Bvc2l0aW9uLCBzZXRQb3NpdGlvbl0gPSAoMCwgJGs3UU9zJHVzZVN0YXRlKSh7XG4gICAgICAgIHBvc2l0aW9uOiB7fSxcbiAgICAgICAgYXJyb3dPZmZzZXRMZWZ0OiB1bmRlZmluZWQsXG4gICAgICAgIGFycm93T2Zmc2V0VG9wOiB1bmRlZmluZWQsXG4gICAgICAgIG1heEhlaWdodDogdW5kZWZpbmVkLFxuICAgICAgICBwbGFjZW1lbnQ6IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIGxldCBkZXBzID0gW1xuICAgICAgICBzaG91bGRVcGRhdGVQb3NpdGlvbixcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBvdmVybGF5UmVmLmN1cnJlbnQsXG4gICAgICAgIHRhcmdldFJlZi5jdXJyZW50LFxuICAgICAgICBzY3JvbGxSZWYuY3VycmVudCxcbiAgICAgICAgY29udGFpbmVyUGFkZGluZyxcbiAgICAgICAgc2hvdWxkRmxpcCxcbiAgICAgICAgYm91bmRhcnlFbGVtZW50LFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGNyb3NzT2Zmc2V0LFxuICAgICAgICBpc09wZW4sXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICBhcnJvd0JvdW5kYXJ5T2Zmc2V0LFxuICAgICAgICBhcnJvd1NpemVcbiAgICBdO1xuICAgIGxldCB1cGRhdGVQb3NpdGlvbiA9ICgwLCAkazdRT3MkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVQb3NpdGlvbiA9PT0gZmFsc2UgfHwgIWlzT3BlbiB8fCAhb3ZlcmxheVJlZi5jdXJyZW50IHx8ICF0YXJnZXRSZWYuY3VycmVudCB8fCAhc2Nyb2xsUmVmLmN1cnJlbnQgfHwgIWJvdW5kYXJ5RWxlbWVudCkgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zaXRpb24gPSAoMCwgJGVkY2YxMzJhOTI4NDM2OGEkZXhwb3J0JGIzY2ViMGNiZjEwNTZkOTgpKHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogJDJhNDFlNDVkZjE1OTNlNjQkdmFyJHRyYW5zbGF0ZVJUTChwbGFjZW1lbnQsIGRpcmVjdGlvbiksXG4gICAgICAgICAgICBvdmVybGF5Tm9kZTogb3ZlcmxheVJlZi5jdXJyZW50LFxuICAgICAgICAgICAgdGFyZ2V0Tm9kZTogdGFyZ2V0UmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBzY3JvbGxOb2RlOiBzY3JvbGxSZWYuY3VycmVudCxcbiAgICAgICAgICAgIHBhZGRpbmc6IGNvbnRhaW5lclBhZGRpbmcsXG4gICAgICAgICAgICBzaG91bGRGbGlwOiBzaG91bGRGbGlwLFxuICAgICAgICAgICAgYm91bmRhcnlFbGVtZW50OiBib3VuZGFyeUVsZW1lbnQsXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgIGNyb3NzT2Zmc2V0OiBjcm9zc09mZnNldCxcbiAgICAgICAgICAgIG1heEhlaWdodDogbWF4SGVpZ2h0LFxuICAgICAgICAgICAgYXJyb3dTaXplOiBhcnJvd1NpemUsXG4gICAgICAgICAgICBhcnJvd0JvdW5kYXJ5T2Zmc2V0OiBhcnJvd0JvdW5kYXJ5T2Zmc2V0XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBNb2RpZnkgb3ZlcmxheSBzdHlsZXMgZGlyZWN0bHkgc28gcG9zaXRpb25pbmcgaGFwcGVucyBpbW1lZGlhdGVseSB3aXRob3V0IHRoZSBuZWVkIG9mIGEgc2Vjb25kIHJlbmRlclxuICAgICAgICAvLyBUaGlzIGlzIHNvIHdlIGRvbid0IGhhdmUgdG8gZGVsYXkgYXV0b0ZvY3VzIHNjcm9sbGluZyBvciBkZWxheSBhcHBseWluZyBwcmV2ZW50U2Nyb2xsIGZvciBwb3BvdmVyc1xuICAgICAgICBPYmplY3Qua2V5cyhwb3NpdGlvbi5wb3NpdGlvbikuZm9yRWFjaCgoa2V5KT0+b3ZlcmxheVJlZi5jdXJyZW50LnN0eWxlW2tleV0gPSBwb3NpdGlvbi5wb3NpdGlvbltrZXldICsgXCJweFwiKTtcbiAgICAgICAgb3ZlcmxheVJlZi5jdXJyZW50LnN0eWxlLm1heEhlaWdodCA9IHBvc2l0aW9uLm1heEhlaWdodCAhPSBudWxsID8gcG9zaXRpb24ubWF4SGVpZ2h0ICsgXCJweFwiIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBUcmlnZ2VyIGEgc2V0IHN0YXRlIGZvciBhIHNlY29uZCByZW5kZXIgYW55d2F5IGZvciBhcnJvdyBwb3NpdGlvbmluZ1xuICAgICAgICBzZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIGRlcHMpO1xuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiB3aGVuIGFueXRoaW5nIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgKDAsICRrN1FPcyR1c2VMYXlvdXRFZmZlY3QpKHVwZGF0ZVBvc2l0aW9uLCBkZXBzKTtcbiAgICAvLyBVcGRhdGUgcG9zaXRpb24gb24gd2luZG93IHJlc2l6ZVxuICAgICQyYTQxZTQ1ZGYxNTkzZTY0JHZhciR1c2VSZXNpemUodXBkYXRlUG9zaXRpb24pO1xuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiB3aGVuIHRoZSBvdmVybGF5IGNoYW5nZXMgc2l6ZSAobWlnaHQgbmVlZCB0byBmbGlwKS5cbiAgICAoMCwgJGs3UU9zJHVzZVJlc2l6ZU9ic2VydmVyKSh7XG4gICAgICAgIHJlZjogb3ZlcmxheVJlZixcbiAgICAgICAgb25SZXNpemU6IHVwZGF0ZVBvc2l0aW9uXG4gICAgfSk7XG4gICAgLy8gUmVwb3NpdGlvbiB0aGUgb3ZlcmxheSBhbmQgZG8gbm90IGNsb3NlIG9uIHNjcm9sbCB3aGlsZSB0aGUgdmlzdWFsIHZpZXdwb3J0IGlzIHJlc2l6aW5nLlxuICAgIC8vIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCBvdmVybGF5cyBhZGp1c3QgdGhlaXIgcG9zaXRpb25pbmcgd2hlbiB0aGUgaU9TIHZpcnR1YWwga2V5Ym9hcmQgYXBwZWFycy5cbiAgICBsZXQgaXNSZXNpemluZyA9ICgwLCAkazdRT3MkdXNlUmVmKShmYWxzZSk7XG4gICAgKDAsICRrN1FPcyR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCB0aW1lb3V0O1xuICAgICAgICBsZXQgb25SZXNpemUgPSAoKT0+e1xuICAgICAgICAgICAgaXNSZXNpemluZy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgaXNSZXNpemluZy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICAgICAgdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgfTtcbiAgICAgICAgJDJhNDFlNDVkZjE1OTNlNjQkdmFyJHZpc3VhbFZpZXdwb3J0ID09PSBudWxsIHx8ICQyYTQxZTQ1ZGYxNTkzZTY0JHZhciR2aXN1YWxWaWV3cG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogJDJhNDFlNDVkZjE1OTNlNjQkdmFyJHZpc3VhbFZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25SZXNpemUpO1xuICAgICAgICAkMmE0MWU0NWRmMTU5M2U2NCR2YXIkdmlzdWFsVmlld3BvcnQgPT09IG51bGwgfHwgJDJhNDFlNDVkZjE1OTNlNjQkdmFyJHZpc3VhbFZpZXdwb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAkMmE0MWU0NWRmMTU5M2U2NCR2YXIkdmlzdWFsVmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBvblJlc2l6ZSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgJDJhNDFlNDVkZjE1OTNlNjQkdmFyJHZpc3VhbFZpZXdwb3J0ID09PSBudWxsIHx8ICQyYTQxZTQ1ZGYxNTkzZTY0JHZhciR2aXN1YWxWaWV3cG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogJDJhNDFlNDVkZjE1OTNlNjQkdmFyJHZpc3VhbFZpZXdwb3J0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25SZXNpemUpO1xuICAgICAgICAgICAgJDJhNDFlNDVkZjE1OTNlNjQkdmFyJHZpc3VhbFZpZXdwb3J0ID09PSBudWxsIHx8ICQyYTQxZTQ1ZGYxNTkzZTY0JHZhciR2aXN1YWxWaWV3cG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogJDJhNDFlNDVkZjE1OTNlNjQkdmFyJHZpc3VhbFZpZXdwb3J0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgb25SZXNpemUpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgdXBkYXRlUG9zaXRpb25cbiAgICBdKTtcbiAgICBsZXQgY2xvc2UgPSAoMCwgJGs3UU9zJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICBpZiAoIWlzUmVzaXppbmcuY3VycmVudCkgb25DbG9zZSgpO1xuICAgIH0sIFtcbiAgICAgICAgb25DbG9zZSxcbiAgICAgICAgaXNSZXNpemluZ1xuICAgIF0pO1xuICAgIC8vIFdoZW4gc2Nyb2xsaW5nIGEgcGFyZW50IHNjcm9sbGFibGUgcmVnaW9uIG9mIHRoZSB0cmlnZ2VyIChvdGhlciB0aGFuIHRoZSBib2R5KSxcbiAgICAvLyB3ZSBoaWRlIHRoZSBwb3BvdmVyLiBPdGhlcndpc2UsIGl0cyBwb3NpdGlvbiB3b3VsZCBiZSBpbmNvcnJlY3QuXG4gICAgKDAsICRkZDE0OWY2MzI4MmFmYmJmJGV4cG9ydCQxOGZjODQyODg2MTE4NGRhKSh7XG4gICAgICAgIHRyaWdnZXJSZWY6IHRhcmdldFJlZixcbiAgICAgICAgaXNPcGVuOiBpc09wZW4sXG4gICAgICAgIG9uQ2xvc2U6IG9uQ2xvc2UgJiYgY2xvc2VcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvdmVybGF5UHJvcHM6IHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDEwMDAwMCxcbiAgICAgICAgICAgICAgICAuLi5wb3NpdGlvbi5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IHBvc2l0aW9uLm1heEhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwbGFjZW1lbnQ6IHBvc2l0aW9uLnBsYWNlbWVudCxcbiAgICAgICAgYXJyb3dQcm9wczoge1xuICAgICAgICAgICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIixcbiAgICAgICAgICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmFycm93T2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IHBvc2l0aW9uLmFycm93T2Zmc2V0VG9wXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVBvc2l0aW9uOiB1cGRhdGVQb3NpdGlvblxuICAgIH07XG59XG5mdW5jdGlvbiAkMmE0MWU0NWRmMTU5M2U2NCR2YXIkdXNlUmVzaXplKG9uUmVzaXplKSB7XG4gICAgKDAsICRrN1FPcyR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG9uUmVzaXplLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25SZXNpemUsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIG9uUmVzaXplXG4gICAgXSk7XG59XG5mdW5jdGlvbiAkMmE0MWU0NWRmMTU5M2U2NCR2YXIkdHJhbnNsYXRlUlRMKHBvc2l0aW9uLCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInJ0bFwiKSByZXR1cm4gcG9zaXRpb24ucmVwbGFjZShcInN0YXJ0XCIsIFwicmlnaHRcIikucmVwbGFjZShcImVuZFwiLCBcImxlZnRcIik7XG4gICAgcmV0dXJuIHBvc2l0aW9uLnJlcGxhY2UoXCJzdGFydFwiLCBcImxlZnRcIikucmVwbGFjZShcImVuZFwiLCBcInJpZ2h0XCIpO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5jb25zdCAkYTExNTAxZjNkMWQzOWU2YyR2YXIkdmlzaWJsZU92ZXJsYXlzID0gW107XG5mdW5jdGlvbiAkYTExNTAxZjNkMWQzOWU2YyRleHBvcnQkZWE4ZjcxMDgzZTkwNjAwZihwcm9wcywgcmVmKSB7XG4gICAgbGV0IHsgb25DbG9zZTogb25DbG9zZSwgc2hvdWxkQ2xvc2VPbkJsdXI6IHNob3VsZENsb3NlT25CbHVyLCBpc09wZW46IGlzT3BlbiwgaXNEaXNtaXNzYWJsZTogaXNEaXNtaXNzYWJsZSA9IGZhbHNlLCBpc0tleWJvYXJkRGlzbWlzc0Rpc2FibGVkOiBpc0tleWJvYXJkRGlzbWlzc0Rpc2FibGVkID0gZmFsc2UsIHNob3VsZENsb3NlT25JbnRlcmFjdE91dHNpZGU6IHNob3VsZENsb3NlT25JbnRlcmFjdE91dHNpZGUgfSA9IHByb3BzO1xuICAgIC8vIEFkZCB0aGUgb3ZlcmxheSByZWYgdG8gdGhlIHN0YWNrIG9mIHZpc2libGUgb3ZlcmxheXMgb24gbW91bnQsIGFuZCByZW1vdmUgb24gdW5tb3VudC5cbiAgICAoMCwgJGs3UU9zJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKGlzT3BlbikgJGExMTUwMWYzZDFkMzllNmMkdmFyJHZpc2libGVPdmVybGF5cy5wdXNoKHJlZik7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJGExMTUwMWYzZDFkMzllNmMkdmFyJHZpc2libGVPdmVybGF5cy5pbmRleE9mKHJlZik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkgJGExMTUwMWYzZDFkMzllNmMkdmFyJHZpc2libGVPdmVybGF5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgaXNPcGVuLFxuICAgICAgICByZWZcbiAgICBdKTtcbiAgICAvLyBPbmx5IGhpZGUgdGhlIG92ZXJsYXkgd2hlbiBpdCBpcyB0aGUgdG9wbW9zdCB2aXNpYmxlIG92ZXJsYXkgaW4gdGhlIHN0YWNrLlxuICAgIGxldCBvbkhpZGUgPSAoKT0+e1xuICAgICAgICBpZiAoJGExMTUwMWYzZDFkMzllNmMkdmFyJHZpc2libGVPdmVybGF5c1skYTExNTAxZjNkMWQzOWU2YyR2YXIkdmlzaWJsZU92ZXJsYXlzLmxlbmd0aCAtIDFdID09PSByZWYgJiYgb25DbG9zZSkgb25DbG9zZSgpO1xuICAgIH07XG4gICAgbGV0IG9uSW50ZXJhY3RPdXRzaWRlU3RhcnQgPSAoZSk9PntcbiAgICAgICAgaWYgKCFzaG91bGRDbG9zZU9uSW50ZXJhY3RPdXRzaWRlIHx8IHNob3VsZENsb3NlT25JbnRlcmFjdE91dHNpZGUoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICBpZiAoJGExMTUwMWYzZDFkMzllNmMkdmFyJHZpc2libGVPdmVybGF5c1skYTExNTAxZjNkMWQzOWU2YyR2YXIkdmlzaWJsZU92ZXJsYXlzLmxlbmd0aCAtIDFdID09PSByZWYpIHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IG9uSW50ZXJhY3RPdXRzaWRlID0gKGUpPT57XG4gICAgICAgIGlmICghc2hvdWxkQ2xvc2VPbkludGVyYWN0T3V0c2lkZSB8fCBzaG91bGRDbG9zZU9uSW50ZXJhY3RPdXRzaWRlKGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgaWYgKCRhMTE1MDFmM2QxZDM5ZTZjJHZhciR2aXNpYmxlT3ZlcmxheXNbJGExMTUwMWYzZDFkMzllNmMkdmFyJHZpc2libGVPdmVybGF5cy5sZW5ndGggLSAxXSA9PT0gcmVmKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkhpZGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSGFuZGxlIHRoZSBlc2NhcGUga2V5XG4gICAgbGV0IG9uS2V5RG93biA9IChlKT0+e1xuICAgICAgICBpZiAoZS5rZXkgPT09IFwiRXNjYXBlXCIgJiYgIWlzS2V5Ym9hcmREaXNtaXNzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBvbkhpZGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSGFuZGxlIGNsaWNraW5nIG91dHNpZGUgdGhlIG92ZXJsYXkgdG8gY2xvc2UgaXRcbiAgICAoMCwgJGs3UU9zJHVzZUludGVyYWN0T3V0c2lkZSkoe1xuICAgICAgICByZWY6IHJlZixcbiAgICAgICAgb25JbnRlcmFjdE91dHNpZGU6IGlzRGlzbWlzc2FibGUgJiYgaXNPcGVuID8gb25JbnRlcmFjdE91dHNpZGUgOiBudWxsLFxuICAgICAgICBvbkludGVyYWN0T3V0c2lkZVN0YXJ0OiBvbkludGVyYWN0T3V0c2lkZVN0YXJ0XG4gICAgfSk7XG4gICAgbGV0IHsgZm9jdXNXaXRoaW5Qcm9wczogZm9jdXNXaXRoaW5Qcm9wcyB9ID0gKDAsICRrN1FPcyR1c2VGb2N1c1dpdGhpbikoe1xuICAgICAgICBpc0Rpc2FibGVkOiAhc2hvdWxkQ2xvc2VPbkJsdXIsXG4gICAgICAgIG9uQmx1cldpdGhpbjogKGUpPT57XG4gICAgICAgICAgICAvLyBEbyBub3QgY2xvc2UgaWYgcmVsYXRlZFRhcmdldCBpcyBudWxsLCB3aGljaCBtZWFucyBmb2N1cyBpcyBsb3N0IHRvIHRoZSBib2R5LlxuICAgICAgICAgICAgLy8gVGhhdCBjYW4gaGFwcGVuIHdoZW4gc3dpdGNoaW5nIHRhYnMsIG9yIGR1ZSB0byBhIFZvaWNlT3Zlci9DaHJvbWUgYnVnIHdpdGggQ29udHJvbCtPcHRpb24rQXJyb3cgbmF2aWdhdGlvbi5cbiAgICAgICAgICAgIC8vIENsaWNraW5nIG9uIHRoZSBib2R5IHRvIGNsb3NlIHRoZSBvdmVybGF5IHNob3VsZCBhbHJlYWR5IGJlIGhhbmRsZWQgYnkgdXNlSW50ZXJhY3RPdXRzaWRlLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Fkb2JlL3JlYWN0LXNwZWN0cnVtL2lzc3Vlcy80MTMwXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYWRvYmUvcmVhY3Qtc3BlY3RydW0vaXNzdWVzLzQ5MjJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJZiBmb2N1cyBpcyBtb3ZpbmcgaW50byBhIGNoaWxkIGZvY3VzIHNjb3BlIChlLmcuIG1lbnUgaW5zaWRlIGEgZGlhbG9nKSxcbiAgICAgICAgICAgIC8vIGRvIG5vdCBjbG9zZSB0aGUgb3V0ZXIgb3ZlcmxheS4gQXQgdGhpcyBwb2ludCwgdGhlIGFjdGl2ZSBzY29wZSBzaG91bGRcbiAgICAgICAgICAgIC8vIHN0aWxsIGJlIHRoZSBvdXRlciBvdmVybGF5LCBzaW5jZSBibHVyIGV2ZW50cyBydW4gYmVmb3JlIGZvY3VzLlxuICAgICAgICAgICAgaWYgKCFlLnJlbGF0ZWRUYXJnZXQgfHwgKDAsICRrN1FPcyRpc0VsZW1lbnRJbkNoaWxkT2ZBY3RpdmVTY29wZSkoZS5yZWxhdGVkVGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCFzaG91bGRDbG9zZU9uSW50ZXJhY3RPdXRzaWRlIHx8IHNob3VsZENsb3NlT25JbnRlcmFjdE91dHNpZGUoZS5yZWxhdGVkVGFyZ2V0KSkgb25DbG9zZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IG9uUG9pbnRlckRvd25VbmRlcmxheSA9IChlKT0+e1xuICAgICAgICAvLyBmaXhlcyBhIGZpcmVmb3ggaXNzdWUgdGhhdCBzdGFydHMgdGV4dCBzZWxlY3Rpb24gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTY3NTg0NlxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3ZlcmxheVByb3BzOiB7XG4gICAgICAgICAgICBvbktleURvd246IG9uS2V5RG93bixcbiAgICAgICAgICAgIC4uLmZvY3VzV2l0aGluUHJvcHNcbiAgICAgICAgfSxcbiAgICAgICAgdW5kZXJsYXlQcm9wczoge1xuICAgICAgICAgICAgb25Qb2ludGVyRG93bjogb25Qb2ludGVyRG93blVuZGVybGF5XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5mdW5jdGlvbiAkNjI4MDM3ODg2YmEzMTIzNiRleHBvcnQkZjlkNWM4YmVlZTdkMDA4ZChwcm9wcywgc3RhdGUsIHJlZikge1xuICAgIGxldCB7IHR5cGU6IHR5cGUgfSA9IHByb3BzO1xuICAgIGxldCB7IGlzT3BlbjogaXNPcGVuIH0gPSBzdGF0ZTtcbiAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBTaGFyZSBzdGF0ZSBjbG9zZSBmdW5jdGlvbiB3aXRoIHVzZU92ZXJsYXlQb3NpdGlvbiBzbyBpdCBjYW4gY2xvc2Ugb24gc2Nyb2xsXG4gICAgLy8gd2l0aG91dCBmb3JjaW5nIHVzZXJzIHRvIHBhc3Mgb25DbG9zZS5cbiAgICAoMCwgJGs3UU9zJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKHJlZiAmJiByZWYuY3VycmVudCkgKDAsICRkZDE0OWY2MzI4MmFmYmJmJGV4cG9ydCRmNjIxMTU2MzIxNWUzYjM3KS5zZXQocmVmLmN1cnJlbnQsIHN0YXRlLmNsb3NlKTtcbiAgICB9KTtcbiAgICAvLyBBcmlhIDEuMSBzdXBwb3J0cyBtdWx0aXBsZSB2YWx1ZXMgZm9yIGFyaWEtaGFzcG9wdXAgb3RoZXIgdGhhbiBqdXN0IG1lbnVzLlxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS0xLjEvI2FyaWEtaGFzcG9wdXBcbiAgICAvLyBIb3dldmVyLCB3ZSBvbmx5IGFkZCBpdCBmb3IgbWVudXMgZm9yIG5vdyBiZWNhdXNlIHNjcmVlbiByZWFkZXJzIG9mdGVuXG4gICAgLy8gYW5ub3VuY2UgaXQgYXMgYSBtZW51IGV2ZW4gZm9yIG90aGVyIHZhbHVlcy5cbiAgICBsZXQgYXJpYUhhc1BvcHVwID0gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlID09PSBcIm1lbnVcIikgYXJpYUhhc1BvcHVwID0gdHJ1ZTtcbiAgICBlbHNlIGlmICh0eXBlID09PSBcImxpc3Rib3hcIikgYXJpYUhhc1BvcHVwID0gXCJsaXN0Ym94XCI7XG4gICAgbGV0IG92ZXJsYXlJZCA9ICgwLCAkazdRT3MkdXNlSWQpKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHJpZ2dlclByb3BzOiB7XG4gICAgICAgICAgICBcImFyaWEtaGFzcG9wdXBcIjogYXJpYUhhc1BvcHVwLFxuICAgICAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IGlzT3BlbixcbiAgICAgICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBpc09wZW4gPyBvdmVybGF5SWQgOiBudWxsLFxuICAgICAgICAgICAgb25QcmVzczogc3RhdGUudG9nZ2xlXG4gICAgICAgIH0sXG4gICAgICAgIG92ZXJsYXlQcm9wczoge1xuICAgICAgICAgICAgaWQ6IG92ZXJsYXlJZFxuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG4vLyBAdHMtaWdub3JlXG5jb25zdCAkNDljNTFjMjUzNjFkNGNkMiR2YXIkdmlzdWFsVmlld3BvcnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnZpc3VhbFZpZXdwb3J0O1xuLy8gSFRNTCBpbnB1dCB0eXBlcyB0aGF0IGRvIG5vdCBjYXVzZSB0aGUgc29mdHdhcmUga2V5Ym9hcmQgdG8gYXBwZWFyLlxuY29uc3QgJDQ5YzUxYzI1MzYxZDRjZDIkdmFyJG5vblRleHRJbnB1dFR5cGVzID0gbmV3IFNldChbXG4gICAgXCJjaGVja2JveFwiLFxuICAgIFwicmFkaW9cIixcbiAgICBcInJhbmdlXCIsXG4gICAgXCJjb2xvclwiLFxuICAgIFwiZmlsZVwiLFxuICAgIFwiaW1hZ2VcIixcbiAgICBcImJ1dHRvblwiLFxuICAgIFwic3VibWl0XCIsXG4gICAgXCJyZXNldFwiXG5dKTtcbi8vIFRoZSBudW1iZXIgb2YgYWN0aXZlIHVzZVByZXZlbnRTY3JvbGwgY2FsbHMuIFVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmV2ZXJ0IGJhY2sgdG8gdGhlIG9yaWdpbmFsIHBhZ2Ugc3R5bGUvc2Nyb2xsIHBvc2l0aW9uXG5sZXQgJDQ5YzUxYzI1MzYxZDRjZDIkdmFyJHByZXZlbnRTY3JvbGxDb3VudCA9IDA7XG5sZXQgJDQ5YzUxYzI1MzYxZDRjZDIkdmFyJHJlc3RvcmU7XG5mdW5jdGlvbiAkNDljNTFjMjUzNjFkNGNkMiRleHBvcnQkZWUwZjdjYzZhZmNkMWMxOChvcHRpb25zID0ge30pIHtcbiAgICBsZXQgeyBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkIH0gPSBvcHRpb25zO1xuICAgICgwLCAkazdRT3MkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoaXNEaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAkNDljNTFjMjUzNjFkNGNkMiR2YXIkcHJldmVudFNjcm9sbENvdW50Kys7XG4gICAgICAgIGlmICgkNDljNTFjMjUzNjFkNGNkMiR2YXIkcHJldmVudFNjcm9sbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoKDAsICRrN1FPcyRpc0lPUykoKSkgJDQ5YzUxYzI1MzYxZDRjZDIkdmFyJHJlc3RvcmUgPSAkNDljNTFjMjUzNjFkNGNkMiR2YXIkcHJldmVudFNjcm9sbE1vYmlsZVNhZmFyaSgpO1xuICAgICAgICAgICAgZWxzZSAkNDljNTFjMjUzNjFkNGNkMiR2YXIkcmVzdG9yZSA9ICQ0OWM1MWMyNTM2MWQ0Y2QyJHZhciRwcmV2ZW50U2Nyb2xsU3RhbmRhcmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICQ0OWM1MWMyNTM2MWQ0Y2QyJHZhciRwcmV2ZW50U2Nyb2xsQ291bnQtLTtcbiAgICAgICAgICAgIGlmICgkNDljNTFjMjUzNjFkNGNkMiR2YXIkcHJldmVudFNjcm9sbENvdW50ID09PSAwKSAkNDljNTFjMjUzNjFkNGNkMiR2YXIkcmVzdG9yZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgaXNEaXNhYmxlZFxuICAgIF0pO1xufVxuLy8gRm9yIG1vc3QgYnJvd3NlcnMsIGFsbCB3ZSBuZWVkIHRvIGRvIGlzIHNldCBgb3ZlcmZsb3c6IGhpZGRlbmAgb24gdGhlIHJvb3QgZWxlbWVudCwgYW5kXG4vLyBhZGQgc29tZSBwYWRkaW5nIHRvIHByZXZlbnQgdGhlIHBhZ2UgZnJvbSBzaGlmdGluZyB3aGVuIHRoZSBzY3JvbGxiYXIgaXMgaGlkZGVuLlxuZnVuY3Rpb24gJDQ5YzUxYzI1MzYxZDRjZDIkdmFyJHByZXZlbnRTY3JvbGxTdGFuZGFyZCgpIHtcbiAgICByZXR1cm4gKDAsICRrN1FPcyRjaGFpbikoJDQ5YzUxYzI1MzYxZDRjZDIkdmFyJHNldFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgXCJwYWRkaW5nUmlnaHRcIiwgYCR7d2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGh9cHhgKSwgJDQ5YzUxYzI1MzYxZDRjZDIkdmFyJHNldFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgXCJvdmVyZmxvd1wiLCBcImhpZGRlblwiKSk7XG59XG4vLyBNb2JpbGUgU2FmYXJpIGlzIGEgd2hvbGUgZGlmZmVyZW50IGJlYXN0LiBFdmVuIHdpdGggb3ZlcmZsb3c6IGhpZGRlbixcbi8vIGl0IHN0aWxsIHNjcm9sbHMgdGhlIHBhZ2UgaW4gbWFueSBzaXR1YXRpb25zOlxuLy9cbi8vIDEuIFdoZW4gdGhlIGJvdHRvbSB0b29sYmFyIGFuZCBhZGRyZXNzIGJhciBhcmUgY29sbGFwc2VkLCBwYWdlIHNjcm9sbGluZyBpcyBhbHdheXMgYWxsb3dlZC5cbi8vIDIuIFdoZW4gdGhlIGtleWJvYXJkIGlzIHZpc2libGUsIHRoZSB2aWV3cG9ydCBkb2VzIG5vdCByZXNpemUuIEluc3RlYWQsIHRoZSBrZXlib2FyZCBjb3ZlcnMgcGFydCBvZlxuLy8gICAgaXQsIHNvIGl0IGJlY29tZXMgc2Nyb2xsYWJsZS5cbi8vIDMuIFdoZW4gdGFwcGluZyBvbiBhbiBpbnB1dCwgdGhlIHBhZ2UgYWx3YXlzIHNjcm9sbHMgc28gdGhhdCB0aGUgaW5wdXQgaXMgY2VudGVyZWQgaW4gdGhlIHZpc3VhbCB2aWV3cG9ydC5cbi8vICAgIFRoaXMgbWF5IGNhdXNlIGV2ZW4gZml4ZWQgcG9zaXRpb24gZWxlbWVudHMgdG8gc2Nyb2xsIG9mZiB0aGUgc2NyZWVuLlxuLy8gNC4gV2hlbiB1c2luZyB0aGUgbmV4dC9wcmV2aW91cyBidXR0b25zIGluIHRoZSBrZXlib2FyZCB0byBuYXZpZ2F0ZSBiZXR3ZWVuIGlucHV0cywgdGhlIHdob2xlIHBhZ2UgYWx3YXlzXG4vLyAgICBzY3JvbGxzLCBldmVuIGlmIHRoZSBpbnB1dCBpcyBpbnNpZGUgYSBuZXN0ZWQgc2Nyb2xsYWJsZSBlbGVtZW50IHRoYXQgY291bGQgYmUgc2Nyb2xsZWQgaW5zdGVhZC5cbi8vXG4vLyBJbiBvcmRlciB0byB3b3JrIGFyb3VuZCB0aGVzZSBjYXNlcywgYW5kIHByZXZlbnQgc2Nyb2xsaW5nIHdpdGhvdXQgamFua2luZXNzLCB3ZSBkbyBhIGZldyB0aGluZ3M6XG4vL1xuLy8gMS4gUHJldmVudCBkZWZhdWx0IG9uIGB0b3VjaG1vdmVgIGV2ZW50cyB0aGF0IGFyZSBub3QgaW4gYSBzY3JvbGxhYmxlIGVsZW1lbnQuIFRoaXMgcHJldmVudHMgdG91Y2ggc2Nyb2xsaW5nXG4vLyAgICBvbiB0aGUgd2luZG93LlxuLy8gMi4gUHJldmVudCBkZWZhdWx0IG9uIGB0b3VjaG1vdmVgIGV2ZW50cyBpbnNpZGUgYSBzY3JvbGxhYmxlIGVsZW1lbnQgd2hlbiB0aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIGF0IHRoZVxuLy8gICAgdG9wIG9yIGJvdHRvbS4gVGhpcyBhdm9pZHMgdGhlIHdob2xlIHBhZ2Ugc2Nyb2xsaW5nIGluc3RlYWQsIGJ1dCBkb2VzIHByZXZlbnQgb3ZlcnNjcm9sbGluZy5cbi8vIDMuIFByZXZlbnQgZGVmYXVsdCBvbiBgdG91Y2hlbmRgIGV2ZW50cyBvbiBpbnB1dCBlbGVtZW50cyBhbmQgaGFuZGxlIGZvY3VzaW5nIHRoZSBlbGVtZW50IG91cnNlbHZlcy5cbi8vIDQuIFdoZW4gZm9jdXNpbmcgYW4gaW5wdXQsIGFwcGx5IGEgdHJhbnNmb3JtIHRvIHRyaWNrIFNhZmFyaSBpbnRvIHRoaW5raW5nIHRoZSBpbnB1dCBpcyBhdCB0aGUgdG9wXG4vLyAgICBvZiB0aGUgcGFnZSwgd2hpY2ggcHJldmVudHMgaXQgZnJvbSBzY3JvbGxpbmcgdGhlIHBhZ2UuIEFmdGVyIHRoZSBpbnB1dCBpcyBmb2N1c2VkLCBzY3JvbGwgdGhlIGVsZW1lbnRcbi8vICAgIGludG8gdmlldyBvdXJzZWx2ZXMsIHdpdGhvdXQgc2Nyb2xsaW5nIHRoZSB3aG9sZSBwYWdlLlxuLy8gNS4gT2Zmc2V0IHRoZSBib2R5IGJ5IHRoZSBzY3JvbGwgcG9zaXRpb24gdXNpbmcgYSBuZWdhdGl2ZSBtYXJnaW4gYW5kIHNjcm9sbCB0byB0aGUgdG9wLiBUaGlzIHNob3VsZCBhcHBlYXIgdGhlXG4vLyAgICBzYW1lIHZpc3VhbGx5LCBidXQgbWFrZXMgdGhlIGFjdHVhbCBzY3JvbGwgcG9zaXRpb24gYWx3YXlzIHplcm8uIFRoaXMgaXMgcmVxdWlyZWQgdG8gbWFrZSBhbGwgb2YgdGhlXG4vLyAgICBhYm92ZSB3b3JrIG9yIFNhZmFyaSB3aWxsIHN0aWxsIHRyeSB0byBzY3JvbGwgdGhlIHBhZ2Ugd2hlbiBmb2N1c2luZyBhbiBpbnB1dC5cbi8vIDYuIEFzIGEgbGFzdCByZXNvcnQsIGhhbmRsZSB3aW5kb3cgc2Nyb2xsIGV2ZW50cywgYW5kIHNjcm9sbCBiYWNrIHRvIHRoZSB0b3AuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGF0dGVtcHRpbmdcbi8vICAgIHRvIG5hdmlnYXRlIHRvIGFuIGlucHV0IHdpdGggdGhlIG5leHQvcHJldmlvdXMgYnV0dG9ucyB0aGF0J3Mgb3V0c2lkZSBhIG1vZGFsLlxuZnVuY3Rpb24gJDQ5YzUxYzI1MzYxZDRjZDIkdmFyJHByZXZlbnRTY3JvbGxNb2JpbGVTYWZhcmkoKSB7XG4gICAgbGV0IHNjcm9sbGFibGU7XG4gICAgbGV0IGxhc3RZID0gMDtcbiAgICBsZXQgb25Ub3VjaFN0YXJ0ID0gKGUpPT57XG4gICAgICAgIC8vIFN0b3JlIHRoZSBuZWFyZXN0IHNjcm9sbGFibGUgcGFyZW50IGVsZW1lbnQgZnJvbSB0aGUgZWxlbWVudCB0aGF0IHRoZSB1c2VyIHRvdWNoZWQuXG4gICAgICAgIHNjcm9sbGFibGUgPSAoMCwgJGs3UU9zJGdldFNjcm9sbFBhcmVudCkoZS50YXJnZXQpO1xuICAgICAgICBpZiAoc2Nyb2xsYWJsZSA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIHNjcm9sbGFibGUgPT09IGRvY3VtZW50LmJvZHkpIHJldHVybjtcbiAgICAgICAgbGFzdFkgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xuICAgIH07XG4gICAgbGV0IG9uVG91Y2hNb3ZlID0gKGUpPT57XG4gICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nIHRoZSB3aW5kb3cuXG4gICAgICAgIGlmICghc2Nyb2xsYWJsZSB8fCBzY3JvbGxhYmxlID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgc2Nyb2xsYWJsZSA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nIHVwIHdoZW4gYXQgdGhlIHRvcCBhbmQgc2Nyb2xsaW5nIGRvd24gd2hlbiBhdCB0aGUgYm90dG9tXG4gICAgICAgIC8vIG9mIGEgbmVzdGVkIHNjcm9sbGFibGUgYXJlYSwgb3RoZXJ3aXNlIG1vYmlsZSBTYWZhcmkgd2lsbCBzdGFydCBzY3JvbGxpbmdcbiAgICAgICAgLy8gdGhlIHdpbmRvdyBpbnN0ZWFkLiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGRpc2FibGVzIGJvdW5jZSBzY3JvbGxpbmcgd2hlbiBhdFxuICAgICAgICAvLyB0aGUgdG9wIGJ1dCBpdCdzIHRoZSBiZXN0IHdlIGNhbiBkby5cbiAgICAgICAgbGV0IHkgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gc2Nyb2xsYWJsZS5zY3JvbGxUb3A7XG4gICAgICAgIGxldCBib3R0b20gPSBzY3JvbGxhYmxlLnNjcm9sbEhlaWdodCAtIHNjcm9sbGFibGUuY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAoYm90dG9tID09PSAwKSByZXR1cm47XG4gICAgICAgIGlmIChzY3JvbGxUb3AgPD0gMCAmJiB5ID4gbGFzdFkgfHwgc2Nyb2xsVG9wID49IGJvdHRvbSAmJiB5IDwgbGFzdFkpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGFzdFkgPSB5O1xuICAgIH07XG4gICAgbGV0IG9uVG91Y2hFbmQgPSAoZSk9PntcbiAgICAgICAgbGV0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAvLyBBcHBseSB0aGlzIGNoYW5nZSBpZiB3ZSdyZSBub3QgYWxyZWFkeSBmb2N1c2VkIG9uIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICBpZiAoJDQ5YzUxYzI1MzYxZDRjZDIkdmFyJHdpbGxPcGVuS2V5Ym9hcmQodGFyZ2V0KSAmJiB0YXJnZXQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGEgdHJhbnNmb3JtIHRvIHRyaWNrIFNhZmFyaSBpbnRvIHRoaW5raW5nIHRoZSBpbnB1dCBpcyBhdCB0aGUgdG9wIG9mIHRoZSBwYWdlXG4gICAgICAgICAgICAvLyBzbyBpdCBkb2Vzbid0IHRyeSB0byBzY3JvbGwgaXQgaW50byB2aWV3LiBXaGVuIHRhcHBpbmcgb24gYW4gaW5wdXQsIHRoaXMgbmVlZHMgdG9cbiAgICAgICAgICAgIC8vIGJlIGRvbmUgYmVmb3JlIHRoZSBcImZvY3VzXCIgZXZlbnQsIHNvIHdlIGhhdmUgdG8gZm9jdXMgdGhlIGVsZW1lbnQgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlWSgtMjAwMHB4KVwiO1xuICAgICAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntcbiAgICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gXCJcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgb25Gb2N1cyA9IChlKT0+e1xuICAgICAgICBsZXQgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIGlmICgkNDljNTFjMjUzNjFkNGNkMiR2YXIkd2lsbE9wZW5LZXlib2FyZCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gYWxzbyBuZWVkcyB0byBiZSBhcHBsaWVkIGluIHRoZSBmb2N1cyBldmVudCBpbiBjYXNlcyB3aGVyZSBmb2N1cyBtb3Zlc1xuICAgICAgICAgICAgLy8gb3RoZXIgdGhhbiB0YXBwaW5nIG9uIGFuIGlucHV0IGRpcmVjdGx5LCBlLmcuIHRoZSBuZXh0L3ByZXZpb3VzIGJ1dHRvbnMgaW4gdGhlXG4gICAgICAgICAgICAvLyBzb2Z0d2FyZSBrZXlib2FyZC4gSW4gdGhlc2UgY2FzZXMsIGl0IHNlZW1zIGFwcGx5aW5nIHRoZSB0cmFuc2Zvcm0gaW4gdGhlIGZvY3VzIGV2ZW50XG4gICAgICAgICAgICAvLyBpcyBnb29kIGVub3VnaCwgd2hlcmVhcyB3aGVuIHRhcHBpbmcgYW4gaW5wdXQsIGl0IG11c3QgYmUgZG9uZSBiZWZvcmUgdGhlIGZvY3VzIGV2ZW50LiDwn6S34oCN4pmC77iPXG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVZKC0yMDAwcHgpXCI7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntcbiAgICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gXCJcIjtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgaGF2ZSBwcmV2ZW50ZWQgdGhlIGJyb3dzZXIgZnJvbSBzY3JvbGxpbmcgdGhlIGZvY3VzZWQgZWxlbWVudCBpbnRvIHZpZXcsXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBkbyB0aGlzIG91cnNlbHZlcyBpbiBhIHdheSB0aGF0IGRvZXNuJ3QgY2F1c2UgdGhlIHdob2xlIHBhZ2UgdG8gc2Nyb2xsLlxuICAgICAgICAgICAgICAgIGlmICgkNDljNTFjMjUzNjFkNGNkMiR2YXIkdmlzdWFsVmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQ0OWM1MWMyNTM2MWQ0Y2QyJHZhciR2aXN1YWxWaWV3cG9ydC5oZWlnaHQgPCB3aW5kb3cuaW5uZXJIZWlnaHQpIC8vIElmIHRoZSBrZXlib2FyZCBpcyBhbHJlYWR5IHZpc2libGUsIGRvIHRoaXMgYWZ0ZXIgb25lIGFkZGl0aW9uYWwgZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gd2FpdCBmb3IgdGhlIHRyYW5zZm9ybSB0byBiZSByZW1vdmVkLlxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICQ0OWM1MWMyNTM2MWQ0Y2QyJHZhciRzY3JvbGxJbnRvVmlldyh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSAvLyBPdGhlcndpc2UsIHdhaXQgZm9yIHRoZSB2aXN1YWwgdmlld3BvcnQgdG8gcmVzaXplIGJlZm9yZSBzY3JvbGxpbmcgc28gd2UgY2FuXG4gICAgICAgICAgICAgICAgICAgIC8vIG1lYXN1cmUgdGhlIGNvcnJlY3QgcG9zaXRpb24gdG8gc2Nyb2xsIHRvLlxuICAgICAgICAgICAgICAgICAgICAkNDljNTFjMjUzNjFkNGNkMiR2YXIkdmlzdWFsVmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCAoKT0+JDQ5YzUxYzI1MzYxZDRjZDIkdmFyJHNjcm9sbEludG9WaWV3KHRhcmdldCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBvbldpbmRvd1Njcm9sbCA9ICgpPT57XG4gICAgICAgIC8vIExhc3QgcmVzb3J0LiBJZiB0aGUgd2luZG93IHNjcm9sbGVkLCBzY3JvbGwgaXQgYmFjayB0byB0aGUgdG9wLlxuICAgICAgICAvLyBJdCBzaG91bGQgYWx3YXlzIGJlIGF0IHRoZSB0b3AgYmVjYXVzZSB0aGUgYm9keSB3aWxsIGhhdmUgYSBuZWdhdGl2ZSBtYXJnaW4gKHNlZSBiZWxvdykuXG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICB9O1xuICAgIC8vIFJlY29yZCB0aGUgb3JpZ2luYWwgc2Nyb2xsIHBvc2l0aW9uIHNvIHdlIGNhbiByZXN0b3JlIGl0LlxuICAgIC8vIFRoZW4gYXBwbHkgYSBuZWdhdGl2ZSBtYXJnaW4gdG8gdGhlIGJvZHkgdG8gb2Zmc2V0IGl0IGJ5IHRoZSBzY3JvbGwgcG9zaXRpb24uIFRoaXMgd2lsbFxuICAgIC8vIGVuYWJsZSB1cyB0byBzY3JvbGwgdGhlIHdpbmRvdyB0byB0aGUgdG9wLCB3aGljaCBpcyByZXF1aXJlZCBmb3IgdGhlIHJlc3Qgb2YgdGhpcyB0byB3b3JrLlxuICAgIGxldCBzY3JvbGxYID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgIGxldCBzY3JvbGxZID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIGxldCByZXN0b3JlU3R5bGVzID0gKDAsICRrN1FPcyRjaGFpbikoJDQ5YzUxYzI1MzYxZDRjZDIkdmFyJHNldFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgXCJwYWRkaW5nUmlnaHRcIiwgYCR7d2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGh9cHhgKSwgJDQ5YzUxYzI1MzYxZDRjZDIkdmFyJHNldFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgXCJvdmVyZmxvd1wiLCBcImhpZGRlblwiKSwgJDQ5YzUxYzI1MzYxZDRjZDIkdmFyJHNldFN0eWxlKGRvY3VtZW50LmJvZHksIFwibWFyZ2luVG9wXCIsIGAtJHtzY3JvbGxZfXB4YCkpO1xuICAgIC8vIFNjcm9sbCB0byB0aGUgdG9wLiBUaGUgbmVnYXRpdmUgbWFyZ2luIG9uIHRoZSBib2R5IHdpbGwgbWFrZSB0aGlzIGFwcGVhciB0aGUgc2FtZS5cbiAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgbGV0IHJlbW92ZUV2ZW50cyA9ICgwLCAkazdRT3MkY2hhaW4pKCQ0OWM1MWMyNTM2MWQ0Y2QyJHZhciRhZGRFdmVudChkb2N1bWVudCwgXCJ0b3VjaHN0YXJ0XCIsIG9uVG91Y2hTdGFydCwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pLCAkNDljNTFjMjUzNjFkNGNkMiR2YXIkYWRkRXZlbnQoZG9jdW1lbnQsIFwidG91Y2htb3ZlXCIsIG9uVG91Y2hNb3ZlLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSksICQ0OWM1MWMyNTM2MWQ0Y2QyJHZhciRhZGRFdmVudChkb2N1bWVudCwgXCJ0b3VjaGVuZFwiLCBvblRvdWNoRW5kLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSksICQ0OWM1MWMyNTM2MWQ0Y2QyJHZhciRhZGRFdmVudChkb2N1bWVudCwgXCJmb2N1c1wiLCBvbkZvY3VzLCB0cnVlKSwgJDQ5YzUxYzI1MzYxZDRjZDIkdmFyJGFkZEV2ZW50KHdpbmRvdywgXCJzY3JvbGxcIiwgb25XaW5kb3dTY3JvbGwpKTtcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgLy8gUmVzdG9yZSBzdHlsZXMgYW5kIHNjcm9sbCB0aGUgcGFnZSBiYWNrIHRvIHdoZXJlIGl0IHdhcy5cbiAgICAgICAgcmVzdG9yZVN0eWxlcygpO1xuICAgICAgICByZW1vdmVFdmVudHMoKTtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHNjcm9sbFgsIHNjcm9sbFkpO1xuICAgIH07XG59XG4vLyBTZXRzIGEgQ1NTIHByb3BlcnR5IG9uIGFuIGVsZW1lbnQsIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gcmV2ZXJ0IGl0IHRvIHRoZSBwcmV2aW91cyB2YWx1ZS5cbmZ1bmN0aW9uICQ0OWM1MWMyNTM2MWQ0Y2QyJHZhciRzZXRTdHlsZShlbGVtZW50LCBzdHlsZSwgdmFsdWUpIHtcbiAgICBsZXQgY3VyID0gZWxlbWVudC5zdHlsZVtzdHlsZV07XG4gICAgZWxlbWVudC5zdHlsZVtzdHlsZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZV0gPSBjdXI7XG4gICAgfTtcbn1cbi8vIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYW4gZWxlbWVudCwgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB0byByZW1vdmUgaXQuXG5mdW5jdGlvbiAkNDljNTFjMjUzNjFkNGNkMiR2YXIkYWRkRXZlbnQodGFyZ2V0LCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH07XG59XG5mdW5jdGlvbiAkNDljNTFjMjUzNjFkNGNkMiR2YXIkc2Nyb2xsSW50b1ZpZXcodGFyZ2V0KSB7XG4gICAgbGV0IHJvb3QgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB3aGlsZSh0YXJnZXQgJiYgdGFyZ2V0ICE9PSByb290KXtcbiAgICAgICAgLy8gRmluZCB0aGUgcGFyZW50IHNjcm9sbGFibGUgZWxlbWVudCBhbmQgYWRqdXN0IHRoZSBzY3JvbGwgcG9zaXRpb24gaWYgdGhlIHRhcmdldCBpcyBub3QgYWxyZWFkeSBpbiB2aWV3LlxuICAgICAgICBsZXQgc2Nyb2xsYWJsZSA9ICgwLCAkazdRT3MkZ2V0U2Nyb2xsUGFyZW50KSh0YXJnZXQpO1xuICAgICAgICBpZiAoc2Nyb2xsYWJsZSAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIHNjcm9sbGFibGUgIT09IGRvY3VtZW50LmJvZHkgJiYgc2Nyb2xsYWJsZSAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsYWJsZVRvcCA9IHNjcm9sbGFibGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICAgICAgbGV0IHRhcmdldFRvcCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgICAgICBpZiAodGFyZ2V0VG9wID4gc2Nyb2xsYWJsZVRvcCArIHRhcmdldC5jbGllbnRIZWlnaHQpIHNjcm9sbGFibGUuc2Nyb2xsVG9wICs9IHRhcmdldFRvcCAtIHNjcm9sbGFibGVUb3A7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0ID0gc2Nyb2xsYWJsZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uICQ0OWM1MWMyNTM2MWQ0Y2QyJHZhciR3aWxsT3BlbktleWJvYXJkKHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmICEkNDljNTFjMjUzNjFkNGNkMiR2YXIkbm9uVGV4dElucHV0VHlwZXMuaGFzKHRhcmdldC50eXBlKSB8fCB0YXJnZXQgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50IHx8IHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuY29uc3QgJGY1N2FlZDRhODgxYTM0ODUkdmFyJENvbnRleHQgPSAvKiNfX1BVUkVfXyovICgwLCAkazdRT3MkcmVhY3QpLmNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiAkZjU3YWVkNGE4ODFhMzQ4NSRleHBvcnQkMTc4NDA1YWZjZDhjNWViKHByb3BzKSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgICBsZXQgcGFyZW50ID0gKDAsICRrN1FPcyR1c2VDb250ZXh0KSgkZjU3YWVkNGE4ODFhMzQ4NSR2YXIkQ29udGV4dCk7XG4gICAgbGV0IFttb2RhbENvdW50LCBzZXRNb2RhbENvdW50XSA9ICgwLCAkazdRT3MkdXNlU3RhdGUpKDApO1xuICAgIGxldCBjb250ZXh0ID0gKDAsICRrN1FPcyR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgICAgbW9kYWxDb3VudDogbW9kYWxDb3VudCxcbiAgICAgICAgICAgIGFkZE1vZGFsICgpIHtcbiAgICAgICAgICAgICAgICBzZXRNb2RhbENvdW50KChjb3VudCk9PmNvdW50ICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkgcGFyZW50LmFkZE1vZGFsKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlTW9kYWwgKCkge1xuICAgICAgICAgICAgICAgIHNldE1vZGFsQ291bnQoKGNvdW50KT0+Y291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlTW9kYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFtcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBtb2RhbENvdW50XG4gICAgXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICRrN1FPcyRyZWFjdCkuY3JlYXRlRWxlbWVudCgkZjU3YWVkNGE4ODFhMzQ4NSR2YXIkQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogY29udGV4dFxuICAgIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uICRmNTdhZWQ0YTg4MWEzNDg1JGV4cG9ydCRkOWFhZWQ0YzNlY2UxYmMwKCkge1xuICAgIGxldCBjb250ZXh0ID0gKDAsICRrN1FPcyR1c2VDb250ZXh0KSgkZjU3YWVkNGE4ODFhMzQ4NSR2YXIkQ29udGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbW9kYWxQcm92aWRlclByb3BzOiB7XG4gICAgICAgICAgICBcImFyaWEtaGlkZGVuXCI6IGNvbnRleHQgJiYgY29udGV4dC5tb2RhbENvdW50ID4gMCA/IHRydWUgOiBudWxsXG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgcm9vdCBub2RlIHRoYXQgd2lsbCBiZSBhcmlhLWhpZGRlbiBpZiB0aGVyZSBhcmUgb3RoZXIgbW9kYWxzIG9wZW4uXG4gKi8gZnVuY3Rpb24gJGY1N2FlZDRhODgxYTM0ODUkdmFyJE92ZXJsYXlDb250YWluZXJET00ocHJvcHMpIHtcbiAgICBsZXQgeyBtb2RhbFByb3ZpZGVyUHJvcHM6IG1vZGFsUHJvdmlkZXJQcm9wcyB9ID0gJGY1N2FlZDRhODgxYTM0ODUkZXhwb3J0JGQ5YWFlZDRjM2VjZTFiYzAoKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJGs3UU9zJHJlYWN0KS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgXCJkYXRhLW92ZXJsYXktY29udGFpbmVyXCI6IHRydWUsXG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICAuLi5tb2RhbFByb3ZpZGVyUHJvcHNcbiAgICB9KTtcbn1cbmZ1bmN0aW9uICRmNTdhZWQ0YTg4MWEzNDg1JGV4cG9ydCRiZjY4ODIyMWY1OTAyNGU1KHByb3BzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICRrN1FPcyRyZWFjdCkuY3JlYXRlRWxlbWVudCgkZjU3YWVkNGE4ODFhMzQ4NSRleHBvcnQkMTc4NDA1YWZjZDhjNWViLCBudWxsLCAvKiNfX1BVUkVfXyovICgwLCAkazdRT3MkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoJGY1N2FlZDRhODgxYTM0ODUkdmFyJE92ZXJsYXlDb250YWluZXJET00sIHByb3BzKSk7XG59XG5mdW5jdGlvbiAkZjU3YWVkNGE4ODFhMzQ4NSRleHBvcnQkYjQ3YzM1OTRlYWI1ODM4Nihwcm9wcykge1xuICAgIGxldCBpc1NTUiA9ICgwLCAkazdRT3MkdXNlSXNTU1IpKCk7XG4gICAgbGV0IHsgcG9ydGFsQ29udGFpbmVyOiBwb3J0YWxDb250YWluZXIgPSBpc1NTUiA/IG51bGwgOiBkb2N1bWVudC5ib2R5LCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgICAoMCwgJGs3UU9zJHJlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKHBvcnRhbENvbnRhaW5lciA9PT0gbnVsbCB8fCBwb3J0YWxDb250YWluZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcnRhbENvbnRhaW5lci5jbG9zZXN0KFwiW2RhdGEtb3ZlcmxheS1jb250YWluZXJdXCIpKSB0aHJvdyBuZXcgRXJyb3IoXCJBbiBPdmVybGF5Q29udGFpbmVyIG11c3Qgbm90IGJlIGluc2lkZSBhbm90aGVyIGNvbnRhaW5lci4gUGxlYXNlIGNoYW5nZSB0aGUgcG9ydGFsQ29udGFpbmVyIHByb3AuXCIpO1xuICAgIH0sIFtcbiAgICAgICAgcG9ydGFsQ29udGFpbmVyXG4gICAgXSk7XG4gICAgaWYgKCFwb3J0YWxDb250YWluZXIpIHJldHVybiBudWxsO1xuICAgIGxldCBjb250ZW50cyA9IC8qI19fUFVSRV9fKi8gKDAsICRrN1FPcyRyZWFjdCkuY3JlYXRlRWxlbWVudCgkZjU3YWVkNGE4ODFhMzQ4NSRleHBvcnQkYmY2ODgyMjFmNTkwMjRlNSwgcmVzdCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICRrN1FPcyRyZWFjdGRvbSkuY3JlYXRlUG9ydGFsKGNvbnRlbnRzLCBwb3J0YWxDb250YWluZXIpO1xufVxuZnVuY3Rpb24gJGY1N2FlZDRhODgxYTM0ODUkZXhwb3J0JDMzZmZkNzRlYmYwN2YwNjAob3B0aW9ucykge1xuICAgIC8vIEFkZCBhcmlhLWhpZGRlbiB0byBhbGwgcGFyZW50IHByb3ZpZGVycyBvbiBtb3VudCwgYW5kIHJlc3RvcmUgb24gdW5tb3VudC5cbiAgICBsZXQgY29udGV4dCA9ICgwLCAkazdRT3MkdXNlQ29udGV4dCkoJGY1N2FlZDRhODgxYTM0ODUkdmFyJENvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkgdGhyb3cgbmV3IEVycm9yKFwiTW9kYWwgaXMgbm90IGNvbnRhaW5lZCB3aXRoaW4gYSBwcm92aWRlclwiKTtcbiAgICAoMCwgJGs3UU9zJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaXNEaXNhYmxlZCkgfHwgIWNvbnRleHQgfHwgIWNvbnRleHQucGFyZW50KSByZXR1cm47XG4gICAgICAgIC8vIFRoZSBpbW1lZGlhdGUgY29udGV4dCBpcyBmcm9tIHRoZSBwcm92aWRlciBjb250YWluaW5nIHRoaXMgbW9kYWwsIHNvIHdlIG9ubHlcbiAgICAgICAgLy8gd2FudCB0byB0cmlnZ2VyIGFyaWEtaGlkZGVuIG9uIGl0cyBwYXJlbnRzIG5vdCBvbiB0aGUgbW9kYWwgcHJvdmlkZXIgaXRzZWxmLlxuICAgICAgICBjb250ZXh0LnBhcmVudC5hZGRNb2RhbCgpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQucGFyZW50KSBjb250ZXh0LnBhcmVudC5yZW1vdmVNb2RhbCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY29udGV4dC5wYXJlbnQsXG4gICAgICAgIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pc0Rpc2FibGVkXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbW9kYWxQcm9wczoge1xuICAgICAgICAgICAgXCJkYXRhLWlzbW9kYWxcIjogIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaXNEaXNhYmxlZClcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIHZhciAkYTJmMjFmNWYxNGY2MDU1MyRleHBvcnRzID0ge307XG52YXIgJDc3M2Q1ODg4Yjk3MmYxY2YkZXhwb3J0cyA9IHt9O1xuJDc3M2Q1ODg4Yjk3MmYxY2YkZXhwb3J0cyA9IHtcbiAgICBcImRpc21pc3NcIjogYFxcdXs2MkF9XFx1ezYyQ31cXHV7NjI3fVxcdXs2NDd9XFx1ezY0NH1gXG59O1xuXG5cbnZhciAkZDExZjE5ODUyYjk0MTU3MyRleHBvcnRzID0ge307XG4kZDExZjE5ODUyYjk0MTU3MyRleHBvcnRzID0ge1xuICAgIFwiZGlzbWlzc1wiOiBgXFx1ezQxRX1cXHV7NDQyfVxcdXs0NDV9XFx1ezQzMn1cXHV7NDRBfVxcdXs0NDB9XFx1ezQzQn1cXHV7NDRGfVxcdXs0M0R9XFx1ezQzNX1gXG59O1xuXG5cbnZhciAkYjk4Mzk3NGMyZWUxZWZiMyRleHBvcnRzID0ge307XG4kYjk4Mzk3NGMyZWUxZWZiMyRleHBvcnRzID0ge1xuICAgIFwiZGlzbWlzc1wiOiBgT2RzdHJhbml0YFxufTtcblxuXG52YXIgJDU4MDljYzlkNGU5MmRlNzMkZXhwb3J0cyA9IHt9O1xuJDU4MDljYzlkNGU5MmRlNzMkZXhwb3J0cyA9IHtcbiAgICBcImRpc21pc3NcIjogYEx1a2Bcbn07XG5cblxudmFyICRjNjhjMmU0ZmM3NDM5OGQxJGV4cG9ydHMgPSB7fTtcbiRjNjhjMmU0ZmM3NDM5OGQxJGV4cG9ydHMgPSB7XG4gICAgXCJkaXNtaXNzXCI6IGBTY2hsaWVcXHhkZmVuYFxufTtcblxuXG52YXIgJDA4OThiNGMxNTNkYjJiNzckZXhwb3J0cyA9IHt9O1xuJDA4OThiNGMxNTNkYjJiNzckZXhwb3J0cyA9IHtcbiAgICBcImRpc21pc3NcIjogYFxcdXszOTF9XFx1ezNDMH1cXHV7M0NDfVxcdXszQzF9XFx1ezNDMX1cXHV7M0I5fVxcdXszQzh9XFx1ezNCN31gXG59O1xuXG5cbnZhciAkNmQ3NDgxMDI4NmExNTE4MyRleHBvcnRzID0ge307XG4kNmQ3NDgxMDI4NmExNTE4MyRleHBvcnRzID0ge1xuICAgIFwiZGlzbWlzc1wiOiBgRGlzbWlzc2Bcbn07XG5cblxudmFyICQzMDlkNzNkYzY1Zjc4MDU1JGV4cG9ydHMgPSB7fTtcbiQzMDlkNzNkYzY1Zjc4MDU1JGV4cG9ydHMgPSB7XG4gICAgXCJkaXNtaXNzXCI6IGBEZXNjYXJ0YXJgXG59O1xuXG5cbnZhciAkNDRhZDk0ZjcyMDVjZjU5MyRleHBvcnRzID0ge307XG4kNDRhZDk0ZjcyMDVjZjU5MyRleHBvcnRzID0ge1xuICAgIFwiZGlzbWlzc1wiOiBgTFxceGY1cGV0YWBcbn07XG5cblxudmFyICQ3YzI4ZjU2ODdmMDc3OWE5JGV4cG9ydHMgPSB7fTtcbiQ3YzI4ZjU2ODdmMDc3OWE5JGV4cG9ydHMgPSB7XG4gICAgXCJkaXNtaXNzXCI6IGBIeWxrXFx4ZTRcXHhlNGBcbn07XG5cblxudmFyICRlNmQ3NWRmNGI2OGJkNzNhJGV4cG9ydHMgPSB7fTtcbiRlNmQ3NWRmNGI2OGJkNzNhJGV4cG9ydHMgPSB7XG4gICAgXCJkaXNtaXNzXCI6IGBSZWpldGVyYFxufTtcblxuXG52YXIgJDg3NTA1YzlkYWIxODZkMGYkZXhwb3J0cyA9IHt9O1xuJDg3NTA1YzlkYWIxODZkMGYkZXhwb3J0cyA9IHtcbiAgICBcImRpc21pc3NcIjogYFxcdXs1RDR9XFx1ezVFQX1cXHV7NUUyfVxcdXs1REN9XFx1ezVERH1gXG59O1xuXG5cbnZhciAkNTUzNDM5YzNmZmIzZTQ5MiRleHBvcnRzID0ge307XG4kNTUzNDM5YzNmZmIzZTQ5MiRleHBvcnRzID0ge1xuICAgIFwiZGlzbWlzc1wiOiBgT2RiYWNpYFxufTtcblxuXG52YXIgJDc0Y2Y0MTEwNjFiOTgzYTIkZXhwb3J0cyA9IHt9O1xuJDc0Y2Y0MTEwNjFiOTgzYTIkZXhwb3J0cyA9IHtcbiAgICBcImRpc21pc3NcIjogYEVsdXRhc1xceGVkdFxceGUxc2Bcbn07XG5cblxudmFyICRlOTMzZjI5ODU3NGRjNDM1JGV4cG9ydHMgPSB7fTtcbiRlOTMzZjI5ODU3NGRjNDM1JGV4cG9ydHMgPSB7XG4gICAgXCJkaXNtaXNzXCI6IGBJZ25vcmFgXG59O1xuXG5cbnZhciAkYWM5MWZjOWZlMDJmNzFmNiRleHBvcnRzID0ge307XG4kYWM5MWZjOWZlMDJmNzFmNiRleHBvcnRzID0ge1xuICAgIFwiZGlzbWlzc1wiOiBgXFx1ezk1ODl9XFx1ezMwNTh9XFx1ezMwOEJ9YFxufTtcblxuXG52YXIgJDUyYjk2Zjg2NDIyMDI1YWYkZXhwb3J0cyA9IHt9O1xuJDUyYjk2Zjg2NDIyMDI1YWYkZXhwb3J0cyA9IHtcbiAgICBcImRpc21pc3NcIjogYFxcdXtCQjM0fVxcdXtDMkRDfWBcbn07XG5cblxudmFyICRjMGQ3MjRjM2U1MWRhZmE2JGV4cG9ydHMgPSB7fTtcbiRjMGQ3MjRjM2U1MWRhZmE2JGV4cG9ydHMgPSB7XG4gICAgXCJkaXNtaXNzXCI6IGBBdG1lc3RpYFxufTtcblxuXG52YXIgJGM5Mjg5OTY3MmEzZmU3MmUkZXhwb3J0cyA9IHt9O1xuJGM5Mjg5OTY3MmEzZmU3MmUkZXhwb3J0cyA9IHtcbiAgICBcImRpc21pc3NcIjogYE5lclxcdXsxMDF9ZFxcdXsxMkJ9dGBcbn07XG5cblxudmFyICQ5ZjU3NmIzOWQ4ZTdhOWQ2JGV4cG9ydHMgPSB7fTtcbiQ5ZjU3NmIzOWQ4ZTdhOWQ2JGV4cG9ydHMgPSB7XG4gICAgXCJkaXNtaXNzXCI6IGBMdWtrYFxufTtcblxuXG52YXIgJDlkMDI1ODA4YWVlYzgxYTckZXhwb3J0cyA9IHt9O1xuJDlkMDI1ODA4YWVlYzgxYTckZXhwb3J0cyA9IHtcbiAgICBcImRpc21pc3NcIjogYE5lZ2VyZW5gXG59O1xuXG5cbnZhciAkZmNlNzA5OTIxZTJjMGZhNiRleHBvcnRzID0ge307XG4kZmNlNzA5OTIxZTJjMGZhNiRleHBvcnRzID0ge1xuICAgIFwiZGlzbWlzc1wiOiBgWmlnbm9ydWpgXG59O1xuXG5cbnZhciAkMjU5OWNmMGM0YWIzN2Y1OSRleHBvcnRzID0ge307XG4kMjU5OWNmMGM0YWIzN2Y1OSRleHBvcnRzID0ge1xuICAgIFwiZGlzbWlzc1wiOiBgRGVzY2FydGFyYFxufTtcblxuXG52YXIgJDNjMjIwYWU3ZWY4YTM1ZmQkZXhwb3J0cyA9IHt9O1xuJDNjMjIwYWU3ZWY4YTM1ZmQkZXhwb3J0cyA9IHtcbiAgICBcImRpc21pc3NcIjogYERpc3BlbnNhcmBcbn07XG5cblxudmFyICQ5MzU2MmI1MDk0MDcyZjU0JGV4cG9ydHMgPSB7fTtcbiQ5MzU2MmI1MDk0MDcyZjU0JGV4cG9ydHMgPSB7XG4gICAgXCJkaXNtaXNzXCI6IGBSZXZvY2FyZWBcbn07XG5cblxudmFyICRjZDllMmFiZDBkMDZjN2I0JGV4cG9ydHMgPSB7fTtcbiRjZDllMmFiZDBkMDZjN2I0JGV4cG9ydHMgPSB7XG4gICAgXCJkaXNtaXNzXCI6IGBcXHV7NDFGfVxcdXs0NDB9XFx1ezQzRX1cXHV7NDNGfVxcdXs0NDN9XFx1ezQ0MX1cXHV7NDQyfVxcdXs0Mzh9XFx1ezQ0Mn1cXHV7NDRDfWBcbn07XG5cblxudmFyICQ0NTM3NTcwMWY0MDlhZGYxJGV4cG9ydHMgPSB7fTtcbiQ0NTM3NTcwMWY0MDlhZGYxJGV4cG9ydHMgPSB7XG4gICAgXCJkaXNtaXNzXCI6IGBacnVcXHV7MTYxfWlcXHV7MTY1fWBcbn07XG5cblxudmFyICQyN2ZhYjUzYTU3NmRlOWRkJGV4cG9ydHMgPSB7fTtcbiQyN2ZhYjUzYTU3NmRlOWRkJGV4cG9ydHMgPSB7XG4gICAgXCJkaXNtaXNzXCI6IGBPcHVzdGlgXG59O1xuXG5cbnZhciAkNDQzODc0OGQ5OTUyZTdjNyRleHBvcnRzID0ge307XG4kNDQzODc0OGQ5OTUyZTdjNyRleHBvcnRzID0ge1xuICAgIFwiZGlzbWlzc1wiOiBgT2RiYWNpYFxufTtcblxuXG52YXIgJDA5MzZkNzM0N2VmNGRhNGMkZXhwb3J0cyA9IHt9O1xuJDA5MzZkNzM0N2VmNGRhNGMkZXhwb3J0cyA9IHtcbiAgICBcImRpc21pc3NcIjogYEF2dmlzYWBcbn07XG5cblxudmFyICQyOTcwMGM5MjE4NWQzOGY4JGV4cG9ydHMgPSB7fTtcbiQyOTcwMGM5MjE4NWQzOGY4JGV4cG9ydHMgPSB7XG4gICAgXCJkaXNtaXNzXCI6IGBLYXBhdGBcbn07XG5cblxudmFyICQ2NjJjY2FmMmJlNGMyNWIzJGV4cG9ydHMgPSB7fTtcbiQ2NjJjY2FmMmJlNGMyNWIzJGV4cG9ydHMgPSB7XG4gICAgXCJkaXNtaXNzXCI6IGBcXHV7NDIxfVxcdXs0M0F9XFx1ezQzMH1cXHV7NDQxfVxcdXs0NDN9XFx1ezQzMn1cXHV7NDMwfVxcdXs0NDJ9XFx1ezQzOH1gXG59O1xuXG5cbnZhciAkZDgwYTI3ZGVkYTdjZGIzYyRleHBvcnRzID0ge307XG4kZDgwYTI3ZGVkYTdjZGIzYyRleHBvcnRzID0ge1xuICAgIFwiZGlzbWlzc1wiOiBgXFx1ezUzRDZ9XFx1ezZEODh9YFxufTtcblxuXG52YXIgJDJiMjczNDM5Mzg0N2M4ODQkZXhwb3J0cyA9IHt9O1xuJDJiMjczNDM5Mzg0N2M4ODQkZXhwb3J0cyA9IHtcbiAgICBcImRpc21pc3NcIjogYFxcdXs5NURDfVxcdXs5NTg5fWBcbn07XG5cblxuJGEyZjIxZjVmMTRmNjA1NTMkZXhwb3J0cyA9IHtcbiAgICBcImFyLUFFXCI6ICQ3NzNkNTg4OGI5NzJmMWNmJGV4cG9ydHMsXG4gICAgXCJiZy1CR1wiOiAkZDExZjE5ODUyYjk0MTU3MyRleHBvcnRzLFxuICAgIFwiY3MtQ1pcIjogJGI5ODM5NzRjMmVlMWVmYjMkZXhwb3J0cyxcbiAgICBcImRhLURLXCI6ICQ1ODA5Y2M5ZDRlOTJkZTczJGV4cG9ydHMsXG4gICAgXCJkZS1ERVwiOiAkYzY4YzJlNGZjNzQzOThkMSRleHBvcnRzLFxuICAgIFwiZWwtR1JcIjogJDA4OThiNGMxNTNkYjJiNzckZXhwb3J0cyxcbiAgICBcImVuLVVTXCI6ICQ2ZDc0ODEwMjg2YTE1MTgzJGV4cG9ydHMsXG4gICAgXCJlcy1FU1wiOiAkMzA5ZDczZGM2NWY3ODA1NSRleHBvcnRzLFxuICAgIFwiZXQtRUVcIjogJDQ0YWQ5NGY3MjA1Y2Y1OTMkZXhwb3J0cyxcbiAgICBcImZpLUZJXCI6ICQ3YzI4ZjU2ODdmMDc3OWE5JGV4cG9ydHMsXG4gICAgXCJmci1GUlwiOiAkZTZkNzVkZjRiNjhiZDczYSRleHBvcnRzLFxuICAgIFwiaGUtSUxcIjogJDg3NTA1YzlkYWIxODZkMGYkZXhwb3J0cyxcbiAgICBcImhyLUhSXCI6ICQ1NTM0MzljM2ZmYjNlNDkyJGV4cG9ydHMsXG4gICAgXCJodS1IVVwiOiAkNzRjZjQxMTA2MWI5ODNhMiRleHBvcnRzLFxuICAgIFwiaXQtSVRcIjogJGU5MzNmMjk4NTc0ZGM0MzUkZXhwb3J0cyxcbiAgICBcImphLUpQXCI6ICRhYzkxZmM5ZmUwMmY3MWY2JGV4cG9ydHMsXG4gICAgXCJrby1LUlwiOiAkNTJiOTZmODY0MjIwMjVhZiRleHBvcnRzLFxuICAgIFwibHQtTFRcIjogJGMwZDcyNGMzZTUxZGFmYTYkZXhwb3J0cyxcbiAgICBcImx2LUxWXCI6ICRjOTI4OTk2NzJhM2ZlNzJlJGV4cG9ydHMsXG4gICAgXCJuYi1OT1wiOiAkOWY1NzZiMzlkOGU3YTlkNiRleHBvcnRzLFxuICAgIFwibmwtTkxcIjogJDlkMDI1ODA4YWVlYzgxYTckZXhwb3J0cyxcbiAgICBcInBsLVBMXCI6ICRmY2U3MDk5MjFlMmMwZmE2JGV4cG9ydHMsXG4gICAgXCJwdC1CUlwiOiAkMjU5OWNmMGM0YWIzN2Y1OSRleHBvcnRzLFxuICAgIFwicHQtUFRcIjogJDNjMjIwYWU3ZWY4YTM1ZmQkZXhwb3J0cyxcbiAgICBcInJvLVJPXCI6ICQ5MzU2MmI1MDk0MDcyZjU0JGV4cG9ydHMsXG4gICAgXCJydS1SVVwiOiAkY2Q5ZTJhYmQwZDA2YzdiNCRleHBvcnRzLFxuICAgIFwic2stU0tcIjogJDQ1Mzc1NzAxZjQwOWFkZjEkZXhwb3J0cyxcbiAgICBcInNsLVNJXCI6ICQyN2ZhYjUzYTU3NmRlOWRkJGV4cG9ydHMsXG4gICAgXCJzci1TUFwiOiAkNDQzODc0OGQ5OTUyZTdjNyRleHBvcnRzLFxuICAgIFwic3YtU0VcIjogJDA5MzZkNzM0N2VmNGRhNGMkZXhwb3J0cyxcbiAgICBcInRyLVRSXCI6ICQyOTcwMGM5MjE4NWQzOGY4JGV4cG9ydHMsXG4gICAgXCJ1ay1VQVwiOiAkNjYyY2NhZjJiZTRjMjViMyRleHBvcnRzLFxuICAgIFwiemgtQ05cIjogJGQ4MGEyN2RlZGE3Y2RiM2MkZXhwb3J0cyxcbiAgICBcInpoLVRXXCI6ICQyYjI3MzQzOTM4NDdjODg0JGV4cG9ydHNcbn07XG5cblxuXG5cblxuXG5mdW5jdGlvbiAkODZlYTRjYjUyMWViMmUzNyRleHBvcnQkMjMxN2QxNDllZDZmNzhjNChwcm9wcykge1xuICAgIGxldCB7IG9uRGlzbWlzczogb25EaXNtaXNzLCAuLi5vdGhlclByb3BzIH0gPSBwcm9wcztcbiAgICBsZXQgc3RyaW5nRm9ybWF0dGVyID0gKDAsICRrN1FPcyR1c2VMb2NhbGl6ZWRTdHJpbmdGb3JtYXR0ZXIpKCgwLCAoLypAX19QVVJFX18qLyRwYXJjZWwkaW50ZXJvcERlZmF1bHQoJGEyZjIxZjVmMTRmNjA1NTMkZXhwb3J0cykpKSk7XG4gICAgbGV0IGxhYmVscyA9ICgwLCAkazdRT3MkdXNlTGFiZWxzKShvdGhlclByb3BzLCBzdHJpbmdGb3JtYXR0ZXIuZm9ybWF0KFwiZGlzbWlzc1wiKSk7XG4gICAgbGV0IG9uQ2xpY2sgPSAoKT0+e1xuICAgICAgICBpZiAob25EaXNtaXNzKSBvbkRpc21pc3MoKTtcbiAgICB9O1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkazdRT3MkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoKDAsICRrN1FPcyRWaXN1YWxseUhpZGRlbiksIG51bGwsIC8qI19fUFVSRV9fKi8gKDAsICRrN1FPcyRyZWFjdCkuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAgICAgIC4uLmxhYmVscyxcbiAgICAgICAgdGFiSW5kZXg6IC0xLFxuICAgICAgICBvbkNsaWNrOiBvbkNsaWNrXG4gICAgfSkpO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvLyBLZWVwcyBhIHJlZiBjb3VudCBvZiBhbGwgaGlkZGVuIGVsZW1lbnRzLiBBZGRlZCB0byB3aGVuIGhpZGluZyBhbiBlbGVtZW50LCBhbmRcbi8vIHN1YnRyYWN0ZWQgZnJvbSB3aGVuIHNob3dpbmcgaXQgYWdhaW4uIFdoZW4gaXQgcmVhY2hlcyB6ZXJvLCBhcmlhLWhpZGRlbiBpcyByZW1vdmVkLlxubGV0ICQ1ZTM4MDI2NDVjYzE5MzE5JHZhciRyZWZDb3VudE1hcCA9IG5ldyBXZWFrTWFwKCk7XG5sZXQgJDVlMzgwMjY0NWNjMTkzMTkkdmFyJG9ic2VydmVyU3RhY2sgPSBbXTtcbmZ1bmN0aW9uICQ1ZTM4MDI2NDVjYzE5MzE5JGV4cG9ydCQxYzNlYmNhZGExODQyN2JmKHRhcmdldHMsIHJvb3QgPSBkb2N1bWVudC5ib2R5KSB7XG4gICAgbGV0IHZpc2libGVOb2RlcyA9IG5ldyBTZXQodGFyZ2V0cyk7XG4gICAgbGV0IGhpZGRlbk5vZGVzID0gbmV3IFNldCgpO1xuICAgIGxldCB3YWxrID0gKHJvb3QpPT57XG4gICAgICAgIC8vIEtlZXAgbGl2ZSBhbm5vdW5jZXIgYW5kIHRvcCBsYXllciBlbGVtZW50cyAoZS5nLiB0b2FzdHMpIHZpc2libGUuXG4gICAgICAgIGZvciAobGV0IGVsZW1lbnQgb2Ygcm9vdC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtbGl2ZS1hbm5vdW5jZXJdLCBbZGF0YS1yZWFjdC1hcmlhLXRvcC1sYXllcl1cIikpdmlzaWJsZU5vZGVzLmFkZChlbGVtZW50KTtcbiAgICAgICAgbGV0IGFjY2VwdE5vZGUgPSAobm9kZSk9PntcbiAgICAgICAgICAgIC8vIFNraXAgdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4gaWYgaXQgaXMgb25lIG9mIHRoZSB0YXJnZXQgbm9kZXMsIG9yIGEgbGl2ZSBhbm5vdW5jZXIuXG4gICAgICAgICAgICAvLyBBbHNvIHNraXAgY2hpbGRyZW4gb2YgYWxyZWFkeSBoaWRkZW4gbm9kZXMsIGFzIGFyaWEtaGlkZGVuIGlzIHJlY3Vyc2l2ZS4gQW4gZXhjZXB0aW9uIGlzXG4gICAgICAgICAgICAvLyBtYWRlIGZvciBlbGVtZW50cyB3aXRoIHJvbGU9XCJyb3dcIiBzaW5jZSBWb2ljZU92ZXIgb24gaU9TIGhhcyBpc3N1ZXMgaGlkaW5nIGVsZW1lbnRzIHdpdGggcm9sZT1cInJvd1wiLlxuICAgICAgICAgICAgLy8gRm9yIHRoYXQgY2FzZSB3ZSB3YW50IHRvIGhpZGUgdGhlIGNlbGxzIGluc2lkZSBhcyB3ZWxsIChodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjIyNjIzKS5cbiAgICAgICAgICAgIGlmICh2aXNpYmxlTm9kZXMuaGFzKG5vZGUpIHx8IGhpZGRlbk5vZGVzLmhhcyhub2RlLnBhcmVudEVsZW1lbnQpICYmIG5vZGUucGFyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpICE9PSBcInJvd1wiKSByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUO1xuICAgICAgICAgICAgLy8gU2tpcCB0aGlzIG5vZGUgYnV0IGNvbnRpbnVlIHRvIGNoaWxkcmVuIGlmIG9uZSBvZiB0aGUgdGFyZ2V0cyBpcyBpbnNpZGUgdGhlIG5vZGUuXG4gICAgICAgICAgICBmb3IgKGxldCB0YXJnZXQgb2YgdmlzaWJsZU5vZGVzKXtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jb250YWlucyh0YXJnZXQpKSByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XG4gICAgICAgIH07XG4gICAgICAgIGxldCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKHJvb3QsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCB7XG4gICAgICAgICAgICBhY2NlcHROb2RlOiBhY2NlcHROb2RlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmVlV2Fsa2VyIGRvZXMgbm90IGluY2x1ZGUgdGhlIHJvb3QuXG4gICAgICAgIGxldCBhY2NlcHRSb290ID0gYWNjZXB0Tm9kZShyb290KTtcbiAgICAgICAgaWYgKGFjY2VwdFJvb3QgPT09IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCkgaGlkZShyb290KTtcbiAgICAgICAgaWYgKGFjY2VwdFJvb3QgIT09IE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVCkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIHdoaWxlKG5vZGUgIT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgaGlkZShub2RlKTtcbiAgICAgICAgICAgICAgICBub2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBoaWRlID0gKG5vZGUpPT57XG4gICAgICAgIHZhciBfcmVmQ291bnRNYXBfZ2V0O1xuICAgICAgICBsZXQgcmVmQ291bnQgPSAoX3JlZkNvdW50TWFwX2dldCA9ICQ1ZTM4MDI2NDVjYzE5MzE5JHZhciRyZWZDb3VudE1hcC5nZXQobm9kZSkpICE9PSBudWxsICYmIF9yZWZDb3VudE1hcF9nZXQgIT09IHZvaWQgMCA/IF9yZWZDb3VudE1hcF9nZXQgOiAwO1xuICAgICAgICAvLyBJZiBhbHJlYWR5IGFyaWEtaGlkZGVuLCBhbmQgdGhlIHJlZiBjb3VudCBpcyB6ZXJvLCB0aGVuIHRoaXMgZWxlbWVudFxuICAgICAgICAvLyB3YXMgYWxyZWFkeSBoaWRkZW4gYW5kIHRoZXJlJ3Mgbm90aGluZyBmb3IgdXMgdG8gZG8uXG4gICAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpID09PSBcInRydWVcIiAmJiByZWZDb3VudCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICBpZiAocmVmQ291bnQgPT09IDApIG5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICBoaWRkZW5Ob2Rlcy5hZGQobm9kZSk7XG4gICAgICAgICQ1ZTM4MDI2NDVjYzE5MzE5JHZhciRyZWZDb3VudE1hcC5zZXQobm9kZSwgcmVmQ291bnQgKyAxKTtcbiAgICB9O1xuICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSBNdXRhdGlvbk9ic2VydmVyIGxpc3RlbmluZyBmcm9tIGEgcHJldmlvdXMgY2FsbCxcbiAgICAvLyBkaXNjb25uZWN0IGl0IHNvIHRoZSBuZXcgb24gdGFrZXMgb3Zlci5cbiAgICBpZiAoJDVlMzgwMjY0NWNjMTkzMTkkdmFyJG9ic2VydmVyU3RhY2subGVuZ3RoKSAkNWUzODAyNjQ1Y2MxOTMxOSR2YXIkb2JzZXJ2ZXJTdGFja1skNWUzODAyNjQ1Y2MxOTMxOSR2YXIkb2JzZXJ2ZXJTdGFjay5sZW5ndGggLSAxXS5kaXNjb25uZWN0KCk7XG4gICAgd2Fsayhyb290KTtcbiAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoY2hhbmdlcyk9PntcbiAgICAgICAgZm9yIChsZXQgY2hhbmdlIG9mIGNoYW5nZXMpe1xuICAgICAgICAgICAgaWYgKGNoYW5nZS50eXBlICE9PSBcImNoaWxkTGlzdFwiIHx8IGNoYW5nZS5hZGRlZE5vZGVzLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcGFyZW50IGVsZW1lbnQgb2YgdGhlIGFkZGVkIG5vZGVzIGlzIG5vdCB3aXRoaW4gb25lIG9mIHRoZSB0YXJnZXRzLFxuICAgICAgICAgICAgLy8gYW5kIG5vdCBhbHJlYWR5IGluc2lkZSBhIGhpZGRlbiBub2RlLCBoaWRlIGFsbCBvZiB0aGUgbmV3IGNoaWxkcmVuLlxuICAgICAgICAgICAgaWYgKCFbXG4gICAgICAgICAgICAgICAgLi4udmlzaWJsZU5vZGVzLFxuICAgICAgICAgICAgICAgIC4uLmhpZGRlbk5vZGVzXG4gICAgICAgICAgICBdLnNvbWUoKG5vZGUpPT5ub2RlLmNvbnRhaW5zKGNoYW5nZS50YXJnZXQpKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2YgY2hhbmdlLnJlbW92ZWROb2RlcylpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZU5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuTm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mIGNoYW5nZS5hZGRlZE5vZGVzKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpICYmIChub2RlLmRhdGFzZXQubGl2ZUFubm91bmNlciA9PT0gXCJ0cnVlXCIgfHwgbm9kZS5kYXRhc2V0LnJlYWN0QXJpYVRvcExheWVyID09PSBcInRydWVcIikpIHZpc2libGVOb2Rlcy5hZGQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB3YWxrKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUocm9vdCwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICB9KTtcbiAgICBsZXQgb2JzZXJ2ZXJXcmFwcGVyID0ge1xuICAgICAgICBvYnNlcnZlICgpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUocm9vdCwge1xuICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzY29ubmVjdCAoKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgICQ1ZTM4MDI2NDVjYzE5MzE5JHZhciRvYnNlcnZlclN0YWNrLnB1c2gob2JzZXJ2ZXJXcmFwcGVyKTtcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIGhpZGRlbk5vZGVzKXtcbiAgICAgICAgICAgIGxldCBjb3VudCA9ICQ1ZTM4MDI2NDVjYzE5MzE5JHZhciRyZWZDb3VudE1hcC5nZXQobm9kZSk7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgICQ1ZTM4MDI2NDVjYzE5MzE5JHZhciRyZWZDb3VudE1hcC5kZWxldGUobm9kZSk7XG4gICAgICAgICAgICB9IGVsc2UgJDVlMzgwMjY0NWNjMTkzMTkkdmFyJHJlZkNvdW50TWFwLnNldChub2RlLCBjb3VudCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIG9ic2VydmVyIGZyb20gdGhlIHN0YWNrLCBhbmQgc3RhcnQgdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgaWYgKG9ic2VydmVyV3JhcHBlciA9PT0gJDVlMzgwMjY0NWNjMTkzMTkkdmFyJG9ic2VydmVyU3RhY2tbJDVlMzgwMjY0NWNjMTkzMTkkdmFyJG9ic2VydmVyU3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICQ1ZTM4MDI2NDVjYzE5MzE5JHZhciRvYnNlcnZlclN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKCQ1ZTM4MDI2NDVjYzE5MzE5JHZhciRvYnNlcnZlclN0YWNrLmxlbmd0aCkgJDVlMzgwMjY0NWNjMTkzMTkkdmFyJG9ic2VydmVyU3RhY2tbJDVlMzgwMjY0NWNjMTkzMTkkdmFyJG9ic2VydmVyU3RhY2subGVuZ3RoIC0gMV0ub2JzZXJ2ZSgpO1xuICAgICAgICB9IGVsc2UgJDVlMzgwMjY0NWNjMTkzMTkkdmFyJG9ic2VydmVyU3RhY2suc3BsaWNlKCQ1ZTM4MDI2NDVjYzE5MzE5JHZhciRvYnNlcnZlclN0YWNrLmluZGV4T2Yob2JzZXJ2ZXJXcmFwcGVyKSwgMSk7XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuXG5cbmZ1bmN0aW9uICRmMmY4YTYwNzc0MTg1NDFlJGV4cG9ydCQ1NDJhNmZkMTNhYzkzMzU0KHByb3BzLCBzdGF0ZSkge1xuICAgIGxldCB7IHRyaWdnZXJSZWY6IHRyaWdnZXJSZWYsIHBvcG92ZXJSZWY6IHBvcG92ZXJSZWYsIGlzTm9uTW9kYWw6IGlzTm9uTW9kYWwsIGlzS2V5Ym9hcmREaXNtaXNzRGlzYWJsZWQ6IGlzS2V5Ym9hcmREaXNtaXNzRGlzYWJsZWQsIC4uLm90aGVyUHJvcHMgfSA9IHByb3BzO1xuICAgIGxldCB7IG92ZXJsYXlQcm9wczogb3ZlcmxheVByb3BzLCB1bmRlcmxheVByb3BzOiB1bmRlcmxheVByb3BzIH0gPSAoMCwgJGExMTUwMWYzZDFkMzllNmMkZXhwb3J0JGVhOGY3MTA4M2U5MDYwMGYpKHtcbiAgICAgICAgaXNPcGVuOiBzdGF0ZS5pc09wZW4sXG4gICAgICAgIG9uQ2xvc2U6IHN0YXRlLmNsb3NlLFxuICAgICAgICBzaG91bGRDbG9zZU9uQmx1cjogdHJ1ZSxcbiAgICAgICAgaXNEaXNtaXNzYWJsZTogIWlzTm9uTW9kYWwsXG4gICAgICAgIGlzS2V5Ym9hcmREaXNtaXNzRGlzYWJsZWQ6IGlzS2V5Ym9hcmREaXNtaXNzRGlzYWJsZWRcbiAgICB9LCBwb3BvdmVyUmVmKTtcbiAgICBsZXQgeyBvdmVybGF5UHJvcHM6IHBvc2l0aW9uUHJvcHMsIGFycm93UHJvcHM6IGFycm93UHJvcHMsIHBsYWNlbWVudDogcGxhY2VtZW50IH0gPSAoMCwgJDJhNDFlNDVkZjE1OTNlNjQkZXhwb3J0JGQzOWUxODEzYjNiZGQwZTEpKHtcbiAgICAgICAgLi4ub3RoZXJQcm9wcyxcbiAgICAgICAgdGFyZ2V0UmVmOiB0cmlnZ2VyUmVmLFxuICAgICAgICBvdmVybGF5UmVmOiBwb3BvdmVyUmVmLFxuICAgICAgICBpc09wZW46IHN0YXRlLmlzT3BlbixcbiAgICAgICAgb25DbG9zZTogbnVsbFxuICAgIH0pO1xuICAgICgwLCAkNDljNTFjMjUzNjFkNGNkMiRleHBvcnQkZWUwZjdjYzZhZmNkMWMxOCkoe1xuICAgICAgICBpc0Rpc2FibGVkOiBpc05vbk1vZGFsXG4gICAgfSk7XG4gICAgKDAsICRrN1FPcyR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChzdGF0ZS5pc09wZW4gJiYgIWlzTm9uTW9kYWwgJiYgcG9wb3ZlclJlZi5jdXJyZW50KSByZXR1cm4gKDAsICQ1ZTM4MDI2NDVjYzE5MzE5JGV4cG9ydCQxYzNlYmNhZGExODQyN2JmKShbXG4gICAgICAgICAgICBwb3BvdmVyUmVmLmN1cnJlbnRcbiAgICAgICAgXSk7XG4gICAgfSwgW1xuICAgICAgICBpc05vbk1vZGFsLFxuICAgICAgICBzdGF0ZS5pc09wZW4sXG4gICAgICAgIHBvcG92ZXJSZWZcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3BvdmVyUHJvcHM6ICgwLCAkazdRT3MkbWVyZ2VQcm9wcykob3ZlcmxheVByb3BzLCBwb3NpdGlvblByb3BzKSxcbiAgICAgICAgYXJyb3dQcm9wczogYXJyb3dQcm9wcyxcbiAgICAgICAgdW5kZXJsYXlQcm9wczogdW5kZXJsYXlQcm9wcyxcbiAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5cblxuXG5jb25zdCAkMzM3Yjg4NDUxMDcyNmEwZCRleHBvcnQkYTIyMDBiOTZhZmQxNjI3MSA9IC8qI19fUFVSRV9fKi8gKDAsICRrN1FPcyRyZWFjdCkuY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uICQzMzdiODg0NTEwNzI2YTBkJGV4cG9ydCRjNmZkYjgzN2IwNzBiNGZmKHByb3BzKSB7XG4gICAgbGV0IGlzU1NSID0gKDAsICRrN1FPcyR1c2VJc1NTUikoKTtcbiAgICBsZXQgeyBwb3J0YWxDb250YWluZXI6IHBvcnRhbENvbnRhaW5lciA9IGlzU1NSID8gbnVsbCA6IGRvY3VtZW50LmJvZHksIGlzRXhpdGluZzogaXNFeGl0aW5nIH0gPSBwcm9wcztcbiAgICBsZXQgW2NvbnRhaW4sIHNldENvbnRhaW5dID0gKDAsICRrN1FPcyR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGxldCBjb250ZXh0VmFsdWUgPSAoMCwgJGs3UU9zJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgY29udGFpbjogY29udGFpbixcbiAgICAgICAgICAgIHNldENvbnRhaW46IHNldENvbnRhaW5cbiAgICAgICAgfSksIFtcbiAgICAgICAgY29udGFpbixcbiAgICAgICAgc2V0Q29udGFpblxuICAgIF0pO1xuICAgIGlmICghcG9ydGFsQ29udGFpbmVyKSByZXR1cm4gbnVsbDtcbiAgICBsZXQgY29udGVudHMgPSBwcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoIXByb3BzLmRpc2FibGVGb2N1c01hbmFnZW1lbnQpIGNvbnRlbnRzID0gLyojX19QVVJFX18qLyAoMCwgJGs3UU9zJHJlYWN0KS5jcmVhdGVFbGVtZW50KCgwLCAkazdRT3MkRm9jdXNTY29wZSksIHtcbiAgICAgICAgcmVzdG9yZUZvY3VzOiB0cnVlLFxuICAgICAgICBjb250YWluOiBjb250YWluICYmICFpc0V4aXRpbmdcbiAgICB9LCBjb250ZW50cyk7XG4gICAgY29udGVudHMgPSAvKiNfX1BVUkVfXyovICgwLCAkazdRT3MkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoJDMzN2I4ODQ1MTA3MjZhMGQkZXhwb3J0JGEyMjAwYjk2YWZkMTYyNzEuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGNvbnRleHRWYWx1ZVxuICAgIH0sIC8qI19fUFVSRV9fKi8gKDAsICRrN1FPcyRyZWFjdCkuY3JlYXRlRWxlbWVudCgoMCwgJGs3UU9zJENsZWFyUHJlc3NSZXNwb25kZXIpLCBudWxsLCBjb250ZW50cykpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkazdRT3MkcmVhY3Rkb20pLmNyZWF0ZVBvcnRhbChjb250ZW50cywgcG9ydGFsQ29udGFpbmVyKTtcbn1cbmZ1bmN0aW9uICQzMzdiODg0NTEwNzI2YTBkJGV4cG9ydCQxNGM5OGE3NTk0Mzc1NDkwKCkge1xuICAgIGxldCBjdHggPSAoMCwgJGs3UU9zJHVzZUNvbnRleHQpKCQzMzdiODg0NTEwNzI2YTBkJGV4cG9ydCRhMjIwMGI5NmFmZDE2MjcxKTtcbiAgICBsZXQgc2V0Q29udGFpbiA9IGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5zZXRDb250YWluO1xuICAgICgwLCAkazdRT3MkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICBzZXRDb250YWluID09PSBudWxsIHx8IHNldENvbnRhaW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldENvbnRhaW4odHJ1ZSk7XG4gICAgfSwgW1xuICAgICAgICBzZXRDb250YWluXG4gICAgXSk7XG59XG5cblxuXG5mdW5jdGlvbiAkOGFjODQyOTI1MWM0NWU0YiRleHBvcnQkZGJjMGYxNzViMjVmYjBmYihwcm9wcywgc3RhdGUsIHJlZikge1xuICAgIGxldCB7IG92ZXJsYXlQcm9wczogb3ZlcmxheVByb3BzLCB1bmRlcmxheVByb3BzOiB1bmRlcmxheVByb3BzIH0gPSAoMCwgJGExMTUwMWYzZDFkMzllNmMkZXhwb3J0JGVhOGY3MTA4M2U5MDYwMGYpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIGlzT3Blbjogc3RhdGUuaXNPcGVuLFxuICAgICAgICBvbkNsb3NlOiBzdGF0ZS5jbG9zZVxuICAgIH0sIHJlZik7XG4gICAgKDAsICQ0OWM1MWMyNTM2MWQ0Y2QyJGV4cG9ydCRlZTBmN2NjNmFmY2QxYzE4KSh7XG4gICAgICAgIGlzRGlzYWJsZWQ6ICFzdGF0ZS5pc09wZW5cbiAgICB9KTtcbiAgICAoMCwgJDMzN2I4ODQ1MTA3MjZhMGQkZXhwb3J0JDE0Yzk4YTc1OTQzNzU0OTApKCk7XG4gICAgKDAsICRrN1FPcyR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChzdGF0ZS5pc09wZW4pIHJldHVybiAoMCwgJDVlMzgwMjY0NWNjMTkzMTkkZXhwb3J0JDFjM2ViY2FkYTE4NDI3YmYpKFtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50XG4gICAgICAgIF0pO1xuICAgIH0sIFtcbiAgICAgICAgc3RhdGUuaXNPcGVuLFxuICAgICAgICByZWZcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtb2RhbFByb3BzOiAoMCwgJGs3UU9zJG1lcmdlUHJvcHMpKG92ZXJsYXlQcm9wcyksXG4gICAgICAgIHVuZGVybGF5UHJvcHM6IHVuZGVybGF5UHJvcHNcbiAgICB9O1xufVxuXG5cblxuXG5cbmV4cG9ydCB7JDJhNDFlNDVkZjE1OTNlNjQkZXhwb3J0JGQzOWUxODEzYjNiZGQwZTEgYXMgdXNlT3ZlcmxheVBvc2l0aW9uLCAkYTExNTAxZjNkMWQzOWU2YyRleHBvcnQkZWE4ZjcxMDgzZTkwNjAwZiBhcyB1c2VPdmVybGF5LCAkNjI4MDM3ODg2YmEzMTIzNiRleHBvcnQkZjlkNWM4YmVlZTdkMDA4ZCBhcyB1c2VPdmVybGF5VHJpZ2dlciwgJDQ5YzUxYzI1MzYxZDRjZDIkZXhwb3J0JGVlMGY3Y2M2YWZjZDFjMTggYXMgdXNlUHJldmVudFNjcm9sbCwgJGY1N2FlZDRhODgxYTM0ODUkZXhwb3J0JDE3ODQwNWFmY2Q4YzVlYiBhcyBNb2RhbFByb3ZpZGVyLCAkZjU3YWVkNGE4ODFhMzQ4NSRleHBvcnQkZDlhYWVkNGMzZWNlMWJjMCBhcyB1c2VNb2RhbFByb3ZpZGVyLCAkZjU3YWVkNGE4ODFhMzQ4NSRleHBvcnQkYmY2ODgyMjFmNTkwMjRlNSBhcyBPdmVybGF5UHJvdmlkZXIsICRmNTdhZWQ0YTg4MWEzNDg1JGV4cG9ydCRiNDdjMzU5NGVhYjU4Mzg2IGFzIE92ZXJsYXlDb250YWluZXIsICRmNTdhZWQ0YTg4MWEzNDg1JGV4cG9ydCQzM2ZmZDc0ZWJmMDdmMDYwIGFzIHVzZU1vZGFsLCAkODZlYTRjYjUyMWViMmUzNyRleHBvcnQkMjMxN2QxNDllZDZmNzhjNCBhcyBEaXNtaXNzQnV0dG9uLCAkNWUzODAyNjQ1Y2MxOTMxOSRleHBvcnQkMWMzZWJjYWRhMTg0MjdiZiBhcyBhcmlhSGlkZU91dHNpZGUsICRmMmY4YTYwNzc0MTg1NDFlJGV4cG9ydCQ1NDJhNmZkMTNhYzkzMzU0IGFzIHVzZVBvcG92ZXIsICQ4YWM4NDI5MjUxYzQ1ZTRiJGV4cG9ydCRkYmMwZjE3NWIyNWZiMGZiIGFzIHVzZU1vZGFsT3ZlcmxheSwgJDMzN2I4ODQ1MTA3MjZhMGQkZXhwb3J0JGM2ZmRiODM3YjA3MGI0ZmYgYXMgT3ZlcmxheSwgJDMzN2I4ODQ1MTA3MjZhMGQkZXhwb3J0JDE0Yzk4YTc1OTQzNzU0OTAgYXMgdXNlT3ZlcmxheUZvY3VzQ29udGFpbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@react-aria/overlays/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@react-aria/ssr/dist/import.mjs":
/*!**********************************************************!*\
  !*** ../../node_modules/@react-aria/ssr/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SSRProvider: () => (/* binding */ $b5e257d569688ac6$export$9f8ac96af4b1b2ae),\n/* harmony export */   useIsSSR: () => (/* binding */ $b5e257d569688ac6$export$535bd6ca7f90a273),\n/* harmony export */   useSSRSafeId: () => (/* binding */ $b5e257d569688ac6$export$619500959fc48b26)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is\n// guarded by a check that it only runs on the client side.\n// eslint-disable-next-line rulesdir/useLayoutEffectRule\n\n// Default context value to use in case there is no SSRProvider. This is fine for\n// client-only apps. In order to support multiple copies of React Aria potentially\n// being on the page at once, the prefix is set to a random number. SSRProvider\n// will reset this to zero for consistency between server and client, so in the\n// SSR case multiple copies of React Aria is not supported.\nconst $b5e257d569688ac6$var$defaultContext = {\n    prefix: String(Math.round(Math.random() * 10000000000)),\n    current: 0\n};\nconst $b5e257d569688ac6$var$SSRContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext($b5e257d569688ac6$var$defaultContext);\nconst $b5e257d569688ac6$var$IsSSRContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext(false);\n// This is only used in React < 18.\nfunction $b5e257d569688ac6$var$LegacySSRProvider(props) {\n    let cur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    let counter = $b5e257d569688ac6$var$useCounter(cur === $b5e257d569688ac6$var$defaultContext);\n    let [isSSR, setIsSSR] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    let value = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            // If this is the first SSRProvider, start with an empty string prefix, otherwise\n            // append and increment the counter.\n            prefix: cur === $b5e257d569688ac6$var$defaultContext ? \"\" : `${cur.prefix}-${counter}`,\n            current: 0\n        }), [\n        cur,\n        counter\n    ]);\n    // If on the client, and the component was initially server rendered,\n    // then schedule a layout effect to update the component after hydration.\n    if (typeof document !== \"undefined\") // This if statement technically breaks the rules of hooks, but is safe\n    // because the condition never changes after mounting.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        setIsSSR(false);\n    }, []);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$SSRContext.Provider, {\n        value: value\n    }, /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$IsSSRContext.Provider, {\n        value: isSSR\n    }, props.children));\n}\nlet $b5e257d569688ac6$var$warnedAboutSSRProvider = false;\nfunction $b5e257d569688ac6$export$9f8ac96af4b1b2ae(props) {\n    if (typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useId\"] === \"function\") {\n        if ( true && !$b5e257d569688ac6$var$warnedAboutSSRProvider) {\n            console.warn(\"In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.\");\n            $b5e257d569688ac6$var$warnedAboutSSRProvider = true;\n        }\n        return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, react__WEBPACK_IMPORTED_MODULE_0__).Fragment, null, props.children);\n    }\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$LegacySSRProvider, props);\n}\nlet $b5e257d569688ac6$var$canUseDOM = Boolean(typeof window !== \"undefined\" && window.document && window.document.createElement);\nlet $b5e257d569688ac6$var$componentIds = new WeakMap();\nfunction $b5e257d569688ac6$var$useCounter(isDisabled = false) {\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    let ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // eslint-disable-next-line rulesdir/pure-render\n    if (ref.current === null && !isDisabled) {\n        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.\n        // This means our id counter will be incremented twice instead of once. This is a problem because on the\n        // server, components are only rendered once and so ids generated on the server won't match the client.\n        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this\n        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.\n        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.\n        // To ensure that we only increment the global counter once, we store the starting id for this component in\n        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.\n        // Since React runs the second render immediately after the first, this is safe.\n        // @ts-ignore\n        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, react__WEBPACK_IMPORTED_MODULE_0__).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;\n        if (currentOwner) {\n            let prevComponentValue = $b5e257d569688ac6$var$componentIds.get(currentOwner);\n            if (prevComponentValue == null) // On the first render, and first call to useId, store the id and state in our weak map.\n            $b5e257d569688ac6$var$componentIds.set(currentOwner, {\n                id: ctx.current,\n                state: currentOwner.memoizedState\n            });\n            else if (currentOwner.memoizedState !== prevComponentValue.state) {\n                // On the second render, the memoizedState gets reset by React.\n                // Reset the counter, and remove from the weak map so we don't\n                // do this for subsequent useId calls.\n                ctx.current = prevComponentValue.id;\n                $b5e257d569688ac6$var$componentIds.delete(currentOwner);\n            }\n        }\n        // eslint-disable-next-line rulesdir/pure-render\n        ref.current = ++ctx.current;\n    }\n    // eslint-disable-next-line rulesdir/pure-render\n    return ref.current;\n}\nfunction $b5e257d569688ac6$var$useLegacySSRSafeId(defaultId) {\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    // If we are rendering in a non-DOM environment, and there's no SSRProvider,\n    // provide a warning to hint to the developer to add one.\n    if (ctx === $b5e257d569688ac6$var$defaultContext && !$b5e257d569688ac6$var$canUseDOM) console.warn(\"When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.\");\n    let counter = $b5e257d569688ac6$var$useCounter(!!defaultId);\n    let prefix = ctx === $b5e257d569688ac6$var$defaultContext && \"development\" === \"test\" ? 0 : `react-aria${ctx.prefix}`;\n    return defaultId || `${prefix}-${counter}`;\n}\nfunction $b5e257d569688ac6$var$useModernSSRSafeId(defaultId) {\n    // @ts-ignore\n    let id = (0, react__WEBPACK_IMPORTED_MODULE_0__).useId();\n    let [didSSR] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($b5e257d569688ac6$export$535bd6ca7f90a273());\n    let prefix = didSSR || \"development\" === \"test\" ? \"react-aria\" : `react-aria${$b5e257d569688ac6$var$defaultContext.prefix}`;\n    return defaultId || `${prefix}-${id}`;\n}\nconst $b5e257d569688ac6$export$619500959fc48b26 = typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useId\"] === \"function\" ? $b5e257d569688ac6$var$useModernSSRSafeId : $b5e257d569688ac6$var$useLegacySSRSafeId;\nfunction $b5e257d569688ac6$var$getSnapshot() {\n    return false;\n}\nfunction $b5e257d569688ac6$var$getServerSnapshot() {\n    return true;\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction $b5e257d569688ac6$var$subscribe(onStoreChange) {\n    // noop\n    return ()=>{};\n}\nfunction $b5e257d569688ac6$export$535bd6ca7f90a273() {\n    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.\n    if (typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useSyncExternalStore\"] === \"function\") return (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useSyncExternalStore\"]($b5e257d569688ac6$var$subscribe, $b5e257d569688ac6$var$getSnapshot, $b5e257d569688ac6$var$getServerSnapshot);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$IsSSRContext);\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL3Nzci9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnTTs7QUFFaE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsa0NBQVk7QUFDdkUsNkRBQTZELGtDQUFZO0FBQ3pFO0FBQ0E7QUFDQSxrQkFBa0IsNkNBQWlCO0FBQ25DO0FBQ0EsZ0NBQWdDLDJDQUFlO0FBQy9DLG9CQUFvQiwwQ0FBYztBQUNsQztBQUNBO0FBQ0EsMkVBQTJFLFdBQVcsR0FBRyxRQUFRO0FBQ2pHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFzQjtBQUM5QjtBQUNBLEtBQUs7QUFDTCw2QkFBNkIsa0NBQVk7QUFDekM7QUFDQSxLQUFLLG9CQUFvQixrQ0FBWTtBQUNyQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0NBQVk7QUFDL0IsWUFBWSxLQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0NBQVksb0JBQW9CLGtDQUFZO0FBQzdFO0FBQ0EsNkJBQTZCLGtDQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZDQUFpQjtBQUNuQyxrQkFBa0IseUNBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsa0NBQVk7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2Q0FBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsYUFBb0IsY0FBYyxDQUFZLGdCQUFnQixXQUFXO0FBQzFJLDJCQUEyQixPQUFPLEdBQUcsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0NBQVk7QUFDN0IsdUJBQXVCLDJDQUFlO0FBQ3RDLDJCQUEyQixhQUFvQiwwQ0FBMEMsNENBQTRDO0FBQ3JJLDJCQUEyQixPQUFPLEdBQUcsR0FBRztBQUN4QztBQUNBLDZEQUE2RCxrQ0FBWTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQ0FBWSxxREFBcUQsa0NBQVk7QUFDaEc7QUFDQSxlQUFlLDZDQUFpQjtBQUNoQzs7Ozs7QUFLb0w7QUFDcEwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvc3NyL2Rpc3QvaW1wb3J0Lm1qcz8zNzc2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAkNzNTSngkcmVhY3QsIHt1c2VDb250ZXh0IGFzICQ3M1NKeCR1c2VDb250ZXh0LCB1c2VTdGF0ZSBhcyAkNzNTSngkdXNlU3RhdGUsIHVzZU1lbW8gYXMgJDczU0p4JHVzZU1lbW8sIHVzZUxheW91dEVmZmVjdCBhcyAkNzNTSngkdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgYXMgJDczU0p4JHVzZVJlZn0gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gV2UgbXVzdCBhdm9pZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2l0aCBAcmVhY3QtYXJpYS91dGlscywgYW5kIHRoaXMgdXNlTGF5b3V0RWZmZWN0IGlzXG4vLyBndWFyZGVkIGJ5IGEgY2hlY2sgdGhhdCBpdCBvbmx5IHJ1bnMgb24gdGhlIGNsaWVudCBzaWRlLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJ1bGVzZGlyL3VzZUxheW91dEVmZmVjdFJ1bGVcblxuLy8gRGVmYXVsdCBjb250ZXh0IHZhbHVlIHRvIHVzZSBpbiBjYXNlIHRoZXJlIGlzIG5vIFNTUlByb3ZpZGVyLiBUaGlzIGlzIGZpbmUgZm9yXG4vLyBjbGllbnQtb25seSBhcHBzLiBJbiBvcmRlciB0byBzdXBwb3J0IG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBBcmlhIHBvdGVudGlhbGx5XG4vLyBiZWluZyBvbiB0aGUgcGFnZSBhdCBvbmNlLCB0aGUgcHJlZml4IGlzIHNldCB0byBhIHJhbmRvbSBudW1iZXIuIFNTUlByb3ZpZGVyXG4vLyB3aWxsIHJlc2V0IHRoaXMgdG8gemVybyBmb3IgY29uc2lzdGVuY3kgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCwgc28gaW4gdGhlXG4vLyBTU1IgY2FzZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgQXJpYSBpcyBub3Qgc3VwcG9ydGVkLlxuY29uc3QgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGRlZmF1bHRDb250ZXh0ID0ge1xuICAgIHByZWZpeDogU3RyaW5nKE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKSksXG4gICAgY3VycmVudDogMFxufTtcbmNvbnN0ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRTU1JDb250ZXh0ID0gLyojX19QVVJFX18qLyAoMCwgJDczU0p4JHJlYWN0KS5jcmVhdGVDb250ZXh0KCRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCk7XG5jb25zdCAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkSXNTU1JDb250ZXh0ID0gLyojX19QVVJFX18qLyAoMCwgJDczU0p4JHJlYWN0KS5jcmVhdGVDb250ZXh0KGZhbHNlKTtcbi8vIFRoaXMgaXMgb25seSB1c2VkIGluIFJlYWN0IDwgMTguXG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkTGVnYWN5U1NSUHJvdmlkZXIocHJvcHMpIHtcbiAgICBsZXQgY3VyID0gKDAsICQ3M1NKeCR1c2VDb250ZXh0KSgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dCk7XG4gICAgbGV0IGNvdW50ZXIgPSAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlQ291bnRlcihjdXIgPT09ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCk7XG4gICAgbGV0IFtpc1NTUiwgc2V0SXNTU1JdID0gKDAsICQ3M1NKeCR1c2VTdGF0ZSkodHJ1ZSk7XG4gICAgbGV0IHZhbHVlID0gKDAsICQ3M1NKeCR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IFNTUlByb3ZpZGVyLCBzdGFydCB3aXRoIGFuIGVtcHR5IHN0cmluZyBwcmVmaXgsIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gYXBwZW5kIGFuZCBpbmNyZW1lbnQgdGhlIGNvdW50ZXIuXG4gICAgICAgICAgICBwcmVmaXg6IGN1ciA9PT0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGRlZmF1bHRDb250ZXh0ID8gXCJcIiA6IGAke2N1ci5wcmVmaXh9LSR7Y291bnRlcn1gLFxuICAgICAgICAgICAgY3VycmVudDogMFxuICAgICAgICB9KSwgW1xuICAgICAgICBjdXIsXG4gICAgICAgIGNvdW50ZXJcbiAgICBdKTtcbiAgICAvLyBJZiBvbiB0aGUgY2xpZW50LCBhbmQgdGhlIGNvbXBvbmVudCB3YXMgaW5pdGlhbGx5IHNlcnZlciByZW5kZXJlZCxcbiAgICAvLyB0aGVuIHNjaGVkdWxlIGEgbGF5b3V0IGVmZmVjdCB0byB1cGRhdGUgdGhlIGNvbXBvbmVudCBhZnRlciBoeWRyYXRpb24uXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikgLy8gVGhpcyBpZiBzdGF0ZW1lbnQgdGVjaG5pY2FsbHkgYnJlYWtzIHRoZSBydWxlcyBvZiBob29rcywgYnV0IGlzIHNhZmVcbiAgICAvLyBiZWNhdXNlIHRoZSBjb25kaXRpb24gbmV2ZXIgY2hhbmdlcyBhZnRlciBtb3VudGluZy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAoMCwgJDczU0p4JHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgc2V0SXNTU1IoZmFsc2UpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJDczU0p4JHJlYWN0KS5jcmVhdGVFbGVtZW50KCRiNWUyNTdkNTY5Njg4YWM2JHZhciRTU1JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0sIC8qI19fUFVSRV9fKi8gKDAsICQ3M1NKeCRyZWFjdCkuY3JlYXRlRWxlbWVudCgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkSXNTU1JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBpc1NTUlxuICAgIH0sIHByb3BzLmNoaWxkcmVuKSk7XG59XG5sZXQgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHdhcm5lZEFib3V0U1NSUHJvdmlkZXIgPSBmYWxzZTtcbmZ1bmN0aW9uICRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ5ZjhhYzk2YWY0YjFiMmFlKHByb3BzKSB7XG4gICAgaWYgKHR5cGVvZiAoMCwgJDczU0p4JHJlYWN0KVtcInVzZUlkXCJdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInRlc3RcIiAmJiAhJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHdhcm5lZEFib3V0U1NSUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkluIFJlYWN0IDE4LCBTU1JQcm92aWRlciBpcyBub3QgbmVjZXNzYXJ5IGFuZCBpcyBhIG5vb3AuIFlvdSBjYW4gcmVtb3ZlIGl0IGZyb20geW91ciBhcHAuXCIpO1xuICAgICAgICAgICAgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHdhcm5lZEFib3V0U1NSUHJvdmlkZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkNzNTSngkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoKDAsICQ3M1NKeCRyZWFjdCkuRnJhZ21lbnQsIG51bGwsIHByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICQ3M1NKeCRyZWFjdCkuY3JlYXRlRWxlbWVudCgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkTGVnYWN5U1NSUHJvdmlkZXIsIHByb3BzKTtcbn1cbmxldCAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkY2FuVXNlRE9NID0gQm9vbGVhbih0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5sZXQgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNvbXBvbmVudElkcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlQ291bnRlcihpc0Rpc2FibGVkID0gZmFsc2UpIHtcbiAgICBsZXQgY3R4ID0gKDAsICQ3M1NKeCR1c2VDb250ZXh0KSgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dCk7XG4gICAgbGV0IHJlZiA9ICgwLCAkNzNTSngkdXNlUmVmKShudWxsKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcnVsZXNkaXIvcHVyZS1yZW5kZXJcbiAgICBpZiAocmVmLmN1cnJlbnQgPT09IG51bGwgJiYgIWlzRGlzYWJsZWQpIHtcbiAgICAgICAgdmFyIF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRF9SZWFjdEN1cnJlbnRPd25lciwgX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICAgICAgICAvLyBJbiBzdHJpY3QgbW9kZSwgUmVhY3QgcmVuZGVycyBjb21wb25lbnRzIHR3aWNlLCBhbmQgdGhlIHJlZiB3aWxsIGJlIHJlc2V0IHRvIG51bGwgb24gdGhlIHNlY29uZCByZW5kZXIuXG4gICAgICAgIC8vIFRoaXMgbWVhbnMgb3VyIGlkIGNvdW50ZXIgd2lsbCBiZSBpbmNyZW1lbnRlZCB0d2ljZSBpbnN0ZWFkIG9mIG9uY2UuIFRoaXMgaXMgYSBwcm9ibGVtIGJlY2F1c2Ugb24gdGhlXG4gICAgICAgIC8vIHNlcnZlciwgY29tcG9uZW50cyBhcmUgb25seSByZW5kZXJlZCBvbmNlIGFuZCBzbyBpZHMgZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIgd29uJ3QgbWF0Y2ggdGhlIGNsaWVudC5cbiAgICAgICAgLy8gSW4gUmVhY3QgMTgsIHVzZUlkIHdhcyBpbnRyb2R1Y2VkIHRvIHNvbHZlIHRoaXMsIGJ1dCBpdCBpcyBub3QgYXZhaWxhYmxlIGluIG9sZGVyIHZlcnNpb25zLiBTbyB0byBzb2x2ZSB0aGlzXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gdXNlIHNvbWUgUmVhY3QgaW50ZXJuYWxzIHRvIGFjY2VzcyB0aGUgdW5kZXJseWluZyBGaWJlciBpbnN0YW5jZSwgd2hpY2ggaXMgc3RhYmxlIGJldHdlZW4gcmVuZGVycy5cbiAgICAgICAgLy8gVGhpcyBpcyBleHBvc2VkIGFzIFJlYWN0Q3VycmVudE93bmVyIGluIGRldmVsb3BtZW50LCB3aGljaCBpcyBhbGwgd2UgbmVlZCBzaW5jZSBTdHJpY3RNb2RlIG9ubHkgcnVucyBpbiBkZXZlbG9wbWVudC5cbiAgICAgICAgLy8gVG8gZW5zdXJlIHRoYXQgd2Ugb25seSBpbmNyZW1lbnQgdGhlIGdsb2JhbCBjb3VudGVyIG9uY2UsIHdlIHN0b3JlIHRoZSBzdGFydGluZyBpZCBmb3IgdGhpcyBjb21wb25lbnQgaW5cbiAgICAgICAgLy8gYSB3ZWFrIG1hcCBhc3NvY2lhdGVkIHdpdGggdGhlIEZpYmVyLiBPbiB0aGUgc2Vjb25kIHJlbmRlciwgd2UgcmVzZXQgdGhlIGdsb2JhbCBjb3VudGVyIHRvIHRoaXMgdmFsdWUuXG4gICAgICAgIC8vIFNpbmNlIFJlYWN0IHJ1bnMgdGhlIHNlY29uZCByZW5kZXIgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGZpcnN0LCB0aGlzIGlzIHNhZmUuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IGN1cnJlbnRPd25lciA9IChfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSAoMCwgJDczU0p4JHJlYWN0KS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCkgPT09IG51bGwgfHwgX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEX1JlYWN0Q3VycmVudE93bmVyID0gX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyKSA9PT0gbnVsbCB8fCBfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURfUmVhY3RDdXJyZW50T3duZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRF9SZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgICBpZiAoY3VycmVudE93bmVyKSB7XG4gICAgICAgICAgICBsZXQgcHJldkNvbXBvbmVudFZhbHVlID0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNvbXBvbmVudElkcy5nZXQoY3VycmVudE93bmVyKTtcbiAgICAgICAgICAgIGlmIChwcmV2Q29tcG9uZW50VmFsdWUgPT0gbnVsbCkgLy8gT24gdGhlIGZpcnN0IHJlbmRlciwgYW5kIGZpcnN0IGNhbGwgdG8gdXNlSWQsIHN0b3JlIHRoZSBpZCBhbmQgc3RhdGUgaW4gb3VyIHdlYWsgbWFwLlxuICAgICAgICAgICAgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNvbXBvbmVudElkcy5zZXQoY3VycmVudE93bmVyLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGN0eC5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHN0YXRlOiBjdXJyZW50T3duZXIubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50T3duZXIubWVtb2l6ZWRTdGF0ZSAhPT0gcHJldkNvbXBvbmVudFZhbHVlLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gT24gdGhlIHNlY29uZCByZW5kZXIsIHRoZSBtZW1vaXplZFN0YXRlIGdldHMgcmVzZXQgYnkgUmVhY3QuXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNvdW50ZXIsIGFuZCByZW1vdmUgZnJvbSB0aGUgd2VhayBtYXAgc28gd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAvLyBkbyB0aGlzIGZvciBzdWJzZXF1ZW50IHVzZUlkIGNhbGxzLlxuICAgICAgICAgICAgICAgIGN0eC5jdXJyZW50ID0gcHJldkNvbXBvbmVudFZhbHVlLmlkO1xuICAgICAgICAgICAgICAgICRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMuZGVsZXRlKGN1cnJlbnRPd25lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJ1bGVzZGlyL3B1cmUtcmVuZGVyXG4gICAgICAgIHJlZi5jdXJyZW50ID0gKytjdHguY3VycmVudDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJ1bGVzZGlyL3B1cmUtcmVuZGVyXG4gICAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUxlZ2FjeVNTUlNhZmVJZChkZWZhdWx0SWQpIHtcbiAgICBsZXQgY3R4ID0gKDAsICQ3M1NKeCR1c2VDb250ZXh0KSgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dCk7XG4gICAgLy8gSWYgd2UgYXJlIHJlbmRlcmluZyBpbiBhIG5vbi1ET00gZW52aXJvbm1lbnQsIGFuZCB0aGVyZSdzIG5vIFNTUlByb3ZpZGVyLFxuICAgIC8vIHByb3ZpZGUgYSB3YXJuaW5nIHRvIGhpbnQgdG8gdGhlIGRldmVsb3BlciB0byBhZGQgb25lLlxuICAgIGlmIChjdHggPT09ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCAmJiAhJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNhblVzZURPTSkgY29uc29sZS53YXJuKFwiV2hlbiBzZXJ2ZXIgcmVuZGVyaW5nLCB5b3UgbXVzdCB3cmFwIHlvdXIgYXBwbGljYXRpb24gaW4gYW4gPFNTUlByb3ZpZGVyPiB0byBlbnN1cmUgY29uc2lzdGVudCBpZHMgYXJlIGdlbmVyYXRlZCBiZXR3ZWVuIHRoZSBjbGllbnQgYW5kIHNlcnZlci5cIik7XG4gICAgbGV0IGNvdW50ZXIgPSAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlQ291bnRlcighIWRlZmF1bHRJZCk7XG4gICAgbGV0IHByZWZpeCA9IGN0eCA9PT0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGRlZmF1bHRDb250ZXh0ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IFwicmVhY3QtYXJpYVwiIDogYHJlYWN0LWFyaWEke2N0eC5wcmVmaXh9YDtcbiAgICByZXR1cm4gZGVmYXVsdElkIHx8IGAke3ByZWZpeH0tJHtjb3VudGVyfWA7XG59XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlTW9kZXJuU1NSU2FmZUlkKGRlZmF1bHRJZCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBsZXQgaWQgPSAoMCwgJDczU0p4JHJlYWN0KS51c2VJZCgpO1xuICAgIGxldCBbZGlkU1NSXSA9ICgwLCAkNzNTSngkdXNlU3RhdGUpKCRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ1MzViZDZjYTdmOTBhMjczKCkpO1xuICAgIGxldCBwcmVmaXggPSBkaWRTU1IgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gXCJyZWFjdC1hcmlhXCIgOiBgcmVhY3QtYXJpYSR7JGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGRlZmF1bHRDb250ZXh0LnByZWZpeH1gO1xuICAgIHJldHVybiBkZWZhdWx0SWQgfHwgYCR7cHJlZml4fS0ke2lkfWA7XG59XG5jb25zdCAkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNjE5NTAwOTU5ZmM0OGIyNiA9IHR5cGVvZiAoMCwgJDczU0p4JHJlYWN0KVtcInVzZUlkXCJdID09PSBcImZ1bmN0aW9uXCIgPyAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlTW9kZXJuU1NSU2FmZUlkIDogJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUxlZ2FjeVNTUlNhZmVJZDtcbmZ1bmN0aW9uICRiNWUyNTdkNTY5Njg4YWM2JHZhciRnZXRTbmFwc2hvdCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZ2V0U2VydmVyU25hcHNob3QoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkc3Vic2NyaWJlKG9uU3RvcmVDaGFuZ2UpIHtcbiAgICAvLyBub29wXG4gICAgcmV0dXJuICgpPT57fTtcbn1cbmZ1bmN0aW9uICRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ1MzViZDZjYTdmOTBhMjczKCkge1xuICAgIC8vIEluIFJlYWN0IDE4LCB3ZSBjYW4gdXNlIHVzZVN5bmNFeHRlcm5hbFN0b3JlIHRvIGRldGVjdCBpZiB3ZSdyZSBzZXJ2ZXIgcmVuZGVyaW5nIG9yIGh5ZHJhdGluZy5cbiAgICBpZiAodHlwZW9mICgwLCAkNzNTSngkcmVhY3QpW1widXNlU3luY0V4dGVybmFsU3RvcmVcIl0gPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuICgwLCAkNzNTSngkcmVhY3QpW1widXNlU3luY0V4dGVybmFsU3RvcmVcIl0oJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHN1YnNjcmliZSwgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGdldFNuYXBzaG90LCAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHJldHVybiAoMCwgJDczU0p4JHVzZUNvbnRleHQpKCRiNWUyNTdkNTY5Njg4YWM2JHZhciRJc1NTUkNvbnRleHQpO1xufVxuXG5cblxuXG5leHBvcnQgeyRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ5ZjhhYzk2YWY0YjFiMmFlIGFzIFNTUlByb3ZpZGVyLCAkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNjE5NTAwOTU5ZmM0OGIyNiBhcyB1c2VTU1JTYWZlSWQsICRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ1MzViZDZjYTdmOTBhMjczIGFzIHVzZUlzU1NSfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@react-aria/ssr/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@react-aria/utils/dist/import.mjs":
/*!************************************************************!*\
  !*** ../../node_modules/@react-aria/utils/dist/import.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RouterProvider: () => (/* binding */ $ea8dcbcb9ea1b556$export$323e4fc2fa4753fb),\n/* harmony export */   chain: () => (/* binding */ $ff5963eb1fccf552$export$e08e3b67e392101e),\n/* harmony export */   clamp: () => (/* reexport safe */ _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.clamp),\n/* harmony export */   filterDOMProps: () => (/* binding */ $65484d02dcb7eb3e$export$457c3d6518dd4c6f),\n/* harmony export */   focusWithoutScrolling: () => (/* binding */ $7215afc6de606d6b$export$de79e2c695e052f3),\n/* harmony export */   getOffset: () => (/* binding */ $ab71dadb03a6fb2e$export$622cea445a1c5b7d),\n/* harmony export */   getOwnerDocument: () => (/* binding */ $431fbd86ca7dc216$export$b204af158042fbac),\n/* harmony export */   getOwnerWindow: () => (/* binding */ $431fbd86ca7dc216$export$f21a1ffae260145a),\n/* harmony export */   getScrollParent: () => (/* binding */ $62d8ded9296f3872$export$cfa2225e87938781),\n/* harmony export */   getSyntheticLinkProps: () => (/* binding */ $ea8dcbcb9ea1b556$export$51437d503373d223),\n/* harmony export */   isAndroid: () => (/* binding */ $c87311424ea30a05$export$a11b0059900ceec8),\n/* harmony export */   isAppleDevice: () => (/* binding */ $c87311424ea30a05$export$e1865c3bedcd822b),\n/* harmony export */   isChrome: () => (/* binding */ $c87311424ea30a05$export$6446a186d09e379e),\n/* harmony export */   isIOS: () => (/* binding */ $c87311424ea30a05$export$fedb369cb70207f1),\n/* harmony export */   isIPad: () => (/* binding */ $c87311424ea30a05$export$7bef049ce92e4224),\n/* harmony export */   isIPhone: () => (/* binding */ $c87311424ea30a05$export$186c6964ca17d99),\n/* harmony export */   isMac: () => (/* binding */ $c87311424ea30a05$export$9ac100e40613ea10),\n/* harmony export */   isScrollable: () => (/* binding */ $62d8ded9296f3872$export$2bb74740c4e19def),\n/* harmony export */   isVirtualClick: () => (/* binding */ $6a7db85432448f7f$export$60278871457622de),\n/* harmony export */   isVirtualPointerEvent: () => (/* binding */ $6a7db85432448f7f$export$29bf1b5f2c56cf63),\n/* harmony export */   isWebKit: () => (/* binding */ $c87311424ea30a05$export$78551043582a6a98),\n/* harmony export */   mergeIds: () => (/* binding */ $bdb11010cef70236$export$cd8c9cb68f842629),\n/* harmony export */   mergeProps: () => (/* binding */ $3ef42575df84b30b$export$9d1611c77c2fe928),\n/* harmony export */   mergeRefs: () => (/* binding */ $5dc95899b306f630$export$c9058316764c140e),\n/* harmony export */   openLink: () => (/* binding */ $ea8dcbcb9ea1b556$export$95185d699e05d4d7),\n/* harmony export */   runAfterTransition: () => (/* binding */ $bbed8b41f857bcc0$export$24490316f764c430),\n/* harmony export */   scrollIntoView: () => (/* binding */ $2f04cbc44ee30ce0$export$53a0910f038337bd),\n/* harmony export */   scrollIntoViewport: () => (/* binding */ $2f04cbc44ee30ce0$export$c826860796309d1b),\n/* harmony export */   shouldClientNavigate: () => (/* binding */ $ea8dcbcb9ea1b556$export$efa8c9099e530235),\n/* harmony export */   snapValueToStep: () => (/* reexport safe */ _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.snapValueToStep),\n/* harmony export */   useDeepMemo: () => (/* binding */ $5a387cc49350e6db$export$722debc0e56fea39),\n/* harmony export */   useDescription: () => (/* binding */ $ef06256079686ba0$export$f8aeda7b10753fa1),\n/* harmony export */   useDrag1D: () => (/* binding */ $9cc09df9fd7676be$export$7bbed75feba39706),\n/* harmony export */   useEffectEvent: () => (/* binding */ $8ae05eaa5c114e9c$export$7f54fc3180508a52),\n/* harmony export */   useEvent: () => (/* binding */ $e9faafb641e167db$export$90fc3a17d93f704c),\n/* harmony export */   useFormReset: () => (/* binding */ $99facab73266f662$export$5add1d006293d136),\n/* harmony export */   useGlobalListeners: () => (/* binding */ $03deb23ff14920c4$export$4eaf04e54aa8eed6),\n/* harmony export */   useId: () => (/* binding */ $bdb11010cef70236$export$f680877a34711e37),\n/* harmony export */   useLabels: () => (/* binding */ $313b98861ee5dd6c$export$d6875122194c7b44),\n/* harmony export */   useLayoutEffect: () => (/* binding */ $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c),\n/* harmony export */   useObjectRef: () => (/* binding */ $df56164dff5785e2$export$4338b53315abf666),\n/* harmony export */   useResizeObserver: () => (/* binding */ $9daab02d461809db$export$683480f191c0e3ea),\n/* harmony export */   useRouter: () => (/* binding */ $ea8dcbcb9ea1b556$export$9a302a45f65d0572),\n/* harmony export */   useSlotId: () => (/* binding */ $bdb11010cef70236$export$b4cc09c592e8fdb8),\n/* harmony export */   useSyncRef: () => (/* binding */ $e7801be82b4b2a53$export$4debdb1a3f0fa79e),\n/* harmony export */   useUpdateEffect: () => (/* binding */ $4f58c5f72bcf79f7$export$496315a1608d9602),\n/* harmony export */   useValueEffect: () => (/* binding */ $1dbecbe27a04f9af$export$14d238f342723f25),\n/* harmony export */   useViewportSize: () => (/* binding */ $5df64b3807dc15ee$export$d699905dd57c73ca)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/../../node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_ssr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/ssr */ \"(ssr)/../../node_modules/@react-aria/ssr/dist/import.mjs\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(ssr)/../../node_modules/@react-aria/utils/node_modules/clsx/dist/clsx.js\");\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nconst $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== \"undefined\" ? (0, react__WEBPACK_IMPORTED_MODULE_0__).useLayoutEffect : ()=>{};\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nfunction $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn) {\n    const ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        ref.current = fn;\n    }, [\n        fn\n    ]);\n    // @ts-ignore\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        const f = ref.current;\n        return f(...args);\n    }, []);\n}\n\n\nfunction $1dbecbe27a04f9af$export$14d238f342723f25(defaultValue) {\n    let [value, setValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultValue);\n    let effect = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Store the function in a ref so we can always access the current version\n    // which has the proper `value` in scope.\n    let nextRef = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(()=>{\n        // Run the generator to the next yield.\n        let newValue = effect.current.next();\n        // If the generator is done, reset the effect.\n        if (newValue.done) {\n            effect.current = null;\n            return;\n        }\n        // If the value is the same as the current value,\n        // then continue to the next yield. Otherwise,\n        // set the value in state and wait for the next layout effect.\n        if (value === newValue.value) nextRef();\n        else setValue(newValue.value);\n    });\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        // If there is an effect currently running, continue to the next yield.\n        if (effect.current) nextRef();\n    });\n    let queue = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((fn)=>{\n        effect.current = fn(value);\n        nextRef();\n    });\n    return [\n        value,\n        queue\n    ];\n}\n\n\n// copied from SSRProvider.tsx to reduce exports, if needed again, consider sharing\nlet $bdb11010cef70236$var$canUseDOM = Boolean(typeof window !== \"undefined\" && window.document && window.document.createElement);\nlet $bdb11010cef70236$var$idsUpdaterMap = new Map();\nfunction $bdb11010cef70236$export$f680877a34711e37(defaultId) {\n    let [value, setValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultId);\n    let nextId = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let res = (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_2__.useSSRSafeId)(value);\n    let updateValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((val)=>{\n        nextId.current = val;\n    }, []);\n    if ($bdb11010cef70236$var$canUseDOM) $bdb11010cef70236$var$idsUpdaterMap.set(res, updateValue);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        let r = res;\n        return ()=>{\n            $bdb11010cef70236$var$idsUpdaterMap.delete(r);\n        };\n    }, [\n        res\n    ]);\n    // This cannot cause an infinite loop because the ref is updated first.\n    // eslint-disable-next-line\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let newId = nextId.current;\n        if (newId) {\n            nextId.current = null;\n            setValue(newId);\n        }\n    });\n    return res;\n}\nfunction $bdb11010cef70236$export$cd8c9cb68f842629(idA, idB) {\n    if (idA === idB) return idA;\n    let setIdA = $bdb11010cef70236$var$idsUpdaterMap.get(idA);\n    if (setIdA) {\n        setIdA(idB);\n        return idB;\n    }\n    let setIdB = $bdb11010cef70236$var$idsUpdaterMap.get(idB);\n    if (setIdB) {\n        setIdB(idA);\n        return idA;\n    }\n    return idB;\n}\nfunction $bdb11010cef70236$export$b4cc09c592e8fdb8(depArray = []) {\n    let id = $bdb11010cef70236$export$f680877a34711e37();\n    let [resolvedId, setResolvedId] = (0, $1dbecbe27a04f9af$export$14d238f342723f25)(id);\n    let updateId = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setResolvedId(function*() {\n            yield id;\n            yield document.getElementById(id) ? id : undefined;\n        });\n    }, [\n        id,\n        setResolvedId\n    ]);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(updateId, [\n        id,\n        updateId,\n        ...depArray\n    ]);\n    return resolvedId;\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /**\n * Calls all functions in the order they were chained with the same arguments.\n */ function $ff5963eb1fccf552$export$e08e3b67e392101e(...callbacks) {\n    return (...args)=>{\n        for (let callback of callbacks)if (typeof callback === \"function\") callback(...args);\n    };\n}\n\n\nconst $431fbd86ca7dc216$export$b204af158042fbac = (el)=>{\n    var _el_ownerDocument;\n    return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;\n};\nconst $431fbd86ca7dc216$export$f21a1ffae260145a = (el)=>{\n    if (el && \"window\" in el && el.window === el) return el;\n    const doc = $431fbd86ca7dc216$export$b204af158042fbac(el);\n    return doc.defaultView || window;\n};\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nfunction $3ef42575df84b30b$export$9d1611c77c2fe928(...args) {\n    // Start with a base clone of the first argument. This is a lot faster than starting\n    // with an empty object and adding properties as we go.\n    let result = {\n        ...args[0]\n    };\n    for(let i = 1; i < args.length; i++){\n        let props = args[i];\n        for(let key in props){\n            let a = result[key];\n            let b = props[key];\n            // Chain events\n            if (typeof a === \"function\" && typeof b === \"function\" && // This is a lot faster than a regex.\n            key[0] === \"o\" && key[1] === \"n\" && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(a, b);\n            else if ((key === \"className\" || key === \"UNSAFE_className\") && typeof a === \"string\" && typeof b === \"string\") result[key] = (0, clsx__WEBPACK_IMPORTED_MODULE_1__)(a, b);\n            else if (key === \"id\" && a && b) result.id = (0, $bdb11010cef70236$export$cd8c9cb68f842629)(a, b);\n            else result[key] = b !== undefined ? b : a;\n        }\n    }\n    return result;\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $5dc95899b306f630$export$c9058316764c140e(...refs) {\n    if (refs.length === 1) return refs[0];\n    return (value)=>{\n        for (let ref of refs){\n            if (typeof ref === \"function\") ref(value);\n            else if (ref != null) ref.current = value;\n        }\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $65484d02dcb7eb3e$var$DOMPropNames = new Set([\n    \"id\"\n]);\nconst $65484d02dcb7eb3e$var$labelablePropNames = new Set([\n    \"aria-label\",\n    \"aria-labelledby\",\n    \"aria-describedby\",\n    \"aria-details\"\n]);\n// See LinkDOMProps in dom.d.ts.\nconst $65484d02dcb7eb3e$var$linkPropNames = new Set([\n    \"href\",\n    \"target\",\n    \"rel\",\n    \"download\",\n    \"ping\",\n    \"referrerPolicy\"\n]);\nconst $65484d02dcb7eb3e$var$propRe = /^(data-.*)$/;\nfunction $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, opts = {}) {\n    let { labelable: labelable, isLink: isLink, propNames: propNames } = opts;\n    let filteredProps = {};\n    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($65484d02dcb7eb3e$var$DOMPropNames.has(prop) || labelable && $65484d02dcb7eb3e$var$labelablePropNames.has(prop) || isLink && $65484d02dcb7eb3e$var$linkPropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $65484d02dcb7eb3e$var$propRe.test(prop))) filteredProps[prop] = props[prop];\n    return filteredProps;\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $7215afc6de606d6b$export$de79e2c695e052f3(element) {\n    if ($7215afc6de606d6b$var$supportsPreventScroll()) element.focus({\n        preventScroll: true\n    });\n    else {\n        let scrollableElements = $7215afc6de606d6b$var$getScrollableElements(element);\n        element.focus();\n        $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements);\n    }\n}\nlet $7215afc6de606d6b$var$supportsPreventScrollCached = null;\nfunction $7215afc6de606d6b$var$supportsPreventScroll() {\n    if ($7215afc6de606d6b$var$supportsPreventScrollCached == null) {\n        $7215afc6de606d6b$var$supportsPreventScrollCached = false;\n        try {\n            var focusElem = document.createElement(\"div\");\n            focusElem.focus({\n                get preventScroll () {\n                    $7215afc6de606d6b$var$supportsPreventScrollCached = true;\n                    return true;\n                }\n            });\n        } catch (e) {\n        // Ignore\n        }\n    }\n    return $7215afc6de606d6b$var$supportsPreventScrollCached;\n}\nfunction $7215afc6de606d6b$var$getScrollableElements(element) {\n    var parent = element.parentNode;\n    var scrollableElements = [];\n    var rootScrollingElement = document.scrollingElement || document.documentElement;\n    while(parent instanceof HTMLElement && parent !== rootScrollingElement){\n        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({\n            element: parent,\n            scrollTop: parent.scrollTop,\n            scrollLeft: parent.scrollLeft\n        });\n        parent = parent.parentNode;\n    }\n    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({\n        element: rootScrollingElement,\n        scrollTop: rootScrollingElement.scrollTop,\n        scrollLeft: rootScrollingElement.scrollLeft\n    });\n    return scrollableElements;\n}\nfunction $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements) {\n    for (let { element: element, scrollTop: scrollTop, scrollLeft: scrollLeft } of scrollableElements){\n        element.scrollTop = scrollTop;\n        element.scrollLeft = scrollLeft;\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $ab71dadb03a6fb2e$export$622cea445a1c5b7d(element, reverse, orientation = \"horizontal\") {\n    let rect = element.getBoundingClientRect();\n    if (reverse) return orientation === \"horizontal\" ? rect.right : rect.bottom;\n    return orientation === \"horizontal\" ? rect.left : rect.top;\n}\n\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c87311424ea30a05$var$testUserAgent(re) {\n    var _window_navigator_userAgentData;\n    if (typeof window === \"undefined\" || window.navigator == null) return false;\n    return ((_window_navigator_userAgentData = window.navigator[\"userAgentData\"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);\n}\nfunction $c87311424ea30a05$var$testPlatform(re) {\n    var _window_navigator_userAgentData;\n    return typeof window !== \"undefined\" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator[\"userAgentData\"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;\n}\nfunction $c87311424ea30a05$export$9ac100e40613ea10() {\n    return $c87311424ea30a05$var$testPlatform(/^Mac/i);\n}\nfunction $c87311424ea30a05$export$186c6964ca17d99() {\n    return $c87311424ea30a05$var$testPlatform(/^iPhone/i);\n}\nfunction $c87311424ea30a05$export$7bef049ce92e4224() {\n    return $c87311424ea30a05$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n    $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;\n}\nfunction $c87311424ea30a05$export$fedb369cb70207f1() {\n    return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();\n}\nfunction $c87311424ea30a05$export$e1865c3bedcd822b() {\n    return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();\n}\nfunction $c87311424ea30a05$export$78551043582a6a98() {\n    return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();\n}\nfunction $c87311424ea30a05$export$6446a186d09e379e() {\n    return $c87311424ea30a05$var$testUserAgent(/Chrome/i);\n}\nfunction $c87311424ea30a05$export$a11b0059900ceec8() {\n    return $c87311424ea30a05$var$testUserAgent(/Android/i);\n}\nfunction $c87311424ea30a05$export$b7d78993b74f766d() {\n    return $c87311424ea30a05$var$testUserAgent(/Firefox/i);\n}\n\n\n\n\nconst $ea8dcbcb9ea1b556$var$RouterContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    isNative: true,\n    open: $ea8dcbcb9ea1b556$var$openSyntheticLink\n});\nfunction $ea8dcbcb9ea1b556$export$323e4fc2fa4753fb(props) {\n    let { children: children, navigate: navigate } = props;\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            isNative: false,\n            open: (target, modifiers)=>{\n                $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link)=>{\n                    if ($ea8dcbcb9ea1b556$export$efa8c9099e530235(link, modifiers)) navigate(link.pathname + link.search + link.hash);\n                    else $ea8dcbcb9ea1b556$export$95185d699e05d4d7(link, modifiers);\n                });\n            }\n        }), [\n        navigate\n    ]);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($ea8dcbcb9ea1b556$var$RouterContext.Provider, {\n        value: ctx\n    }, children);\n}\nfunction $ea8dcbcb9ea1b556$export$9a302a45f65d0572() {\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($ea8dcbcb9ea1b556$var$RouterContext);\n}\nfunction $ea8dcbcb9ea1b556$export$efa8c9099e530235(link, modifiers) {\n    // Use getAttribute here instead of link.target. Firefox will default link.target to \"_parent\" when inside an iframe.\n    let target = link.getAttribute(\"target\");\n    return (!target || target === \"_self\") && link.origin === location.origin && !link.hasAttribute(\"download\") && !modifiers.metaKey && // open in new tab (mac)\n    !modifiers.ctrlKey && // open in new tab (windows)\n    !modifiers.altKey && // download\n    !modifiers.shiftKey;\n}\nfunction $ea8dcbcb9ea1b556$export$95185d699e05d4d7(target, modifiers, setOpening = true) {\n    var _window_event_type, _window_event;\n    let { metaKey: metaKey, ctrlKey: ctrlKey, altKey: altKey, shiftKey: shiftKey } = modifiers;\n    // Firefox does not recognize keyboard events as a user action by default, and the popup blocker\n    // will prevent links with target=\"_blank\" from opening. However, it does allow the event if the\n    // Command/Control key is held, which opens the link in a background tab. This seems like the best we can do.\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=257870 and https://bugzilla.mozilla.org/show_bug.cgi?id=746640.\n    if ((0, $c87311424ea30a05$export$b7d78993b74f766d)() && ((_window_event = window.event) === null || _window_event === void 0 ? void 0 : (_window_event_type = _window_event.type) === null || _window_event_type === void 0 ? void 0 : _window_event_type.startsWith(\"key\")) && target.target === \"_blank\") {\n        if ((0, $c87311424ea30a05$export$9ac100e40613ea10)()) metaKey = true;\n        else ctrlKey = true;\n    }\n    // WebKit does not support firing click events with modifier keys, but does support keyboard events.\n    // https://github.com/WebKit/WebKit/blob/c03d0ac6e6db178f90923a0a63080b5ca210d25f/Source/WebCore/html/HTMLAnchorElement.cpp#L184\n    let event = (0, $c87311424ea30a05$export$78551043582a6a98)() && (0, $c87311424ea30a05$export$9ac100e40613ea10)() && !(0, $c87311424ea30a05$export$7bef049ce92e4224)() && true ? new KeyboardEvent(\"keydown\", {\n        keyIdentifier: \"Enter\",\n        metaKey: metaKey,\n        ctrlKey: ctrlKey,\n        altKey: altKey,\n        shiftKey: shiftKey\n    }) : new MouseEvent(\"click\", {\n        metaKey: metaKey,\n        ctrlKey: ctrlKey,\n        altKey: altKey,\n        shiftKey: shiftKey,\n        bubbles: true,\n        cancelable: true\n    });\n    $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = setOpening;\n    (0, $7215afc6de606d6b$export$de79e2c695e052f3)(target);\n    target.dispatchEvent(event);\n    $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;\n}\n// https://github.com/parcel-bundler/parcel/issues/8724\n$ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;\nfunction $ea8dcbcb9ea1b556$var$getSyntheticLink(target, open) {\n    if (target instanceof HTMLAnchorElement) open(target);\n    else if (target.hasAttribute(\"data-href\")) {\n        let link = document.createElement(\"a\");\n        link.href = target.getAttribute(\"data-href\");\n        if (target.hasAttribute(\"data-target\")) link.target = target.getAttribute(\"data-target\");\n        if (target.hasAttribute(\"data-rel\")) link.rel = target.getAttribute(\"data-rel\");\n        if (target.hasAttribute(\"data-download\")) link.download = target.getAttribute(\"data-download\");\n        if (target.hasAttribute(\"data-ping\")) link.ping = target.getAttribute(\"data-ping\");\n        if (target.hasAttribute(\"data-referrer-policy\")) link.referrerPolicy = target.getAttribute(\"data-referrer-policy\");\n        target.appendChild(link);\n        open(link);\n        target.removeChild(link);\n    }\n}\nfunction $ea8dcbcb9ea1b556$var$openSyntheticLink(target, modifiers) {\n    $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link)=>$ea8dcbcb9ea1b556$export$95185d699e05d4d7(link, modifiers));\n}\nfunction $ea8dcbcb9ea1b556$export$51437d503373d223(props) {\n    return {\n        \"data-href\": props.href,\n        \"data-target\": props.target,\n        \"data-rel\": props.rel,\n        \"data-download\": props.download,\n        \"data-ping\": props.ping,\n        \"data-referrer-policy\": props.referrerPolicy\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // We store a global list of elements that are currently transitioning,\n// mapped to a set of CSS properties that are transitioning for that element.\n// This is necessary rather than a simple count of transitions because of browser\n// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather\n// than one or the other. So we need to track what's actually transitioning so that\n// we can ignore these duplicate events.\nlet $bbed8b41f857bcc0$var$transitionsByElement = new Map();\n// A list of callbacks to call once there are no transitioning elements.\nlet $bbed8b41f857bcc0$var$transitionCallbacks = new Set();\nfunction $bbed8b41f857bcc0$var$setupGlobalEvents() {\n    if (typeof window === \"undefined\") return;\n    let onTransitionStart = (e)=>{\n        // Add the transitioning property to the list for this element.\n        let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n        if (!transitions) {\n            transitions = new Set();\n            $bbed8b41f857bcc0$var$transitionsByElement.set(e.target, transitions);\n            // The transitioncancel event must be registered on the element itself, rather than as a global\n            // event. This enables us to handle when the node is deleted from the document while it is transitioning.\n            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.\n            e.target.addEventListener(\"transitioncancel\", onTransitionEnd);\n        }\n        transitions.add(e.propertyName);\n    };\n    let onTransitionEnd = (e)=>{\n        // Remove property from list of transitioning properties.\n        let properties = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n        if (!properties) return;\n        properties.delete(e.propertyName);\n        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.\n        if (properties.size === 0) {\n            e.target.removeEventListener(\"transitioncancel\", onTransitionEnd);\n            $bbed8b41f857bcc0$var$transitionsByElement.delete(e.target);\n        }\n        // If no transitioning elements, call all of the queued callbacks.\n        if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {\n            for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks)cb();\n            $bbed8b41f857bcc0$var$transitionCallbacks.clear();\n        }\n    };\n    document.body.addEventListener(\"transitionrun\", onTransitionStart);\n    document.body.addEventListener(\"transitionend\", onTransitionEnd);\n}\nif (typeof document !== \"undefined\") {\n    if (document.readyState !== \"loading\") $bbed8b41f857bcc0$var$setupGlobalEvents();\n    else document.addEventListener(\"DOMContentLoaded\", $bbed8b41f857bcc0$var$setupGlobalEvents);\n}\nfunction $bbed8b41f857bcc0$export$24490316f764c430(fn) {\n    // Wait one frame to see if an animation starts, e.g. a transition on mount.\n    requestAnimationFrame(()=>{\n        // If no transitions are running, call the function immediately.\n        // Otherwise, add it to a list of callbacks to run at the end of the animation.\n        if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) fn();\n        else $bbed8b41f857bcc0$var$transitionCallbacks.add(fn);\n    });\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /* eslint-disable rulesdir/pure-render */ \n\n// Keep track of elements that we are currently handling dragging for via useDrag1D.\n// If there's an ancestor and a descendant both using useDrag1D(), and the user starts\n// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.\nconst $9cc09df9fd7676be$var$draggingElements = [];\nfunction $9cc09df9fd7676be$export$7bbed75feba39706(props) {\n    console.warn(\"useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html\");\n    let { containerRef: containerRef, reverse: reverse, orientation: orientation, onHover: onHover, onDrag: onDrag, onPositionChange: onPositionChange, onIncrement: onIncrement, onDecrement: onDecrement, onIncrementToMax: onIncrementToMax, onDecrementToMin: onDecrementToMin, onCollapseToggle: onCollapseToggle } = props;\n    let getPosition = (e)=>orientation === \"horizontal\" ? e.clientX : e.clientY;\n    let getNextOffset = (e)=>{\n        let containerOffset = (0, $ab71dadb03a6fb2e$export$622cea445a1c5b7d)(containerRef.current, reverse, orientation);\n        let mouseOffset = getPosition(e);\n        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;\n        return nextOffset;\n    };\n    let dragging = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let prevPosition = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Keep track of the current handlers in a ref so that the events can access them.\n    let handlers = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        onPositionChange: onPositionChange,\n        onDrag: onDrag\n    });\n    handlers.current.onDrag = onDrag;\n    handlers.current.onPositionChange = onPositionChange;\n    let onMouseDragged = (e)=>{\n        e.preventDefault();\n        let nextOffset = getNextOffset(e);\n        if (!dragging.current) {\n            dragging.current = true;\n            if (handlers.current.onDrag) handlers.current.onDrag(true);\n            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);\n        }\n        if (prevPosition.current === nextOffset) return;\n        prevPosition.current = nextOffset;\n        if (onPositionChange) onPositionChange(nextOffset);\n    };\n    let onMouseUp = (e)=>{\n        const target = e.target;\n        dragging.current = false;\n        let nextOffset = getNextOffset(e);\n        if (handlers.current.onDrag) handlers.current.onDrag(false);\n        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);\n        $9cc09df9fd7676be$var$draggingElements.splice($9cc09df9fd7676be$var$draggingElements.indexOf(target), 1);\n        window.removeEventListener(\"mouseup\", onMouseUp, false);\n        window.removeEventListener(\"mousemove\", onMouseDragged, false);\n    };\n    let onMouseDown = (e)=>{\n        const target = e.currentTarget;\n        // If we're already handling dragging on a descendant with useDrag1D, then\n        // we don't want to handle the drag motion on this target as well.\n        if ($9cc09df9fd7676be$var$draggingElements.some((elt)=>target.contains(elt))) return;\n        $9cc09df9fd7676be$var$draggingElements.push(target);\n        window.addEventListener(\"mousemove\", onMouseDragged, false);\n        window.addEventListener(\"mouseup\", onMouseUp, false);\n    };\n    let onMouseEnter = ()=>{\n        if (onHover) onHover(true);\n    };\n    let onMouseOut = ()=>{\n        if (onHover) onHover(false);\n    };\n    let onKeyDown = (e)=>{\n        switch(e.key){\n            case \"Left\":\n            case \"ArrowLeft\":\n                if (orientation === \"horizontal\") {\n                    e.preventDefault();\n                    if (onDecrement && !reverse) onDecrement();\n                    else if (onIncrement && reverse) onIncrement();\n                }\n                break;\n            case \"Up\":\n            case \"ArrowUp\":\n                if (orientation === \"vertical\") {\n                    e.preventDefault();\n                    if (onDecrement && !reverse) onDecrement();\n                    else if (onIncrement && reverse) onIncrement();\n                }\n                break;\n            case \"Right\":\n            case \"ArrowRight\":\n                if (orientation === \"horizontal\") {\n                    e.preventDefault();\n                    if (onIncrement && !reverse) onIncrement();\n                    else if (onDecrement && reverse) onDecrement();\n                }\n                break;\n            case \"Down\":\n            case \"ArrowDown\":\n                if (orientation === \"vertical\") {\n                    e.preventDefault();\n                    if (onIncrement && !reverse) onIncrement();\n                    else if (onDecrement && reverse) onDecrement();\n                }\n                break;\n            case \"Home\":\n                e.preventDefault();\n                if (onDecrementToMin) onDecrementToMin();\n                break;\n            case \"End\":\n                e.preventDefault();\n                if (onIncrementToMax) onIncrementToMax();\n                break;\n            case \"Enter\":\n                e.preventDefault();\n                if (onCollapseToggle) onCollapseToggle();\n                break;\n        }\n    };\n    return {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        onKeyDown: onKeyDown\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $03deb23ff14920c4$export$4eaf04e54aa8eed6() {\n    let globalListeners = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    let addGlobalListener = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((eventTarget, type, listener, options)=>{\n        // Make sure we remove the listener after it is called with the `once` option.\n        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{\n            globalListeners.current.delete(listener);\n            listener(...args);\n        } : listener;\n        globalListeners.current.set(listener, {\n            type: type,\n            eventTarget: eventTarget,\n            fn: fn,\n            options: options\n        });\n        eventTarget.addEventListener(type, listener, options);\n    }, []);\n    let removeGlobalListener = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((eventTarget, type, listener, options)=>{\n        var _globalListeners_current_get;\n        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;\n        eventTarget.removeEventListener(type, fn, options);\n        globalListeners.current.delete(listener);\n    }, []);\n    let removeAllGlobalListeners = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        globalListeners.current.forEach((value, key)=>{\n            removeGlobalListener(value.eventTarget, value.type, key, value.options);\n        });\n    }, [\n        removeGlobalListener\n    ]);\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return removeAllGlobalListeners;\n    }, [\n        removeAllGlobalListeners\n    ]);\n    return {\n        addGlobalListener: addGlobalListener,\n        removeGlobalListener: removeGlobalListener,\n        removeAllGlobalListeners: removeAllGlobalListeners\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $313b98861ee5dd6c$export$d6875122194c7b44(props, defaultLabel) {\n    let { id: id, \"aria-label\": label, \"aria-labelledby\": labelledBy } = props;\n    // If there is both an aria-label and aria-labelledby,\n    // combine them by pointing to the element itself.\n    id = (0, $bdb11010cef70236$export$f680877a34711e37)(id);\n    if (labelledBy && label) {\n        let ids = new Set([\n            id,\n            ...labelledBy.trim().split(/\\s+/)\n        ]);\n        labelledBy = [\n            ...ids\n        ].join(\" \");\n    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\\s+/).join(\" \");\n    // If no labels are provided, use the default\n    if (!label && !labelledBy && defaultLabel) label = defaultLabel;\n    return {\n        id: id,\n        \"aria-label\": label,\n        \"aria-labelledby\": labelledBy\n    };\n}\n\n\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $df56164dff5785e2$export$4338b53315abf666(forwardedRef) {\n    const objRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            get current () {\n                return objRef.current;\n            },\n            set current (value){\n                objRef.current = value;\n                if (typeof forwardedRef === \"function\") forwardedRef(value);\n                else if (forwardedRef) forwardedRef.current = value;\n            }\n        }), [\n        forwardedRef\n    ]);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $4f58c5f72bcf79f7$export$496315a1608d9602(effect, dependencies) {\n    const isInitialMount = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const lastDeps = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        isInitialMount.current = true;\n        return ()=>{\n            isInitialMount.current = false;\n        };\n    }, []);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isInitialMount.current) isInitialMount.current = false;\n        else if (!lastDeps.current || dependencies.some((dep, i)=>!Object.is(dep, lastDeps[i]))) effect();\n        lastDeps.current = dependencies;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, dependencies);\n}\n\n\n\n\nfunction $9daab02d461809db$var$hasResizeObserver() {\n    return typeof window.ResizeObserver !== \"undefined\";\n}\nfunction $9daab02d461809db$export$683480f191c0e3ea(options) {\n    const { ref: ref, onResize: onResize } = options;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let element = ref === null || ref === void 0 ? void 0 : ref.current;\n        if (!element) return;\n        if (!$9daab02d461809db$var$hasResizeObserver()) {\n            window.addEventListener(\"resize\", onResize, false);\n            return ()=>{\n                window.removeEventListener(\"resize\", onResize, false);\n            };\n        } else {\n            const resizeObserverInstance = new window.ResizeObserver((entries)=>{\n                if (!entries.length) return;\n                onResize();\n            });\n            resizeObserverInstance.observe(element);\n            return ()=>{\n                if (element) resizeObserverInstance.unobserve(element);\n            };\n        }\n    }, [\n        onResize,\n        ref\n    ]);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $e7801be82b4b2a53$export$4debdb1a3f0fa79e(context, ref) {\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        if (context && context.ref && ref) {\n            context.ref.current = ref.current;\n            return ()=>{\n                context.ref.current = null;\n            };\n        }\n    });\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $62d8ded9296f3872$export$cfa2225e87938781(node) {\n    if ($62d8ded9296f3872$export$2bb74740c4e19def(node)) node = node.parentElement;\n    while(node && !$62d8ded9296f3872$export$2bb74740c4e19def(node))node = node.parentElement;\n    return node || document.scrollingElement || document.documentElement;\n}\nfunction $62d8ded9296f3872$export$2bb74740c4e19def(node) {\n    let style = window.getComputedStyle(node);\n    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n// @ts-ignore\nlet $5df64b3807dc15ee$var$visualViewport = typeof document !== \"undefined\" && window.visualViewport;\nfunction $5df64b3807dc15ee$export$d699905dd57c73ca() {\n    let isSSR = (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_2__.useIsSSR)();\n    let [size, setSize] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>isSSR ? {\n            width: 0,\n            height: 0\n        } : $5df64b3807dc15ee$var$getViewportSize());\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Use visualViewport api to track available height even on iOS virtual keyboard opening\n        let onResize = ()=>{\n            setSize((size)=>{\n                let newSize = $5df64b3807dc15ee$var$getViewportSize();\n                if (newSize.width === size.width && newSize.height === size.height) return size;\n                return newSize;\n            });\n        };\n        if (!$5df64b3807dc15ee$var$visualViewport) window.addEventListener(\"resize\", onResize);\n        else $5df64b3807dc15ee$var$visualViewport.addEventListener(\"resize\", onResize);\n        return ()=>{\n            if (!$5df64b3807dc15ee$var$visualViewport) window.removeEventListener(\"resize\", onResize);\n            else $5df64b3807dc15ee$var$visualViewport.removeEventListener(\"resize\", onResize);\n        };\n    }, []);\n    return size;\n}\nfunction $5df64b3807dc15ee$var$getViewportSize() {\n    return {\n        width: ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.width) || window.innerWidth,\n        height: ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.height) || window.innerHeight\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nlet $ef06256079686ba0$var$descriptionId = 0;\nconst $ef06256079686ba0$var$descriptionNodes = new Map();\nfunction $ef06256079686ba0$export$f8aeda7b10753fa1(description) {\n    let [id, setId] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        if (!description) return;\n        let desc = $ef06256079686ba0$var$descriptionNodes.get(description);\n        if (!desc) {\n            let id = `react-aria-description-${$ef06256079686ba0$var$descriptionId++}`;\n            setId(id);\n            let node = document.createElement(\"div\");\n            node.id = id;\n            node.style.display = \"none\";\n            node.textContent = description;\n            document.body.appendChild(node);\n            desc = {\n                refCount: 0,\n                element: node\n            };\n            $ef06256079686ba0$var$descriptionNodes.set(description, desc);\n        } else setId(desc.element.id);\n        desc.refCount++;\n        return ()=>{\n            if (--desc.refCount === 0) {\n                desc.element.remove();\n                $ef06256079686ba0$var$descriptionNodes.delete(description);\n            }\n        };\n    }, [\n        description\n    ]);\n    return {\n        \"aria-describedby\": description ? id : undefined\n    };\n}\n\n\n\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nfunction $e9faafb641e167db$export$90fc3a17d93f704c(ref, event, handler, options) {\n    let handleEvent = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(handler);\n    let isDisabled = handler == null;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isDisabled) return;\n        let element = ref.current;\n        element.addEventListener(event, handleEvent, options);\n        return ()=>{\n            element.removeEventListener(event, handleEvent, options);\n        };\n    }, [\n        ref,\n        event,\n        options,\n        isDisabled,\n        handleEvent\n    ]);\n}\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollView, element) {\n    let offsetX = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element, \"left\");\n    let offsetY = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element, \"top\");\n    let width = element.offsetWidth;\n    let height = element.offsetHeight;\n    let x = scrollView.scrollLeft;\n    let y = scrollView.scrollTop;\n    // Account for top/left border offsetting the scroll top/Left\n    let { borderTopWidth: borderTopWidth, borderLeftWidth: borderLeftWidth } = getComputedStyle(scrollView);\n    let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);\n    let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);\n    // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width\n    let maxX = borderAdjustedX + scrollView.clientWidth;\n    let maxY = borderAdjustedY + scrollView.clientHeight;\n    if (offsetX <= x) x = offsetX - parseInt(borderLeftWidth, 10);\n    else if (offsetX + width > maxX) x += offsetX + width - maxX;\n    if (offsetY <= borderAdjustedY) y = offsetY - parseInt(borderTopWidth, 10);\n    else if (offsetY + height > maxY) y += offsetY + height - maxY;\n    scrollView.scrollLeft = x;\n    scrollView.scrollTop = y;\n}\n/**\n * Computes the offset left or top from child to ancestor by accumulating\n * offsetLeft or offsetTop through intervening offsetParents.\n */ function $2f04cbc44ee30ce0$var$relativeOffset(ancestor, child, axis) {\n    const prop = axis === \"left\" ? \"offsetLeft\" : \"offsetTop\";\n    let sum = 0;\n    while(child.offsetParent){\n        sum += child[prop];\n        if (child.offsetParent === ancestor) break;\n        else if (child.offsetParent.contains(ancestor)) {\n            // If the ancestor is not `position:relative`, then we stop at\n            // _its_ offset parent, and we subtract off _its_ offset, so that\n            // we end up with the proper offset from child to ancestor.\n            sum -= ancestor[prop];\n            break;\n        }\n        child = child.offsetParent;\n    }\n    return sum;\n}\nfunction $2f04cbc44ee30ce0$export$c826860796309d1b(targetElement, opts) {\n    if (document.contains(targetElement)) {\n        let root = document.scrollingElement || document.documentElement;\n        let isScrollPrevented = window.getComputedStyle(root).overflow === \"hidden\";\n        // If scrolling is not currently prevented then we aren’t in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view\n        if (!isScrollPrevented) {\n            var // use scrollIntoView({block: 'nearest'}) instead of .focus to check if the element is fully in view or not since .focus()\n            // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically\n            _targetElement_scrollIntoView;\n            let { left: originalLeft, top: originalTop } = targetElement.getBoundingClientRect();\n            targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {\n                block: \"nearest\"\n            });\n            let { left: newLeft, top: newTop } = targetElement.getBoundingClientRect();\n            // Account for sub pixel differences from rounding\n            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {\n                var _opts_containingElement_scrollIntoView, _opts_containingElement, _targetElement_scrollIntoView1;\n                opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {\n                    block: \"center\",\n                    inline: \"center\"\n                });\n                (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {\n                    block: \"nearest\"\n                });\n            }\n        } else {\n            let scrollParent = (0, $62d8ded9296f3872$export$cfa2225e87938781)(targetElement);\n            // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.\n            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){\n                $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollParent, targetElement);\n                targetElement = scrollParent;\n                scrollParent = (0, $62d8ded9296f3872$export$cfa2225e87938781)(targetElement);\n            }\n        }\n    }\n}\n\n\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $6a7db85432448f7f$export$60278871457622de(event) {\n    // JAWS/NVDA with Firefox.\n    if (event.mozInputSource === 0 && event.isTrusted) return true;\n    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead\n    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check\n    // to detect TalkBack virtual clicks.\n    if ((0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.pointerType) return event.type === \"click\" && event.buttons === 1;\n    return event.detail === 0 && !event.pointerType;\n}\nfunction $6a7db85432448f7f$export$29bf1b5f2c56cf63(event) {\n    // If the pointer size is zero, then we assume it's from a screen reader.\n    // Android TalkBack double tap will sometimes return a event with width and height of 1\n    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.\n    // Cannot use \"event.pressure === 0\" as the sole check due to Safari pointer events always returning pressure === 0\n    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush\n    // Talkback double tap from Windows Firefox touch screen press\n    return !(0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === \"mouse\";\n}\n\n\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /* eslint-disable rulesdir/pure-render */ \nfunction $5a387cc49350e6db$export$722debc0e56fea39(value, isEqual) {\n    // Using a ref during render is ok here because it's only an optimization – both values are equivalent.\n    // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.\n    let lastValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    if (value && lastValue.current && isEqual(value, lastValue.current)) value = lastValue.current;\n    lastValue.current = value;\n    return value;\n}\n\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nfunction $99facab73266f662$export$5add1d006293d136(ref, initialValue, onReset) {\n    let resetValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialValue);\n    let handleReset = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(()=>{\n        if (onReset) onReset(resetValue.current);\n    });\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _ref_current;\n        let form = ref === null || ref === void 0 ? void 0 : (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.form;\n        form === null || form === void 0 ? void 0 : form.addEventListener(\"reset\", handleReset);\n        return ()=>{\n            form === null || form === void 0 ? void 0 : form.removeEventListener(\"reset\", handleReset);\n        };\n    }, [\n        ref,\n        handleReset\n    ]);\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL3V0aWxzL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdKO0FBQzhHO0FBQzdKO0FBQ2xFOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLGtDQUFZOzs7O0FBSXBHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHlDQUFhO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBa0I7QUFDakM7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQSxnQ0FBZ0MsMkNBQWU7QUFDL0MscUJBQXFCLHlDQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJDQUFlO0FBQy9DLHFCQUFxQix5Q0FBYTtBQUNsQyxrQkFBa0IseURBQW1CO0FBQ3JDLDBCQUEwQiw4Q0FBa0I7QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtB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QTZCLGtDQUFZO0FBQ3pDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLDZDQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5RUFBeUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK1NBQStTO0FBQ3pUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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ZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL3V0aWxzL2Rpc3QvaW1wb3J0Lm1qcz8wYWJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y2xhbXAgYXMgJDQ1MDc0NjFhMWI4NzAxMjMkcmVfZXhwb3J0JGNsYW1wLCBzbmFwVmFsdWVUb1N0ZXAgYXMgJDQ1MDc0NjFhMWI4NzAxMjMkcmVfZXhwb3J0JHNuYXBWYWx1ZVRvU3RlcH0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5pbXBvcnQgJDEydUdwJHJlYWN0LCB7dXNlU3RhdGUgYXMgJDEydUdwJHVzZVN0YXRlLCB1c2VSZWYgYXMgJDEydUdwJHVzZVJlZiwgdXNlQ2FsbGJhY2sgYXMgJDEydUdwJHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgYXMgJDEydUdwJHVzZUVmZmVjdCwgY3JlYXRlQ29udGV4dCBhcyAkMTJ1R3AkY3JlYXRlQ29udGV4dCwgdXNlTWVtbyBhcyAkMTJ1R3AkdXNlTWVtbywgdXNlQ29udGV4dCBhcyAkMTJ1R3AkdXNlQ29udGV4dH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZVNTUlNhZmVJZCBhcyAkMTJ1R3AkdXNlU1NSU2FmZUlkLCB1c2VJc1NTUiBhcyAkMTJ1R3AkdXNlSXNTU1J9IGZyb20gXCJAcmVhY3QtYXJpYS9zc3JcIjtcbmltcG9ydCAkMTJ1R3AkY2xzeCBmcm9tIFwiY2xzeFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuY29uc3QgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyAoMCwgJDEydUdwJHJlYWN0KS51c2VMYXlvdXRFZmZlY3QgOiAoKT0+e307XG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmZ1bmN0aW9uICQ4YWUwNWVhYTVjMTE0ZTljJGV4cG9ydCQ3ZjU0ZmMzMTgwNTA4YTUyKGZuKSB7XG4gICAgY29uc3QgcmVmID0gKDAsICQxMnVHcCR1c2VSZWYpKG51bGwpO1xuICAgICgwLCAkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYykoKCk9PntcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBmbjtcbiAgICB9LCBbXG4gICAgICAgIGZuXG4gICAgXSk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiAoMCwgJDEydUdwJHVzZUNhbGxiYWNrKSgoLi4uYXJncyk9PntcbiAgICAgICAgY29uc3QgZiA9IHJlZi5jdXJyZW50O1xuICAgICAgICByZXR1cm4gZiguLi5hcmdzKTtcbiAgICB9LCBbXSk7XG59XG5cblxuZnVuY3Rpb24gJDFkYmVjYmUyN2EwNGY5YWYkZXhwb3J0JDE0ZDIzOGYzNDI3MjNmMjUoZGVmYXVsdFZhbHVlKSB7XG4gICAgbGV0IFt2YWx1ZSwgc2V0VmFsdWVdID0gKDAsICQxMnVHcCR1c2VTdGF0ZSkoZGVmYXVsdFZhbHVlKTtcbiAgICBsZXQgZWZmZWN0ID0gKDAsICQxMnVHcCR1c2VSZWYpKG51bGwpO1xuICAgIC8vIFN0b3JlIHRoZSBmdW5jdGlvbiBpbiBhIHJlZiBzbyB3ZSBjYW4gYWx3YXlzIGFjY2VzcyB0aGUgY3VycmVudCB2ZXJzaW9uXG4gICAgLy8gd2hpY2ggaGFzIHRoZSBwcm9wZXIgYHZhbHVlYCBpbiBzY29wZS5cbiAgICBsZXQgbmV4dFJlZiA9ICgwLCAkOGFlMDVlYWE1YzExNGU5YyRleHBvcnQkN2Y1NGZjMzE4MDUwOGE1MikoKCk9PntcbiAgICAgICAgLy8gUnVuIHRoZSBnZW5lcmF0b3IgdG8gdGhlIG5leHQgeWllbGQuXG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IGVmZmVjdC5jdXJyZW50Lm5leHQoKTtcbiAgICAgICAgLy8gSWYgdGhlIGdlbmVyYXRvciBpcyBkb25lLCByZXNldCB0aGUgZWZmZWN0LlxuICAgICAgICBpZiAobmV3VmFsdWUuZG9uZSkge1xuICAgICAgICAgICAgZWZmZWN0LmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCB2YWx1ZSxcbiAgICAgICAgLy8gdGhlbiBjb250aW51ZSB0byB0aGUgbmV4dCB5aWVsZC4gT3RoZXJ3aXNlLFxuICAgICAgICAvLyBzZXQgdGhlIHZhbHVlIGluIHN0YXRlIGFuZCB3YWl0IGZvciB0aGUgbmV4dCBsYXlvdXQgZWZmZWN0LlxuICAgICAgICBpZiAodmFsdWUgPT09IG5ld1ZhbHVlLnZhbHVlKSBuZXh0UmVmKCk7XG4gICAgICAgIGVsc2Ugc2V0VmFsdWUobmV3VmFsdWUudmFsdWUpO1xuICAgIH0pO1xuICAgICgwLCAkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYykoKCk9PntcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gZWZmZWN0IGN1cnJlbnRseSBydW5uaW5nLCBjb250aW51ZSB0byB0aGUgbmV4dCB5aWVsZC5cbiAgICAgICAgaWYgKGVmZmVjdC5jdXJyZW50KSBuZXh0UmVmKCk7XG4gICAgfSk7XG4gICAgbGV0IHF1ZXVlID0gKDAsICQ4YWUwNWVhYTVjMTE0ZTljJGV4cG9ydCQ3ZjU0ZmMzMTgwNTA4YTUyKSgoZm4pPT57XG4gICAgICAgIGVmZmVjdC5jdXJyZW50ID0gZm4odmFsdWUpO1xuICAgICAgICBuZXh0UmVmKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHF1ZXVlXG4gICAgXTtcbn1cblxuXG4vLyBjb3BpZWQgZnJvbSBTU1JQcm92aWRlci50c3ggdG8gcmVkdWNlIGV4cG9ydHMsIGlmIG5lZWRlZCBhZ2FpbiwgY29uc2lkZXIgc2hhcmluZ1xubGV0ICRiZGIxMTAxMGNlZjcwMjM2JHZhciRjYW5Vc2VET00gPSBCb29sZWFuKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbmxldCAkYmRiMTEwMTBjZWY3MDIzNiR2YXIkaWRzVXBkYXRlck1hcCA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uICRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRmNjgwODc3YTM0NzExZTM3KGRlZmF1bHRJZCkge1xuICAgIGxldCBbdmFsdWUsIHNldFZhbHVlXSA9ICgwLCAkMTJ1R3AkdXNlU3RhdGUpKGRlZmF1bHRJZCk7XG4gICAgbGV0IG5leHRJZCA9ICgwLCAkMTJ1R3AkdXNlUmVmKShudWxsKTtcbiAgICBsZXQgcmVzID0gKDAsICQxMnVHcCR1c2VTU1JTYWZlSWQpKHZhbHVlKTtcbiAgICBsZXQgdXBkYXRlVmFsdWUgPSAoMCwgJDEydUdwJHVzZUNhbGxiYWNrKSgodmFsKT0+e1xuICAgICAgICBuZXh0SWQuY3VycmVudCA9IHZhbDtcbiAgICB9LCBbXSk7XG4gICAgaWYgKCRiZGIxMTAxMGNlZjcwMjM2JHZhciRjYW5Vc2VET00pICRiZGIxMTAxMGNlZjcwMjM2JHZhciRpZHNVcGRhdGVyTWFwLnNldChyZXMsIHVwZGF0ZVZhbHVlKTtcbiAgICAoMCwgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMpKCgpPT57XG4gICAgICAgIGxldCByID0gcmVzO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICRiZGIxMTAxMGNlZjcwMjM2JHZhciRpZHNVcGRhdGVyTWFwLmRlbGV0ZShyKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHJlc1xuICAgIF0pO1xuICAgIC8vIFRoaXMgY2Fubm90IGNhdXNlIGFuIGluZmluaXRlIGxvb3AgYmVjYXVzZSB0aGUgcmVmIGlzIHVwZGF0ZWQgZmlyc3QuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgKDAsICQxMnVHcCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCBuZXdJZCA9IG5leHRJZC5jdXJyZW50O1xuICAgICAgICBpZiAobmV3SWQpIHtcbiAgICAgICAgICAgIG5leHRJZC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHNldFZhbHVlKG5ld0lkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiAkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkY2Q4YzljYjY4Zjg0MjYyOShpZEEsIGlkQikge1xuICAgIGlmIChpZEEgPT09IGlkQikgcmV0dXJuIGlkQTtcbiAgICBsZXQgc2V0SWRBID0gJGJkYjExMDEwY2VmNzAyMzYkdmFyJGlkc1VwZGF0ZXJNYXAuZ2V0KGlkQSk7XG4gICAgaWYgKHNldElkQSkge1xuICAgICAgICBzZXRJZEEoaWRCKTtcbiAgICAgICAgcmV0dXJuIGlkQjtcbiAgICB9XG4gICAgbGV0IHNldElkQiA9ICRiZGIxMTAxMGNlZjcwMjM2JHZhciRpZHNVcGRhdGVyTWFwLmdldChpZEIpO1xuICAgIGlmIChzZXRJZEIpIHtcbiAgICAgICAgc2V0SWRCKGlkQSk7XG4gICAgICAgIHJldHVybiBpZEE7XG4gICAgfVxuICAgIHJldHVybiBpZEI7XG59XG5mdW5jdGlvbiAkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkYjRjYzA5YzU5MmU4ZmRiOChkZXBBcnJheSA9IFtdKSB7XG4gICAgbGV0IGlkID0gJGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGY2ODA4NzdhMzQ3MTFlMzcoKTtcbiAgICBsZXQgW3Jlc29sdmVkSWQsIHNldFJlc29sdmVkSWRdID0gKDAsICQxZGJlY2JlMjdhMDRmOWFmJGV4cG9ydCQxNGQyMzhmMzQyNzIzZjI1KShpZCk7XG4gICAgbGV0IHVwZGF0ZUlkID0gKDAsICQxMnVHcCR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0UmVzb2x2ZWRJZChmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICB5aWVsZCBpZDtcbiAgICAgICAgICAgIHlpZWxkIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA/IGlkIDogdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIGlkLFxuICAgICAgICBzZXRSZXNvbHZlZElkXG4gICAgXSk7XG4gICAgKDAsICRmMGEwNGNjZDhkYmRkODNiJGV4cG9ydCRlNWM1YTVmOTE3YTU4NzFjKSh1cGRhdGVJZCwgW1xuICAgICAgICBpZCxcbiAgICAgICAgdXBkYXRlSWQsXG4gICAgICAgIC4uLmRlcEFycmF5XG4gICAgXSk7XG4gICAgcmV0dXJuIHJlc29sdmVkSWQ7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qKlxuICogQ2FsbHMgYWxsIGZ1bmN0aW9ucyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIGNoYWluZWQgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMuXG4gKi8gZnVuY3Rpb24gJGZmNTk2M2ViMWZjY2Y1NTIkZXhwb3J0JGUwOGUzYjY3ZTM5MjEwMWUoLi4uY2FsbGJhY2tzKSB7XG4gICAgcmV0dXJuICguLi5hcmdzKT0+e1xuICAgICAgICBmb3IgKGxldCBjYWxsYmFjayBvZiBjYWxsYmFja3MpaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSBjYWxsYmFjayguLi5hcmdzKTtcbiAgICB9O1xufVxuXG5cbmNvbnN0ICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRiMjA0YWYxNTgwNDJmYmFjID0gKGVsKT0+e1xuICAgIHZhciBfZWxfb3duZXJEb2N1bWVudDtcbiAgICByZXR1cm4gKF9lbF9vd25lckRvY3VtZW50ID0gZWwgPT09IG51bGwgfHwgZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsLm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9lbF9vd25lckRvY3VtZW50ICE9PSB2b2lkIDAgPyBfZWxfb3duZXJEb2N1bWVudCA6IGRvY3VtZW50O1xufTtcbmNvbnN0ICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRmMjFhMWZmYWUyNjAxNDVhID0gKGVsKT0+e1xuICAgIGlmIChlbCAmJiBcIndpbmRvd1wiIGluIGVsICYmIGVsLndpbmRvdyA9PT0gZWwpIHJldHVybiBlbDtcbiAgICBjb25zdCBkb2MgPSAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkYjIwNGFmMTU4MDQyZmJhYyhlbCk7XG4gICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG59O1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5mdW5jdGlvbiAkM2VmNDI1NzVkZjg0YjMwYiRleHBvcnQkOWQxNjExYzc3YzJmZTkyOCguLi5hcmdzKSB7XG4gICAgLy8gU3RhcnQgd2l0aCBhIGJhc2UgY2xvbmUgb2YgdGhlIGZpcnN0IGFyZ3VtZW50LiBUaGlzIGlzIGEgbG90IGZhc3RlciB0aGFuIHN0YXJ0aW5nXG4gICAgLy8gd2l0aCBhbiBlbXB0eSBvYmplY3QgYW5kIGFkZGluZyBwcm9wZXJ0aWVzIGFzIHdlIGdvLlxuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIC4uLmFyZ3NbMF1cbiAgICB9O1xuICAgIGZvcihsZXQgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgbGV0IHByb3BzID0gYXJnc1tpXTtcbiAgICAgICAgZm9yKGxldCBrZXkgaW4gcHJvcHMpe1xuICAgICAgICAgICAgbGV0IGEgPSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgIGxldCBiID0gcHJvcHNba2V5XTtcbiAgICAgICAgICAgIC8vIENoYWluIGV2ZW50c1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGIgPT09IFwiZnVuY3Rpb25cIiAmJiAvLyBUaGlzIGlzIGEgbG90IGZhc3RlciB0aGFuIGEgcmVnZXguXG4gICAgICAgICAgICBrZXlbMF0gPT09IFwib1wiICYmIGtleVsxXSA9PT0gXCJuXCIgJiYga2V5LmNoYXJDb2RlQXQoMikgPj0gLyogJ0EnICovIDY1ICYmIGtleS5jaGFyQ29kZUF0KDIpIDw9IC8qICdaJyAqLyA5MCkgcmVzdWx0W2tleV0gPSAoMCwgJGZmNTk2M2ViMWZjY2Y1NTIkZXhwb3J0JGUwOGUzYjY3ZTM5MjEwMWUpKGEsIGIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoKGtleSA9PT0gXCJjbGFzc05hbWVcIiB8fCBrZXkgPT09IFwiVU5TQUZFX2NsYXNzTmFtZVwiKSAmJiB0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgYiA9PT0gXCJzdHJpbmdcIikgcmVzdWx0W2tleV0gPSAoMCwgJDEydUdwJGNsc3gpKGEsIGIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImlkXCIgJiYgYSAmJiBiKSByZXN1bHQuaWQgPSAoMCwgJGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGNkOGM5Y2I2OGY4NDI2MjkpKGEsIGIpO1xuICAgICAgICAgICAgZWxzZSByZXN1bHRba2V5XSA9IGIgIT09IHVuZGVmaW5lZCA/IGIgOiBhO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICQ1ZGM5NTg5OWIzMDZmNjMwJGV4cG9ydCRjOTA1ODMxNjc2NGMxNDBlKC4uLnJlZnMpIHtcbiAgICBpZiAocmVmcy5sZW5ndGggPT09IDEpIHJldHVybiByZWZzWzBdO1xuICAgIHJldHVybiAodmFsdWUpPT57XG4gICAgICAgIGZvciAobGV0IHJlZiBvZiByZWZzKXtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHJlZih2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChyZWYgIT0gbnVsbCkgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNvbnN0ICQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRET01Qcm9wTmFtZXMgPSBuZXcgU2V0KFtcbiAgICBcImlkXCJcbl0pO1xuY29uc3QgJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJGxhYmVsYWJsZVByb3BOYW1lcyA9IG5ldyBTZXQoW1xuICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCIsXG4gICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCIsXG4gICAgXCJhcmlhLWRldGFpbHNcIlxuXSk7XG4vLyBTZWUgTGlua0RPTVByb3BzIGluIGRvbS5kLnRzLlxuY29uc3QgJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJGxpbmtQcm9wTmFtZXMgPSBuZXcgU2V0KFtcbiAgICBcImhyZWZcIixcbiAgICBcInRhcmdldFwiLFxuICAgIFwicmVsXCIsXG4gICAgXCJkb3dubG9hZFwiLFxuICAgIFwicGluZ1wiLFxuICAgIFwicmVmZXJyZXJQb2xpY3lcIlxuXSk7XG5jb25zdCAkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkcHJvcFJlID0gL14oZGF0YS0uKikkLztcbmZ1bmN0aW9uICQ2NTQ4NGQwMmRjYjdlYjNlJGV4cG9ydCQ0NTdjM2Q2NTE4ZGQ0YzZmKHByb3BzLCBvcHRzID0ge30pIHtcbiAgICBsZXQgeyBsYWJlbGFibGU6IGxhYmVsYWJsZSwgaXNMaW5rOiBpc0xpbmssIHByb3BOYW1lczogcHJvcE5hbWVzIH0gPSBvcHRzO1xuICAgIGxldCBmaWx0ZXJlZFByb3BzID0ge307XG4gICAgZm9yKGNvbnN0IHByb3AgaW4gcHJvcHMpaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcCkgJiYgKCQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRET01Qcm9wTmFtZXMuaGFzKHByb3ApIHx8IGxhYmVsYWJsZSAmJiAkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkbGFiZWxhYmxlUHJvcE5hbWVzLmhhcyhwcm9wKSB8fCBpc0xpbmsgJiYgJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJGxpbmtQcm9wTmFtZXMuaGFzKHByb3ApIHx8IChwcm9wTmFtZXMgPT09IG51bGwgfHwgcHJvcE5hbWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wTmFtZXMuaGFzKHByb3ApKSB8fCAkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkcHJvcFJlLnRlc3QocHJvcCkpKSBmaWx0ZXJlZFByb3BzW3Byb3BdID0gcHJvcHNbcHJvcF07XG4gICAgcmV0dXJuIGZpbHRlcmVkUHJvcHM7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICQ3MjE1YWZjNmRlNjA2ZDZiJGV4cG9ydCRkZTc5ZTJjNjk1ZTA1MmYzKGVsZW1lbnQpIHtcbiAgICBpZiAoJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbCgpKSBlbGVtZW50LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgIH0pO1xuICAgIGVsc2Uge1xuICAgICAgICBsZXQgc2Nyb2xsYWJsZUVsZW1lbnRzID0gJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJGdldFNjcm9sbGFibGVFbGVtZW50cyhlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgICAgICAkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkcmVzdG9yZVNjcm9sbFBvc2l0aW9uKHNjcm9sbGFibGVFbGVtZW50cyk7XG4gICAgfVxufVxubGV0ICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGxDYWNoZWQgPSBudWxsO1xuZnVuY3Rpb24gJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbCgpIHtcbiAgICBpZiAoJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbENhY2hlZCA9PSBudWxsKSB7XG4gICAgICAgICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGxDYWNoZWQgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBmb2N1c0VsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZm9jdXNFbGVtLmZvY3VzKHtcbiAgICAgICAgICAgICAgICBnZXQgcHJldmVudFNjcm9sbCAoKSB7XG4gICAgICAgICAgICAgICAgICAgICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGxDYWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZ25vcmVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbENhY2hlZDtcbn1cbmZ1bmN0aW9uICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRnZXRTY3JvbGxhYmxlRWxlbWVudHMoZWxlbWVudCkge1xuICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgdmFyIHNjcm9sbGFibGVFbGVtZW50cyA9IFtdO1xuICAgIHZhciByb290U2Nyb2xsaW5nRWxlbWVudCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHdoaWxlKHBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHBhcmVudCAhPT0gcm9vdFNjcm9sbGluZ0VsZW1lbnQpe1xuICAgICAgICBpZiAocGFyZW50Lm9mZnNldEhlaWdodCA8IHBhcmVudC5zY3JvbGxIZWlnaHQgfHwgcGFyZW50Lm9mZnNldFdpZHRoIDwgcGFyZW50LnNjcm9sbFdpZHRoKSBzY3JvbGxhYmxlRWxlbWVudHMucHVzaCh7XG4gICAgICAgICAgICBlbGVtZW50OiBwYXJlbnQsXG4gICAgICAgICAgICBzY3JvbGxUb3A6IHBhcmVudC5zY3JvbGxUb3AsXG4gICAgICAgICAgICBzY3JvbGxMZWZ0OiBwYXJlbnQuc2Nyb2xsTGVmdFxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmIChyb290U2Nyb2xsaW5nRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSBzY3JvbGxhYmxlRWxlbWVudHMucHVzaCh7XG4gICAgICAgIGVsZW1lbnQ6IHJvb3RTY3JvbGxpbmdFbGVtZW50LFxuICAgICAgICBzY3JvbGxUb3A6IHJvb3RTY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCxcbiAgICAgICAgc2Nyb2xsTGVmdDogcm9vdFNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdFxuICAgIH0pO1xuICAgIHJldHVybiBzY3JvbGxhYmxlRWxlbWVudHM7XG59XG5mdW5jdGlvbiAkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkcmVzdG9yZVNjcm9sbFBvc2l0aW9uKHNjcm9sbGFibGVFbGVtZW50cykge1xuICAgIGZvciAobGV0IHsgZWxlbWVudDogZWxlbWVudCwgc2Nyb2xsVG9wOiBzY3JvbGxUb3AsIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQgfSBvZiBzY3JvbGxhYmxlRWxlbWVudHMpe1xuICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICRhYjcxZGFkYjAzYTZmYjJlJGV4cG9ydCQ2MjJjZWE0NDVhMWM1YjdkKGVsZW1lbnQsIHJldmVyc2UsIG9yaWVudGF0aW9uID0gXCJob3Jpem9udGFsXCIpIHtcbiAgICBsZXQgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKHJldmVyc2UpIHJldHVybiBvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyByZWN0LnJpZ2h0IDogcmVjdC5ib3R0b207XG4gICAgcmV0dXJuIG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IHJlY3QubGVmdCA6IHJlY3QudG9wO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RVc2VyQWdlbnQocmUpIHtcbiAgICB2YXIgX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB3aW5kb3cubmF2aWdhdG9yID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKChfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhID0gd2luZG93Lm5hdmlnYXRvcltcInVzZXJBZ2VudERhdGFcIl0pID09PSBudWxsIHx8IF93aW5kb3dfbmF2aWdhdG9yX3VzZXJBZ2VudERhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3dfbmF2aWdhdG9yX3VzZXJBZ2VudERhdGEuYnJhbmRzLnNvbWUoKGJyYW5kKT0+cmUudGVzdChicmFuZC5icmFuZCkpKSB8fCByZS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0UGxhdGZvcm0ocmUpIHtcbiAgICB2YXIgX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YTtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubmF2aWdhdG9yICE9IG51bGwgPyByZS50ZXN0KCgoX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YSA9IHdpbmRvdy5uYXZpZ2F0b3JbXCJ1c2VyQWdlbnREYXRhXCJdKSA9PT0gbnVsbCB8fCBfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhLnBsYXRmb3JtKSB8fCB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTAoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0UGxhdGZvcm0oL15NYWMvaSk7XG59XG5mdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkMTg2YzY5NjRjYTE3ZDk5KCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFBsYXRmb3JtKC9eaVBob25lL2kpO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDdiZWYwNDljZTkyZTQyMjQoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0UGxhdGZvcm0oL15pUGFkL2kpIHx8IC8vIGlQYWRPUyAxMyBsaWVzIGFuZCBzYXlzIGl0J3MgYSBNYWMsIGJ1dCB3ZSBjYW4gZGlzdGluZ3Vpc2ggYnkgZGV0ZWN0aW5nIHRvdWNoIHN1cHBvcnQuXG4gICAgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTAoKSAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGZlZGIzNjljYjcwMjA3ZjEoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQxODZjNjk2NGNhMTdkOTkoKSB8fCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkN2JlZjA0OWNlOTJlNDIyNCgpO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGUxODY1YzNiZWRjZDgyMmIoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ5YWMxMDBlNDA2MTNlYTEwKCkgfHwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGZlZGIzNjljYjcwMjA3ZjEoKTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3ODU1MTA0MzU4MmE2YTk4KCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFVzZXJBZ2VudCgvQXBwbGVXZWJLaXQvaSkgJiYgISRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ2NDQ2YTE4NmQwOWUzNzllKCk7XG59XG5mdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkNjQ0NmExODZkMDllMzc5ZSgpIHtcbiAgICByZXR1cm4gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RVc2VyQWdlbnQoL0Nocm9tZS9pKTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRhMTFiMDA1OTkwMGNlZWM4KCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFVzZXJBZ2VudCgvQW5kcm9pZC9pKTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRiN2Q3ODk5M2I3NGY3NjZkKCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFVzZXJBZ2VudCgvRmlyZWZveC9pKTtcbn1cblxuXG5cblxuY29uc3QgJGVhOGRjYmNiOWVhMWI1NTYkdmFyJFJvdXRlckNvbnRleHQgPSAvKiNfX1BVUkVfXyovICgwLCAkMTJ1R3AkY3JlYXRlQ29udGV4dCkoe1xuICAgIGlzTmF0aXZlOiB0cnVlLFxuICAgIG9wZW46ICRlYThkY2JjYjllYTFiNTU2JHZhciRvcGVuU3ludGhldGljTGlua1xufSk7XG5mdW5jdGlvbiAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkMzIzZTRmYzJmYTQ3NTNmYihwcm9wcykge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgbmF2aWdhdGU6IG5hdmlnYXRlIH0gPSBwcm9wcztcbiAgICBsZXQgY3R4ID0gKDAsICQxMnVHcCR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIGlzTmF0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG9wZW46ICh0YXJnZXQsIG1vZGlmaWVycyk9PntcbiAgICAgICAgICAgICAgICAkZWE4ZGNiY2I5ZWExYjU1NiR2YXIkZ2V0U3ludGhldGljTGluayh0YXJnZXQsIChsaW5rKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JGVmYThjOTA5OWU1MzAyMzUobGluaywgbW9kaWZpZXJzKSkgbmF2aWdhdGUobGluay5wYXRobmFtZSArIGxpbmsuc2VhcmNoICsgbGluay5oYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOTUxODVkNjk5ZTA1ZDRkNyhsaW5rLCBtb2RpZmllcnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgW1xuICAgICAgICBuYXZpZ2F0ZVxuICAgIF0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkMTJ1R3AkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoJGVhOGRjYmNiOWVhMWI1NTYkdmFyJFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGN0eFxuICAgIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5YTMwMmE0NWY2NWQwNTcyKCkge1xuICAgIHJldHVybiAoMCwgJDEydUdwJHVzZUNvbnRleHQpKCRlYThkY2JjYjllYTFiNTU2JHZhciRSb3V0ZXJDb250ZXh0KTtcbn1cbmZ1bmN0aW9uICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCRlZmE4YzkwOTllNTMwMjM1KGxpbmssIG1vZGlmaWVycykge1xuICAgIC8vIFVzZSBnZXRBdHRyaWJ1dGUgaGVyZSBpbnN0ZWFkIG9mIGxpbmsudGFyZ2V0LiBGaXJlZm94IHdpbGwgZGVmYXVsdCBsaW5rLnRhcmdldCB0byBcIl9wYXJlbnRcIiB3aGVuIGluc2lkZSBhbiBpZnJhbWUuXG4gICAgbGV0IHRhcmdldCA9IGxpbmsuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpO1xuICAgIHJldHVybiAoIXRhcmdldCB8fCB0YXJnZXQgPT09IFwiX3NlbGZcIikgJiYgbGluay5vcmlnaW4gPT09IGxvY2F0aW9uLm9yaWdpbiAmJiAhbGluay5oYXNBdHRyaWJ1dGUoXCJkb3dubG9hZFwiKSAmJiAhbW9kaWZpZXJzLm1ldGFLZXkgJiYgLy8gb3BlbiBpbiBuZXcgdGFiIChtYWMpXG4gICAgIW1vZGlmaWVycy5jdHJsS2V5ICYmIC8vIG9wZW4gaW4gbmV3IHRhYiAod2luZG93cylcbiAgICAhbW9kaWZpZXJzLmFsdEtleSAmJiAvLyBkb3dubG9hZFxuICAgICFtb2RpZmllcnMuc2hpZnRLZXk7XG59XG5mdW5jdGlvbiAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOTUxODVkNjk5ZTA1ZDRkNyh0YXJnZXQsIG1vZGlmaWVycywgc2V0T3BlbmluZyA9IHRydWUpIHtcbiAgICB2YXIgX3dpbmRvd19ldmVudF90eXBlLCBfd2luZG93X2V2ZW50O1xuICAgIGxldCB7IG1ldGFLZXk6IG1ldGFLZXksIGN0cmxLZXk6IGN0cmxLZXksIGFsdEtleTogYWx0S2V5LCBzaGlmdEtleTogc2hpZnRLZXkgfSA9IG1vZGlmaWVycztcbiAgICAvLyBGaXJlZm94IGRvZXMgbm90IHJlY29nbml6ZSBrZXlib2FyZCBldmVudHMgYXMgYSB1c2VyIGFjdGlvbiBieSBkZWZhdWx0LCBhbmQgdGhlIHBvcHVwIGJsb2NrZXJcbiAgICAvLyB3aWxsIHByZXZlbnQgbGlua3Mgd2l0aCB0YXJnZXQ9XCJfYmxhbmtcIiBmcm9tIG9wZW5pbmcuIEhvd2V2ZXIsIGl0IGRvZXMgYWxsb3cgdGhlIGV2ZW50IGlmIHRoZVxuICAgIC8vIENvbW1hbmQvQ29udHJvbCBrZXkgaXMgaGVsZCwgd2hpY2ggb3BlbnMgdGhlIGxpbmsgaW4gYSBiYWNrZ3JvdW5kIHRhYi4gVGhpcyBzZWVtcyBsaWtlIHRoZSBiZXN0IHdlIGNhbiBkby5cbiAgICAvLyBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjU3ODcwIGFuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NDY2NDAuXG4gICAgaWYgKCgwLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYjdkNzg5OTNiNzRmNzY2ZCkoKSAmJiAoKF93aW5kb3dfZXZlbnQgPSB3aW5kb3cuZXZlbnQpID09PSBudWxsIHx8IF93aW5kb3dfZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfd2luZG93X2V2ZW50X3R5cGUgPSBfd2luZG93X2V2ZW50LnR5cGUpID09PSBudWxsIHx8IF93aW5kb3dfZXZlbnRfdHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvd19ldmVudF90eXBlLnN0YXJ0c1dpdGgoXCJrZXlcIikpICYmIHRhcmdldC50YXJnZXQgPT09IFwiX2JsYW5rXCIpIHtcbiAgICAgICAgaWYgKCgwLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkOWFjMTAwZTQwNjEzZWExMCkoKSkgbWV0YUtleSA9IHRydWU7XG4gICAgICAgIGVsc2UgY3RybEtleSA9IHRydWU7XG4gICAgfVxuICAgIC8vIFdlYktpdCBkb2VzIG5vdCBzdXBwb3J0IGZpcmluZyBjbGljayBldmVudHMgd2l0aCBtb2RpZmllciBrZXlzLCBidXQgZG9lcyBzdXBwb3J0IGtleWJvYXJkIGV2ZW50cy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vV2ViS2l0L1dlYktpdC9ibG9iL2MwM2QwYWM2ZTZkYjE3OGY5MDkyM2EwYTYzMDgwYjVjYTIxMGQyNWYvU291cmNlL1dlYkNvcmUvaHRtbC9IVE1MQW5jaG9yRWxlbWVudC5jcHAjTDE4NFxuICAgIGxldCBldmVudCA9ICgwLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkNzg1NTEwNDM1ODJhNmE5OCkoKSAmJiAoMCwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTApKCkgJiYgISgwLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkN2JlZjA0OWNlOTJlNDIyNCkoKSAmJiB0cnVlID8gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXlkb3duXCIsIHtcbiAgICAgICAga2V5SWRlbnRpZmllcjogXCJFbnRlclwiLFxuICAgICAgICBtZXRhS2V5OiBtZXRhS2V5LFxuICAgICAgICBjdHJsS2V5OiBjdHJsS2V5LFxuICAgICAgICBhbHRLZXk6IGFsdEtleSxcbiAgICAgICAgc2hpZnRLZXk6IHNoaWZ0S2V5XG4gICAgfSkgOiBuZXcgTW91c2VFdmVudChcImNsaWNrXCIsIHtcbiAgICAgICAgbWV0YUtleTogbWV0YUtleSxcbiAgICAgICAgY3RybEtleTogY3RybEtleSxcbiAgICAgICAgYWx0S2V5OiBhbHRLZXksXG4gICAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5NTE4NWQ2OTllMDVkNGQ3LmlzT3BlbmluZyA9IHNldE9wZW5pbmc7XG4gICAgKDAsICQ3MjE1YWZjNmRlNjA2ZDZiJGV4cG9ydCRkZTc5ZTJjNjk1ZTA1MmYzKSh0YXJnZXQpO1xuICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOTUxODVkNjk5ZTA1ZDRkNy5pc09wZW5pbmcgPSBmYWxzZTtcbn1cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXJjZWwtYnVuZGxlci9wYXJjZWwvaXNzdWVzLzg3MjRcbiRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5NTE4NWQ2OTllMDVkNGQ3LmlzT3BlbmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gJGVhOGRjYmNiOWVhMWI1NTYkdmFyJGdldFN5bnRoZXRpY0xpbmsodGFyZ2V0LCBvcGVuKSB7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50KSBvcGVuKHRhcmdldCk7XG4gICAgZWxzZSBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRhdGEtaHJlZlwiKSkge1xuICAgICAgICBsZXQgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICBsaW5rLmhyZWYgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1ocmVmXCIpO1xuICAgICAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRhdGEtdGFyZ2V0XCIpKSBsaW5rLnRhcmdldCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRhcmdldFwiKTtcbiAgICAgICAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJlbFwiKSkgbGluay5yZWwgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZWxcIik7XG4gICAgICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKFwiZGF0YS1kb3dubG9hZFwiKSkgbGluay5kb3dubG9hZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRvd25sb2FkXCIpO1xuICAgICAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRhdGEtcGluZ1wiKSkgbGluay5waW5nID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtcGluZ1wiKTtcbiAgICAgICAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJlZmVycmVyLXBvbGljeVwiKSkgbGluay5yZWZlcnJlclBvbGljeSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlZmVycmVyLXBvbGljeVwiKTtcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGxpbmspO1xuICAgICAgICBvcGVuKGxpbmspO1xuICAgICAgICB0YXJnZXQucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgfVxufVxuZnVuY3Rpb24gJGVhOGRjYmNiOWVhMWI1NTYkdmFyJG9wZW5TeW50aGV0aWNMaW5rKHRhcmdldCwgbW9kaWZpZXJzKSB7XG4gICAgJGVhOGRjYmNiOWVhMWI1NTYkdmFyJGdldFN5bnRoZXRpY0xpbmsodGFyZ2V0LCAobGluayk9PiRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5NTE4NWQ2OTllMDVkNGQ3KGxpbmssIG1vZGlmaWVycykpO1xufVxuZnVuY3Rpb24gJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDUxNDM3ZDUwMzM3M2QyMjMocHJvcHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBcImRhdGEtaHJlZlwiOiBwcm9wcy5ocmVmLFxuICAgICAgICBcImRhdGEtdGFyZ2V0XCI6IHByb3BzLnRhcmdldCxcbiAgICAgICAgXCJkYXRhLXJlbFwiOiBwcm9wcy5yZWwsXG4gICAgICAgIFwiZGF0YS1kb3dubG9hZFwiOiBwcm9wcy5kb3dubG9hZCxcbiAgICAgICAgXCJkYXRhLXBpbmdcIjogcHJvcHMucGluZyxcbiAgICAgICAgXCJkYXRhLXJlZmVycmVyLXBvbGljeVwiOiBwcm9wcy5yZWZlcnJlclBvbGljeVxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFdlIHN0b3JlIGEgZ2xvYmFsIGxpc3Qgb2YgZWxlbWVudHMgdGhhdCBhcmUgY3VycmVudGx5IHRyYW5zaXRpb25pbmcsXG4vLyBtYXBwZWQgdG8gYSBzZXQgb2YgQ1NTIHByb3BlcnRpZXMgdGhhdCBhcmUgdHJhbnNpdGlvbmluZyBmb3IgdGhhdCBlbGVtZW50LlxuLy8gVGhpcyBpcyBuZWNlc3NhcnkgcmF0aGVyIHRoYW4gYSBzaW1wbGUgY291bnQgb2YgdHJhbnNpdGlvbnMgYmVjYXVzZSBvZiBicm93c2VyXG4vLyBidWdzLCBlLmcuIENocm9tZSBzb21ldGltZXMgZmlyZXMgYm90aCB0cmFuc2l0aW9uZW5kIGFuZCB0cmFuc2l0aW9uY2FuY2VsIHJhdGhlclxuLy8gdGhhbiBvbmUgb3IgdGhlIG90aGVyLiBTbyB3ZSBuZWVkIHRvIHRyYWNrIHdoYXQncyBhY3R1YWxseSB0cmFuc2l0aW9uaW5nIHNvIHRoYXRcbi8vIHdlIGNhbiBpZ25vcmUgdGhlc2UgZHVwbGljYXRlIGV2ZW50cy5cbmxldCAkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbnNCeUVsZW1lbnQgPSBuZXcgTWFwKCk7XG4vLyBBIGxpc3Qgb2YgY2FsbGJhY2tzIHRvIGNhbGwgb25jZSB0aGVyZSBhcmUgbm8gdHJhbnNpdGlvbmluZyBlbGVtZW50cy5cbmxldCAkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbkNhbGxiYWNrcyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uICRiYmVkOGI0MWY4NTdiY2MwJHZhciRzZXR1cEdsb2JhbEV2ZW50cygpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuICAgIGxldCBvblRyYW5zaXRpb25TdGFydCA9IChlKT0+e1xuICAgICAgICAvLyBBZGQgdGhlIHRyYW5zaXRpb25pbmcgcHJvcGVydHkgdG8gdGhlIGxpc3QgZm9yIHRoaXMgZWxlbWVudC5cbiAgICAgICAgbGV0IHRyYW5zaXRpb25zID0gJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25zQnlFbGVtZW50LmdldChlLnRhcmdldCk7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25zQnlFbGVtZW50LnNldChlLnRhcmdldCwgdHJhbnNpdGlvbnMpO1xuICAgICAgICAgICAgLy8gVGhlIHRyYW5zaXRpb25jYW5jZWwgZXZlbnQgbXVzdCBiZSByZWdpc3RlcmVkIG9uIHRoZSBlbGVtZW50IGl0c2VsZiwgcmF0aGVyIHRoYW4gYXMgYSBnbG9iYWxcbiAgICAgICAgICAgIC8vIGV2ZW50LiBUaGlzIGVuYWJsZXMgdXMgdG8gaGFuZGxlIHdoZW4gdGhlIG5vZGUgaXMgZGVsZXRlZCBmcm9tIHRoZSBkb2N1bWVudCB3aGlsZSBpdCBpcyB0cmFuc2l0aW9uaW5nLlxuICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlLCB0aGUgY2FuY2VsIGV2ZW50IHdvdWxkIGhhdmUgbm93aGVyZSB0byBidWJibGUgdG8gc28gd2UgbmVlZCB0byBoYW5kbGUgaXQgZGlyZWN0bHkuXG4gICAgICAgICAgICBlLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmNhbmNlbFwiLCBvblRyYW5zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zaXRpb25zLmFkZChlLnByb3BlcnR5TmFtZSk7XG4gICAgfTtcbiAgICBsZXQgb25UcmFuc2l0aW9uRW5kID0gKGUpPT57XG4gICAgICAgIC8vIFJlbW92ZSBwcm9wZXJ0eSBmcm9tIGxpc3Qgb2YgdHJhbnNpdGlvbmluZyBwcm9wZXJ0aWVzLlxuICAgICAgICBsZXQgcHJvcGVydGllcyA9ICRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uc0J5RWxlbWVudC5nZXQoZS50YXJnZXQpO1xuICAgICAgICBpZiAoIXByb3BlcnRpZXMpIHJldHVybjtcbiAgICAgICAgcHJvcGVydGllcy5kZWxldGUoZS5wcm9wZXJ0eU5hbWUpO1xuICAgICAgICAvLyBJZiBlbXB0eSwgcmVtb3ZlIHRyYW5zaXRpb25jYW5jZWwgZXZlbnQsIGFuZCByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgbGlzdCBvZiB0cmFuc2l0aW9uaW5nIGVsZW1lbnRzLlxuICAgICAgICBpZiAocHJvcGVydGllcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBlLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmNhbmNlbFwiLCBvblRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgICAgJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25zQnlFbGVtZW50LmRlbGV0ZShlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gdHJhbnNpdGlvbmluZyBlbGVtZW50cywgY2FsbCBhbGwgb2YgdGhlIHF1ZXVlZCBjYWxsYmFja3MuXG4gICAgICAgIGlmICgkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbnNCeUVsZW1lbnQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgY2Igb2YgJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25DYWxsYmFja3MpY2IoKTtcbiAgICAgICAgICAgICRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uQ2FsbGJhY2tzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25ydW5cIiwgb25UcmFuc2l0aW9uU3RhcnQpO1xuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgb25UcmFuc2l0aW9uRW5kKTtcbn1cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIpICRiYmVkOGI0MWY4NTdiY2MwJHZhciRzZXR1cEdsb2JhbEV2ZW50cygpO1xuICAgIGVsc2UgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHNldHVwR2xvYmFsRXZlbnRzKTtcbn1cbmZ1bmN0aW9uICRiYmVkOGI0MWY4NTdiY2MwJGV4cG9ydCQyNDQ5MDMxNmY3NjRjNDMwKGZuKSB7XG4gICAgLy8gV2FpdCBvbmUgZnJhbWUgdG8gc2VlIGlmIGFuIGFuaW1hdGlvbiBzdGFydHMsIGUuZy4gYSB0cmFuc2l0aW9uIG9uIG1vdW50LlxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAvLyBJZiBubyB0cmFuc2l0aW9ucyBhcmUgcnVubmluZywgY2FsbCB0aGUgZnVuY3Rpb24gaW1tZWRpYXRlbHkuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgYWRkIGl0IHRvIGEgbGlzdCBvZiBjYWxsYmFja3MgdG8gcnVuIGF0IHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgaWYgKCRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uc0J5RWxlbWVudC5zaXplID09PSAwKSBmbigpO1xuICAgICAgICBlbHNlICRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uQ2FsbGJhY2tzLmFkZChmbik7XG4gICAgfSk7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qIGVzbGludC1kaXNhYmxlIHJ1bGVzZGlyL3B1cmUtcmVuZGVyICovIFxuXG4vLyBLZWVwIHRyYWNrIG9mIGVsZW1lbnRzIHRoYXQgd2UgYXJlIGN1cnJlbnRseSBoYW5kbGluZyBkcmFnZ2luZyBmb3IgdmlhIHVzZURyYWcxRC5cbi8vIElmIHRoZXJlJ3MgYW4gYW5jZXN0b3IgYW5kIGEgZGVzY2VuZGFudCBib3RoIHVzaW5nIHVzZURyYWcxRCgpLCBhbmQgdGhlIHVzZXIgc3RhcnRzXG4vLyBkcmFnZ2luZyB0aGUgZGVzY2VuZGFudCwgd2UgZG9uJ3Qgd2FudCB1c2VEcmFnMUQgZXZlbnRzIHRvIGZpcmUgZm9yIHRoZSBhbmNlc3Rvci5cbmNvbnN0ICQ5Y2MwOWRmOWZkNzY3NmJlJHZhciRkcmFnZ2luZ0VsZW1lbnRzID0gW107XG5mdW5jdGlvbiAkOWNjMDlkZjlmZDc2NzZiZSRleHBvcnQkN2JiZWQ3NWZlYmEzOTcwNihwcm9wcykge1xuICAgIGNvbnNvbGUud2FybihcInVzZURyYWcxRCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGB1c2VNb3ZlYCBpbnN0ZWFkIGh0dHBzOi8vcmVhY3Qtc3BlY3RydW0uYWRvYmUuY29tL3JlYWN0LWFyaWEvdXNlTW92ZS5odG1sXCIpO1xuICAgIGxldCB7IGNvbnRhaW5lclJlZjogY29udGFpbmVyUmVmLCByZXZlcnNlOiByZXZlcnNlLCBvcmllbnRhdGlvbjogb3JpZW50YXRpb24sIG9uSG92ZXI6IG9uSG92ZXIsIG9uRHJhZzogb25EcmFnLCBvblBvc2l0aW9uQ2hhbmdlOiBvblBvc2l0aW9uQ2hhbmdlLCBvbkluY3JlbWVudDogb25JbmNyZW1lbnQsIG9uRGVjcmVtZW50OiBvbkRlY3JlbWVudCwgb25JbmNyZW1lbnRUb01heDogb25JbmNyZW1lbnRUb01heCwgb25EZWNyZW1lbnRUb01pbjogb25EZWNyZW1lbnRUb01pbiwgb25Db2xsYXBzZVRvZ2dsZTogb25Db2xsYXBzZVRvZ2dsZSB9ID0gcHJvcHM7XG4gICAgbGV0IGdldFBvc2l0aW9uID0gKGUpPT5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBlLmNsaWVudFggOiBlLmNsaWVudFk7XG4gICAgbGV0IGdldE5leHRPZmZzZXQgPSAoZSk9PntcbiAgICAgICAgbGV0IGNvbnRhaW5lck9mZnNldCA9ICgwLCAkYWI3MWRhZGIwM2E2ZmIyZSRleHBvcnQkNjIyY2VhNDQ1YTFjNWI3ZCkoY29udGFpbmVyUmVmLmN1cnJlbnQsIHJldmVyc2UsIG9yaWVudGF0aW9uKTtcbiAgICAgICAgbGV0IG1vdXNlT2Zmc2V0ID0gZ2V0UG9zaXRpb24oZSk7XG4gICAgICAgIGxldCBuZXh0T2Zmc2V0ID0gcmV2ZXJzZSA/IGNvbnRhaW5lck9mZnNldCAtIG1vdXNlT2Zmc2V0IDogbW91c2VPZmZzZXQgLSBjb250YWluZXJPZmZzZXQ7XG4gICAgICAgIHJldHVybiBuZXh0T2Zmc2V0O1xuICAgIH07XG4gICAgbGV0IGRyYWdnaW5nID0gKDAsICQxMnVHcCR1c2VSZWYpKGZhbHNlKTtcbiAgICBsZXQgcHJldlBvc2l0aW9uID0gKDAsICQxMnVHcCR1c2VSZWYpKDApO1xuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgaGFuZGxlcnMgaW4gYSByZWYgc28gdGhhdCB0aGUgZXZlbnRzIGNhbiBhY2Nlc3MgdGhlbS5cbiAgICBsZXQgaGFuZGxlcnMgPSAoMCwgJDEydUdwJHVzZVJlZikoe1xuICAgICAgICBvblBvc2l0aW9uQ2hhbmdlOiBvblBvc2l0aW9uQ2hhbmdlLFxuICAgICAgICBvbkRyYWc6IG9uRHJhZ1xuICAgIH0pO1xuICAgIGhhbmRsZXJzLmN1cnJlbnQub25EcmFnID0gb25EcmFnO1xuICAgIGhhbmRsZXJzLmN1cnJlbnQub25Qb3NpdGlvbkNoYW5nZSA9IG9uUG9zaXRpb25DaGFuZ2U7XG4gICAgbGV0IG9uTW91c2VEcmFnZ2VkID0gKGUpPT57XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IG5leHRPZmZzZXQgPSBnZXROZXh0T2Zmc2V0KGUpO1xuICAgICAgICBpZiAoIWRyYWdnaW5nLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXJzLmN1cnJlbnQub25EcmFnKSBoYW5kbGVycy5jdXJyZW50Lm9uRHJhZyh0cnVlKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVycy5jdXJyZW50Lm9uUG9zaXRpb25DaGFuZ2UpIGhhbmRsZXJzLmN1cnJlbnQub25Qb3NpdGlvbkNoYW5nZShuZXh0T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlBvc2l0aW9uLmN1cnJlbnQgPT09IG5leHRPZmZzZXQpIHJldHVybjtcbiAgICAgICAgcHJldlBvc2l0aW9uLmN1cnJlbnQgPSBuZXh0T2Zmc2V0O1xuICAgICAgICBpZiAob25Qb3NpdGlvbkNoYW5nZSkgb25Qb3NpdGlvbkNoYW5nZShuZXh0T2Zmc2V0KTtcbiAgICB9O1xuICAgIGxldCBvbk1vdXNlVXAgPSAoZSk9PntcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIGRyYWdnaW5nLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IG5leHRPZmZzZXQgPSBnZXROZXh0T2Zmc2V0KGUpO1xuICAgICAgICBpZiAoaGFuZGxlcnMuY3VycmVudC5vbkRyYWcpIGhhbmRsZXJzLmN1cnJlbnQub25EcmFnKGZhbHNlKTtcbiAgICAgICAgaWYgKGhhbmRsZXJzLmN1cnJlbnQub25Qb3NpdGlvbkNoYW5nZSkgaGFuZGxlcnMuY3VycmVudC5vblBvc2l0aW9uQ2hhbmdlKG5leHRPZmZzZXQpO1xuICAgICAgICAkOWNjMDlkZjlmZDc2NzZiZSR2YXIkZHJhZ2dpbmdFbGVtZW50cy5zcGxpY2UoJDljYzA5ZGY5ZmQ3Njc2YmUkdmFyJGRyYWdnaW5nRWxlbWVudHMuaW5kZXhPZih0YXJnZXQpLCAxKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uTW91c2VVcCwgZmFsc2UpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbk1vdXNlRHJhZ2dlZCwgZmFsc2UpO1xuICAgIH07XG4gICAgbGV0IG9uTW91c2VEb3duID0gKGUpPT57XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcbiAgICAgICAgLy8gSWYgd2UncmUgYWxyZWFkeSBoYW5kbGluZyBkcmFnZ2luZyBvbiBhIGRlc2NlbmRhbnQgd2l0aCB1c2VEcmFnMUQsIHRoZW5cbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBoYW5kbGUgdGhlIGRyYWcgbW90aW9uIG9uIHRoaXMgdGFyZ2V0IGFzIHdlbGwuXG4gICAgICAgIGlmICgkOWNjMDlkZjlmZDc2NzZiZSR2YXIkZHJhZ2dpbmdFbGVtZW50cy5zb21lKChlbHQpPT50YXJnZXQuY29udGFpbnMoZWx0KSkpIHJldHVybjtcbiAgICAgICAgJDljYzA5ZGY5ZmQ3Njc2YmUkdmFyJGRyYWdnaW5nRWxlbWVudHMucHVzaCh0YXJnZXQpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbk1vdXNlRHJhZ2dlZCwgZmFsc2UpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgfTtcbiAgICBsZXQgb25Nb3VzZUVudGVyID0gKCk9PntcbiAgICAgICAgaWYgKG9uSG92ZXIpIG9uSG92ZXIodHJ1ZSk7XG4gICAgfTtcbiAgICBsZXQgb25Nb3VzZU91dCA9ICgpPT57XG4gICAgICAgIGlmIChvbkhvdmVyKSBvbkhvdmVyKGZhbHNlKTtcbiAgICB9O1xuICAgIGxldCBvbktleURvd24gPSAoZSk9PntcbiAgICAgICAgc3dpdGNoKGUua2V5KXtcbiAgICAgICAgICAgIGNhc2UgXCJMZWZ0XCI6XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6XG4gICAgICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkRlY3JlbWVudCAmJiAhcmV2ZXJzZSkgb25EZWNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob25JbmNyZW1lbnQgJiYgcmV2ZXJzZSkgb25JbmNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVXBcIjpcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25EZWNyZW1lbnQgJiYgIXJldmVyc2UpIG9uRGVjcmVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9uSW5jcmVtZW50ICYmIHJldmVyc2UpIG9uSW5jcmVtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlJpZ2h0XCI6XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOlxuICAgICAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25JbmNyZW1lbnQgJiYgIXJldmVyc2UpIG9uSW5jcmVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9uRGVjcmVtZW50ICYmIHJldmVyc2UpIG9uRGVjcmVtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkRvd25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkluY3JlbWVudCAmJiAhcmV2ZXJzZSkgb25JbmNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob25EZWNyZW1lbnQgJiYgcmV2ZXJzZSkgb25EZWNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiSG9tZVwiOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAob25EZWNyZW1lbnRUb01pbikgb25EZWNyZW1lbnRUb01pbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkVuZFwiOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAob25JbmNyZW1lbnRUb01heCkgb25JbmNyZW1lbnRUb01heCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkVudGVyXCI6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChvbkNvbGxhcHNlVG9nZ2xlKSBvbkNvbGxhcHNlVG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIG9uTW91c2VEb3duOiBvbk1vdXNlRG93bixcbiAgICAgICAgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXIsXG4gICAgICAgIG9uTW91c2VPdXQ6IG9uTW91c2VPdXQsXG4gICAgICAgIG9uS2V5RG93bjogb25LZXlEb3duXG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkMDNkZWIyM2ZmMTQ5MjBjNCRleHBvcnQkNGVhZjA0ZTU0YWE4ZWVkNigpIHtcbiAgICBsZXQgZ2xvYmFsTGlzdGVuZXJzID0gKDAsICQxMnVHcCR1c2VSZWYpKG5ldyBNYXAoKSk7XG4gICAgbGV0IGFkZEdsb2JhbExpc3RlbmVyID0gKDAsICQxMnVHcCR1c2VDYWxsYmFjaykoKGV2ZW50VGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk9PntcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHJlbW92ZSB0aGUgbGlzdGVuZXIgYWZ0ZXIgaXQgaXMgY2FsbGVkIHdpdGggdGhlIGBvbmNlYCBvcHRpb24uXG4gICAgICAgIGxldCBmbiA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25jZSkgPyAoLi4uYXJncyk9PntcbiAgICAgICAgICAgIGdsb2JhbExpc3RlbmVycy5jdXJyZW50LmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgICAgICBsaXN0ZW5lciguLi5hcmdzKTtcbiAgICAgICAgfSA6IGxpc3RlbmVyO1xuICAgICAgICBnbG9iYWxMaXN0ZW5lcnMuY3VycmVudC5zZXQobGlzdGVuZXIsIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBldmVudFRhcmdldDogZXZlbnRUYXJnZXQsXG4gICAgICAgICAgICBmbjogZm4sXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICB9LCBbXSk7XG4gICAgbGV0IHJlbW92ZUdsb2JhbExpc3RlbmVyID0gKDAsICQxMnVHcCR1c2VDYWxsYmFjaykoKGV2ZW50VGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk9PntcbiAgICAgICAgdmFyIF9nbG9iYWxMaXN0ZW5lcnNfY3VycmVudF9nZXQ7XG4gICAgICAgIGxldCBmbiA9ICgoX2dsb2JhbExpc3RlbmVyc19jdXJyZW50X2dldCA9IGdsb2JhbExpc3RlbmVycy5jdXJyZW50LmdldChsaXN0ZW5lcikpID09PSBudWxsIHx8IF9nbG9iYWxMaXN0ZW5lcnNfY3VycmVudF9nZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nbG9iYWxMaXN0ZW5lcnNfY3VycmVudF9nZXQuZm4pIHx8IGxpc3RlbmVyO1xuICAgICAgICBldmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRpb25zKTtcbiAgICAgICAgZ2xvYmFsTGlzdGVuZXJzLmN1cnJlbnQuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9LCBbXSk7XG4gICAgbGV0IHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycyA9ICgwLCAkMTJ1R3AkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIGdsb2JhbExpc3RlbmVycy5jdXJyZW50LmZvckVhY2goKHZhbHVlLCBrZXkpPT57XG4gICAgICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcih2YWx1ZS5ldmVudFRhcmdldCwgdmFsdWUudHlwZSwga2V5LCB2YWx1ZS5vcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lclxuICAgIF0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJvdy1ib2R5LXN0eWxlXG4gICAgKDAsICQxMnVHcCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIHJldHVybiByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnM7XG4gICAgfSwgW1xuICAgICAgICByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnNcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcjogYWRkR2xvYmFsTGlzdGVuZXIsXG4gICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyOiByZW1vdmVHbG9iYWxMaXN0ZW5lcixcbiAgICAgICAgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzOiByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnNcbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQzMTNiOTg4NjFlZTVkZDZjJGV4cG9ydCRkNjg3NTEyMjE5NGM3YjQ0KHByb3BzLCBkZWZhdWx0TGFiZWwpIHtcbiAgICBsZXQgeyBpZDogaWQsIFwiYXJpYS1sYWJlbFwiOiBsYWJlbCwgXCJhcmlhLWxhYmVsbGVkYnlcIjogbGFiZWxsZWRCeSB9ID0gcHJvcHM7XG4gICAgLy8gSWYgdGhlcmUgaXMgYm90aCBhbiBhcmlhLWxhYmVsIGFuZCBhcmlhLWxhYmVsbGVkYnksXG4gICAgLy8gY29tYmluZSB0aGVtIGJ5IHBvaW50aW5nIHRvIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICBpZCA9ICgwLCAkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkZjY4MDg3N2EzNDcxMWUzNykoaWQpO1xuICAgIGlmIChsYWJlbGxlZEJ5ICYmIGxhYmVsKSB7XG4gICAgICAgIGxldCBpZHMgPSBuZXcgU2V0KFtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgLi4ubGFiZWxsZWRCeS50cmltKCkuc3BsaXQoL1xccysvKVxuICAgICAgICBdKTtcbiAgICAgICAgbGFiZWxsZWRCeSA9IFtcbiAgICAgICAgICAgIC4uLmlkc1xuICAgICAgICBdLmpvaW4oXCIgXCIpO1xuICAgIH0gZWxzZSBpZiAobGFiZWxsZWRCeSkgbGFiZWxsZWRCeSA9IGxhYmVsbGVkQnkudHJpbSgpLnNwbGl0KC9cXHMrLykuam9pbihcIiBcIik7XG4gICAgLy8gSWYgbm8gbGFiZWxzIGFyZSBwcm92aWRlZCwgdXNlIHRoZSBkZWZhdWx0XG4gICAgaWYgKCFsYWJlbCAmJiAhbGFiZWxsZWRCeSAmJiBkZWZhdWx0TGFiZWwpIGxhYmVsID0gZGVmYXVsdExhYmVsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IGxhYmVsLFxuICAgICAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBsYWJlbGxlZEJ5XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkZGY1NjE2NGRmZjU3ODVlMiRleHBvcnQkNDMzOGI1MzMxNWFiZjY2Nihmb3J3YXJkZWRSZWYpIHtcbiAgICBjb25zdCBvYmpSZWYgPSAoMCwgJDEydUdwJHVzZVJlZikoKTtcbiAgICByZXR1cm4gKDAsICQxMnVHcCR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIGdldCBjdXJyZW50ICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IGN1cnJlbnQgKHZhbHVlKXtcbiAgICAgICAgICAgICAgICBvYmpSZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9yd2FyZGVkUmVmID09PSBcImZ1bmN0aW9uXCIpIGZvcndhcmRlZFJlZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9yd2FyZGVkUmVmKSBmb3J3YXJkZWRSZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgW1xuICAgICAgICBmb3J3YXJkZWRSZWZcbiAgICBdKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkNGY1OGM1ZjcyYmNmNzlmNyRleHBvcnQkNDk2MzE1YTE2MDhkOTYwMihlZmZlY3QsIGRlcGVuZGVuY2llcykge1xuICAgIGNvbnN0IGlzSW5pdGlhbE1vdW50ID0gKDAsICQxMnVHcCR1c2VSZWYpKHRydWUpO1xuICAgIGNvbnN0IGxhc3REZXBzID0gKDAsICQxMnVHcCR1c2VSZWYpKG51bGwpO1xuICAgICgwLCAkMTJ1R3AkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpc0luaXRpYWxNb3VudC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpc0luaXRpYWxNb3VudC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgICgwLCAkMTJ1R3AkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoaXNJbml0aWFsTW91bnQuY3VycmVudCkgaXNJbml0aWFsTW91bnQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBlbHNlIGlmICghbGFzdERlcHMuY3VycmVudCB8fCBkZXBlbmRlbmNpZXMuc29tZSgoZGVwLCBpKT0+IU9iamVjdC5pcyhkZXAsIGxhc3REZXBzW2ldKSkpIGVmZmVjdCgpO1xuICAgICAgICBsYXN0RGVwcy5jdXJyZW50ID0gZGVwZW5kZW5jaWVzO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBkZXBlbmRlbmNpZXMpO1xufVxuXG5cblxuXG5mdW5jdGlvbiAkOWRhYWIwMmQ0NjE4MDlkYiR2YXIkaGFzUmVzaXplT2JzZXJ2ZXIoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiAkOWRhYWIwMmQ0NjE4MDlkYiRleHBvcnQkNjgzNDgwZjE5MWMwZTNlYShvcHRpb25zKSB7XG4gICAgY29uc3QgeyByZWY6IHJlZiwgb25SZXNpemU6IG9uUmVzaXplIH0gPSBvcHRpb25zO1xuICAgICgwLCAkMTJ1R3AkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgZWxlbWVudCA9IHJlZiA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHJldHVybjtcbiAgICAgICAgaWYgKCEkOWRhYWIwMmQ0NjE4MDlkYiR2YXIkaGFzUmVzaXplT2JzZXJ2ZXIoKSkge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25SZXNpemUsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG9uUmVzaXplLCBmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzaXplT2JzZXJ2ZXJJbnN0YW5jZSA9IG5ldyB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlbnRyaWVzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG9uUmVzaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVySW5zdGFuY2Uub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSByZXNpemVPYnNlcnZlckluc3RhbmNlLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIG9uUmVzaXplLFxuICAgICAgICByZWZcbiAgICBdKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkZTc4MDFiZTgyYjRiMmE1MyRleHBvcnQkNGRlYmRiMWEzZjBmYTc5ZShjb250ZXh0LCByZWYpIHtcbiAgICAoMCwgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMpKCgpPT57XG4gICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQucmVmICYmIHJlZikge1xuICAgICAgICAgICAgY29udGV4dC5yZWYuY3VycmVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCRjZmEyMjI1ZTg3OTM4NzgxKG5vZGUpIHtcbiAgICBpZiAoJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JDJiYjc0NzQwYzRlMTlkZWYobm9kZSkpIG5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgd2hpbGUobm9kZSAmJiAhJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JDJiYjc0NzQwYzRlMTlkZWYobm9kZSkpbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICByZXR1cm4gbm9kZSB8fCBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uICQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCQyYmI3NDc0MGM0ZTE5ZGVmKG5vZGUpIHtcbiAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICByZXR1cm4gLyhhdXRvfHNjcm9sbCkvLnRlc3Qoc3R5bGUub3ZlcmZsb3cgKyBzdHlsZS5vdmVyZmxvd1ggKyBzdHlsZS5vdmVyZmxvd1kpO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuLy8gQHRzLWlnbm9yZVxubGV0ICQ1ZGY2NGIzODA3ZGMxNWVlJHZhciR2aXN1YWxWaWV3cG9ydCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cudmlzdWFsVmlld3BvcnQ7XG5mdW5jdGlvbiAkNWRmNjRiMzgwN2RjMTVlZSRleHBvcnQkZDY5OTkwNWRkNTdjNzNjYSgpIHtcbiAgICBsZXQgaXNTU1IgPSAoMCwgJDEydUdwJHVzZUlzU1NSKSgpO1xuICAgIGxldCBbc2l6ZSwgc2V0U2l6ZV0gPSAoMCwgJDEydUdwJHVzZVN0YXRlKSgoKT0+aXNTU1IgPyB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9IDogJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJGdldFZpZXdwb3J0U2l6ZSgpKTtcbiAgICAoMCwgJDEydUdwJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgLy8gVXNlIHZpc3VhbFZpZXdwb3J0IGFwaSB0byB0cmFjayBhdmFpbGFibGUgaGVpZ2h0IGV2ZW4gb24gaU9TIHZpcnR1YWwga2V5Ym9hcmQgb3BlbmluZ1xuICAgICAgICBsZXQgb25SZXNpemUgPSAoKT0+e1xuICAgICAgICAgICAgc2V0U2l6ZSgoc2l6ZSk9PntcbiAgICAgICAgICAgICAgICBsZXQgbmV3U2l6ZSA9ICQ1ZGY2NGIzODA3ZGMxNWVlJHZhciRnZXRWaWV3cG9ydFNpemUoKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3U2l6ZS53aWR0aCA9PT0gc2l6ZS53aWR0aCAmJiBuZXdTaXplLmhlaWdodCA9PT0gc2l6ZS5oZWlnaHQpIHJldHVybiBzaXplO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdTaXplO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0KSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBvblJlc2l6ZSk7XG4gICAgICAgIGVsc2UgJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25SZXNpemUpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmICghJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0KSB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBvblJlc2l6ZSk7XG4gICAgICAgICAgICBlbHNlICQ1ZGY2NGIzODA3ZGMxNWVlJHZhciR2aXN1YWxWaWV3cG9ydC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG9uUmVzaXplKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHNpemU7XG59XG5mdW5jdGlvbiAkNWRmNjRiMzgwN2RjMTVlZSR2YXIkZ2V0Vmlld3BvcnRTaXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiAoJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0ID09PSBudWxsIHx8ICQ1ZGY2NGIzODA3ZGMxNWVlJHZhciR2aXN1YWxWaWV3cG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0LndpZHRoKSB8fCB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiAoJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0ID09PSBudWxsIHx8ICQ1ZGY2NGIzODA3ZGMxNWVlJHZhciR2aXN1YWxWaWV3cG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0LmhlaWdodCkgfHwgd2luZG93LmlubmVySGVpZ2h0XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmxldCAkZWYwNjI1NjA3OTY4NmJhMCR2YXIkZGVzY3JpcHRpb25JZCA9IDA7XG5jb25zdCAkZWYwNjI1NjA3OTY4NmJhMCR2YXIkZGVzY3JpcHRpb25Ob2RlcyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uICRlZjA2MjU2MDc5Njg2YmEwJGV4cG9ydCRmOGFlZGE3YjEwNzUzZmExKGRlc2NyaXB0aW9uKSB7XG4gICAgbGV0IFtpZCwgc2V0SWRdID0gKDAsICQxMnVHcCR1c2VTdGF0ZSkodW5kZWZpbmVkKTtcbiAgICAoMCwgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMpKCgpPT57XG4gICAgICAgIGlmICghZGVzY3JpcHRpb24pIHJldHVybjtcbiAgICAgICAgbGV0IGRlc2MgPSAkZWYwNjI1NjA3OTY4NmJhMCR2YXIkZGVzY3JpcHRpb25Ob2Rlcy5nZXQoZGVzY3JpcHRpb24pO1xuICAgICAgICBpZiAoIWRlc2MpIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGByZWFjdC1hcmlhLWRlc2NyaXB0aW9uLSR7JGVmMDYyNTYwNzk2ODZiYTAkdmFyJGRlc2NyaXB0aW9uSWQrK31gO1xuICAgICAgICAgICAgc2V0SWQoaWQpO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgbm9kZS5pZCA9IGlkO1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gZGVzY3JpcHRpb247XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICByZWZDb3VudDogMCxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBub2RlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgJGVmMDYyNTYwNzk2ODZiYTAkdmFyJGRlc2NyaXB0aW9uTm9kZXMuc2V0KGRlc2NyaXB0aW9uLCBkZXNjKTtcbiAgICAgICAgfSBlbHNlIHNldElkKGRlc2MuZWxlbWVudC5pZCk7XG4gICAgICAgIGRlc2MucmVmQ291bnQrKztcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAoLS1kZXNjLnJlZkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVzYy5lbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICRlZjA2MjU2MDc5Njg2YmEwJHZhciRkZXNjcmlwdGlvbk5vZGVzLmRlbGV0ZShkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBkZXNjcmlwdGlvblxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIFwiYXJpYS1kZXNjcmliZWRieVwiOiBkZXNjcmlwdGlvbiA/IGlkIDogdW5kZWZpbmVkXG4gICAgfTtcbn1cblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuZnVuY3Rpb24gJGU5ZmFhZmI2NDFlMTY3ZGIkZXhwb3J0JDkwZmMzYTE3ZDkzZjcwNGMocmVmLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGxldCBoYW5kbGVFdmVudCA9ICgwLCAkOGFlMDVlYWE1YzExNGU5YyRleHBvcnQkN2Y1NGZjMzE4MDUwOGE1MikoaGFuZGxlcik7XG4gICAgbGV0IGlzRGlzYWJsZWQgPSBoYW5kbGVyID09IG51bGw7XG4gICAgKDAsICQxMnVHcCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChpc0Rpc2FibGVkKSByZXR1cm47XG4gICAgICAgIGxldCBlbGVtZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlRXZlbnQsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlRXZlbnQsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgcmVmLFxuICAgICAgICBldmVudCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgaXNEaXNhYmxlZCxcbiAgICAgICAgaGFuZGxlRXZlbnRcbiAgICBdKTtcbn1cblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQyZjA0Y2JjNDRlZTMwY2UwJGV4cG9ydCQ1M2EwOTEwZjAzODMzN2JkKHNjcm9sbFZpZXcsIGVsZW1lbnQpIHtcbiAgICBsZXQgb2Zmc2V0WCA9ICQyZjA0Y2JjNDRlZTMwY2UwJHZhciRyZWxhdGl2ZU9mZnNldChzY3JvbGxWaWV3LCBlbGVtZW50LCBcImxlZnRcIik7XG4gICAgbGV0IG9mZnNldFkgPSAkMmYwNGNiYzQ0ZWUzMGNlMCR2YXIkcmVsYXRpdmVPZmZzZXQoc2Nyb2xsVmlldywgZWxlbWVudCwgXCJ0b3BcIik7XG4gICAgbGV0IHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICBsZXQgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgbGV0IHggPSBzY3JvbGxWaWV3LnNjcm9sbExlZnQ7XG4gICAgbGV0IHkgPSBzY3JvbGxWaWV3LnNjcm9sbFRvcDtcbiAgICAvLyBBY2NvdW50IGZvciB0b3AvbGVmdCBib3JkZXIgb2Zmc2V0dGluZyB0aGUgc2Nyb2xsIHRvcC9MZWZ0XG4gICAgbGV0IHsgYm9yZGVyVG9wV2lkdGg6IGJvcmRlclRvcFdpZHRoLCBib3JkZXJMZWZ0V2lkdGg6IGJvcmRlckxlZnRXaWR0aCB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShzY3JvbGxWaWV3KTtcbiAgICBsZXQgYm9yZGVyQWRqdXN0ZWRYID0gc2Nyb2xsVmlldy5zY3JvbGxMZWZ0ICsgcGFyc2VJbnQoYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG4gICAgbGV0IGJvcmRlckFkanVzdGVkWSA9IHNjcm9sbFZpZXcuc2Nyb2xsVG9wICsgcGFyc2VJbnQoYm9yZGVyVG9wV2lkdGgsIDEwKTtcbiAgICAvLyBJZ25vcmUgZW5kL2JvdHRvbSBib3JkZXIgdmlhIGNsaWVudEhlaWdodC9XaWR0aCBpbnN0ZWFkIG9mIG9mZnNldEhlaWdodC9XaWR0aFxuICAgIGxldCBtYXhYID0gYm9yZGVyQWRqdXN0ZWRYICsgc2Nyb2xsVmlldy5jbGllbnRXaWR0aDtcbiAgICBsZXQgbWF4WSA9IGJvcmRlckFkanVzdGVkWSArIHNjcm9sbFZpZXcuY2xpZW50SGVpZ2h0O1xuICAgIGlmIChvZmZzZXRYIDw9IHgpIHggPSBvZmZzZXRYIC0gcGFyc2VJbnQoYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG4gICAgZWxzZSBpZiAob2Zmc2V0WCArIHdpZHRoID4gbWF4WCkgeCArPSBvZmZzZXRYICsgd2lkdGggLSBtYXhYO1xuICAgIGlmIChvZmZzZXRZIDw9IGJvcmRlckFkanVzdGVkWSkgeSA9IG9mZnNldFkgLSBwYXJzZUludChib3JkZXJUb3BXaWR0aCwgMTApO1xuICAgIGVsc2UgaWYgKG9mZnNldFkgKyBoZWlnaHQgPiBtYXhZKSB5ICs9IG9mZnNldFkgKyBoZWlnaHQgLSBtYXhZO1xuICAgIHNjcm9sbFZpZXcuc2Nyb2xsTGVmdCA9IHg7XG4gICAgc2Nyb2xsVmlldy5zY3JvbGxUb3AgPSB5O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgb2Zmc2V0IGxlZnQgb3IgdG9wIGZyb20gY2hpbGQgdG8gYW5jZXN0b3IgYnkgYWNjdW11bGF0aW5nXG4gKiBvZmZzZXRMZWZ0IG9yIG9mZnNldFRvcCB0aHJvdWdoIGludGVydmVuaW5nIG9mZnNldFBhcmVudHMuXG4gKi8gZnVuY3Rpb24gJDJmMDRjYmM0NGVlMzBjZTAkdmFyJHJlbGF0aXZlT2Zmc2V0KGFuY2VzdG9yLCBjaGlsZCwgYXhpcykge1xuICAgIGNvbnN0IHByb3AgPSBheGlzID09PSBcImxlZnRcIiA/IFwib2Zmc2V0TGVmdFwiIDogXCJvZmZzZXRUb3BcIjtcbiAgICBsZXQgc3VtID0gMDtcbiAgICB3aGlsZShjaGlsZC5vZmZzZXRQYXJlbnQpe1xuICAgICAgICBzdW0gKz0gY2hpbGRbcHJvcF07XG4gICAgICAgIGlmIChjaGlsZC5vZmZzZXRQYXJlbnQgPT09IGFuY2VzdG9yKSBicmVhaztcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQub2Zmc2V0UGFyZW50LmNvbnRhaW5zKGFuY2VzdG9yKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGFuY2VzdG9yIGlzIG5vdCBgcG9zaXRpb246cmVsYXRpdmVgLCB0aGVuIHdlIHN0b3AgYXRcbiAgICAgICAgICAgIC8vIF9pdHNfIG9mZnNldCBwYXJlbnQsIGFuZCB3ZSBzdWJ0cmFjdCBvZmYgX2l0c18gb2Zmc2V0LCBzbyB0aGF0XG4gICAgICAgICAgICAvLyB3ZSBlbmQgdXAgd2l0aCB0aGUgcHJvcGVyIG9mZnNldCBmcm9tIGNoaWxkIHRvIGFuY2VzdG9yLlxuICAgICAgICAgICAgc3VtIC09IGFuY2VzdG9yW3Byb3BdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5mdW5jdGlvbiAkMmYwNGNiYzQ0ZWUzMGNlMCRleHBvcnQkYzgyNjg2MDc5NjMwOWQxYih0YXJnZXRFbGVtZW50LCBvcHRzKSB7XG4gICAgaWYgKGRvY3VtZW50LmNvbnRhaW5zKHRhcmdldEVsZW1lbnQpKSB7XG4gICAgICAgIGxldCByb290ID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIGxldCBpc1Njcm9sbFByZXZlbnRlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHJvb3QpLm92ZXJmbG93ID09PSBcImhpZGRlblwiO1xuICAgICAgICAvLyBJZiBzY3JvbGxpbmcgaXMgbm90IGN1cnJlbnRseSBwcmV2ZW50ZWQgdGhlbiB3ZSBhcmVu4oCZdCBpbiBhIG92ZXJsYXkgbm9yIGlzIGEgb3ZlcmxheSBvcGVuLCBqdXN0IHVzZSBlbGVtZW50LnNjcm9sbEludG9WaWV3IHRvIGJyaW5nIHRoZSBlbGVtZW50IGludG8gdmlld1xuICAgICAgICBpZiAoIWlzU2Nyb2xsUHJldmVudGVkKSB7XG4gICAgICAgICAgICB2YXIgLy8gdXNlIHNjcm9sbEludG9WaWV3KHtibG9jazogJ25lYXJlc3QnfSkgaW5zdGVhZCBvZiAuZm9jdXMgdG8gY2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgZnVsbHkgaW4gdmlldyBvciBub3Qgc2luY2UgLmZvY3VzKClcbiAgICAgICAgICAgIC8vIHdvbid0IGNhdXNlIGEgc2Nyb2xsIGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCBhbmQgZG9lc24ndCBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gYW4gZWxlbWVudCBpcyBwYXJ0aWFsbHkgb3V0IG9mIHZpZXcgaG9yaXpvbnRhbGx5IHZzIHZlcnRpY2FsbHlcbiAgICAgICAgICAgIF90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3O1xuICAgICAgICAgICAgbGV0IHsgbGVmdDogb3JpZ2luYWxMZWZ0LCB0b3A6IG9yaWdpbmFsVG9wIH0gPSB0YXJnZXRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9PT0gbnVsbCB8fCB0YXJnZXRFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3RhcmdldEVsZW1lbnRfc2Nyb2xsSW50b1ZpZXcgPSB0YXJnZXRFbGVtZW50LnNjcm9sbEludG9WaWV3KSA9PT0gbnVsbCB8fCBfdGFyZ2V0RWxlbWVudF9zY3JvbGxJbnRvVmlldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RhcmdldEVsZW1lbnRfc2Nyb2xsSW50b1ZpZXcuY2FsbCh0YXJnZXRFbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCB7IGxlZnQ6IG5ld0xlZnQsIHRvcDogbmV3VG9wIH0gPSB0YXJnZXRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgLy8gQWNjb3VudCBmb3Igc3ViIHBpeGVsIGRpZmZlcmVuY2VzIGZyb20gcm91bmRpbmdcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhvcmlnaW5hbExlZnQgLSBuZXdMZWZ0KSA+IDEgfHwgTWF0aC5hYnMob3JpZ2luYWxUb3AgLSBuZXdUb3ApID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBfb3B0c19jb250YWluaW5nRWxlbWVudF9zY3JvbGxJbnRvVmlldywgX29wdHNfY29udGFpbmluZ0VsZW1lbnQsIF90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3MTtcbiAgICAgICAgICAgICAgICBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfb3B0c19jb250YWluaW5nRWxlbWVudCA9IG9wdHMuY29udGFpbmluZ0VsZW1lbnQpID09PSBudWxsIHx8IF9vcHRzX2NvbnRhaW5pbmdFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX29wdHNfY29udGFpbmluZ0VsZW1lbnRfc2Nyb2xsSW50b1ZpZXcgPSBfb3B0c19jb250YWluaW5nRWxlbWVudC5zY3JvbGxJbnRvVmlldykgPT09IG51bGwgfHwgX29wdHNfY29udGFpbmluZ0VsZW1lbnRfc2Nyb2xsSW50b1ZpZXcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRzX2NvbnRhaW5pbmdFbGVtZW50X3Njcm9sbEludG9WaWV3LmNhbGwoX29wdHNfY29udGFpbmluZ0VsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGlubGluZTogXCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIChfdGFyZ2V0RWxlbWVudF9zY3JvbGxJbnRvVmlldzEgPSB0YXJnZXRFbGVtZW50LnNjcm9sbEludG9WaWV3KSA9PT0gbnVsbCB8fCBfdGFyZ2V0RWxlbWVudF9zY3JvbGxJbnRvVmlldzEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3MS5jYWxsKHRhcmdldEVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsUGFyZW50ID0gKDAsICQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCRjZmEyMjI1ZTg3OTM4NzgxKSh0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgICAgIC8vIElmIHNjcm9sbGluZyBpcyBwcmV2ZW50ZWQsIHdlIGRvbid0IHdhbnQgdG8gc2Nyb2xsIHRoZSBib2R5IHNpbmNlIGl0IG1pZ2h0IG1vdmUgdGhlIG92ZXJsYXkgcGFydGlhbGx5IG9mZnNjcmVlbiBhbmQgdGhlIHVzZXIgY2FuJ3Qgc2Nyb2xsIGl0IGJhY2sgaW50byB2aWV3LlxuICAgICAgICAgICAgd2hpbGUodGFyZ2V0RWxlbWVudCAmJiBzY3JvbGxQYXJlbnQgJiYgdGFyZ2V0RWxlbWVudCAhPT0gcm9vdCAmJiBzY3JvbGxQYXJlbnQgIT09IHJvb3Qpe1xuICAgICAgICAgICAgICAgICQyZjA0Y2JjNDRlZTMwY2UwJGV4cG9ydCQ1M2EwOTEwZjAzODMzN2JkKHNjcm9sbFBhcmVudCwgdGFyZ2V0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9IHNjcm9sbFBhcmVudDtcbiAgICAgICAgICAgICAgICBzY3JvbGxQYXJlbnQgPSAoMCwgJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JGNmYTIyMjVlODc5Mzg3ODEpKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDZhN2RiODU0MzI0NDhmN2YkZXhwb3J0JDYwMjc4ODcxNDU3NjIyZGUoZXZlbnQpIHtcbiAgICAvLyBKQVdTL05WREEgd2l0aCBGaXJlZm94LlxuICAgIGlmIChldmVudC5tb3pJbnB1dFNvdXJjZSA9PT0gMCAmJiBldmVudC5pc1RydXN0ZWQpIHJldHVybiB0cnVlO1xuICAgIC8vIEFuZHJvaWQgVGFsa0JhY2sncyBkZXRhaWwgdmFsdWUgdmFyaWVzIGRlcGVuZGluZyBvbiB0aGUgZXZlbnQgbGlzdGVuZXIgcHJvdmlkaW5nIHRoZSBldmVudCBzbyB3ZSBoYXZlIHNwZWNpZmljIGxvZ2ljIGhlcmUgaW5zdGVhZFxuICAgIC8vIElmIHBvaW50ZXJUeXBlIGlzIGRlZmluZWQsIGV2ZW50IGlzIGZyb20gYSBjbGljayBsaXN0ZW5lci4gRm9yIGV2ZW50cyBmcm9tIG1vdXNlZG93biBsaXN0ZW5lciwgZGV0YWlsID09PSAwIGlzIGEgc3VmZmljaWVudCBjaGVja1xuICAgIC8vIHRvIGRldGVjdCBUYWxrQmFjayB2aXJ0dWFsIGNsaWNrcy5cbiAgICBpZiAoKDAsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRhMTFiMDA1OTkwMGNlZWM4KSgpICYmIGV2ZW50LnBvaW50ZXJUeXBlKSByZXR1cm4gZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbnMgPT09IDE7XG4gICAgcmV0dXJuIGV2ZW50LmRldGFpbCA9PT0gMCAmJiAhZXZlbnQucG9pbnRlclR5cGU7XG59XG5mdW5jdGlvbiAkNmE3ZGI4NTQzMjQ0OGY3ZiRleHBvcnQkMjliZjFiNWYyYzU2Y2Y2MyhldmVudCkge1xuICAgIC8vIElmIHRoZSBwb2ludGVyIHNpemUgaXMgemVybywgdGhlbiB3ZSBhc3N1bWUgaXQncyBmcm9tIGEgc2NyZWVuIHJlYWRlci5cbiAgICAvLyBBbmRyb2lkIFRhbGtCYWNrIGRvdWJsZSB0YXAgd2lsbCBzb21ldGltZXMgcmV0dXJuIGEgZXZlbnQgd2l0aCB3aWR0aCBhbmQgaGVpZ2h0IG9mIDFcbiAgICAvLyBhbmQgcG9pbnRlclR5cGUgPT09ICdtb3VzZScgc28gd2UgbmVlZCB0byBjaGVjayBmb3IgYSBzcGVjaWZpYyBjb21iaW5hdGlvbiBvZiBldmVudCBhdHRyaWJ1dGVzLlxuICAgIC8vIENhbm5vdCB1c2UgXCJldmVudC5wcmVzc3VyZSA9PT0gMFwiIGFzIHRoZSBzb2xlIGNoZWNrIGR1ZSB0byBTYWZhcmkgcG9pbnRlciBldmVudHMgYWx3YXlzIHJldHVybmluZyBwcmVzc3VyZSA9PT0gMFxuICAgIC8vIGluc3RlYWQgb2YgLjUsIHNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA2MjE2LiBldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyBpcyB0byBkaXN0aW5ndXNoXG4gICAgLy8gVGFsa2JhY2sgZG91YmxlIHRhcCBmcm9tIFdpbmRvd3MgRmlyZWZveCB0b3VjaCBzY3JlZW4gcHJlc3NcbiAgICByZXR1cm4gISgwLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYTExYjAwNTk5MDBjZWVjOCkoKSAmJiBldmVudC53aWR0aCA9PT0gMCAmJiBldmVudC5oZWlnaHQgPT09IDAgfHwgZXZlbnQud2lkdGggPT09IDEgJiYgZXZlbnQuaGVpZ2h0ID09PSAxICYmIGV2ZW50LnByZXNzdXJlID09PSAwICYmIGV2ZW50LmRldGFpbCA9PT0gMCAmJiBldmVudC5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiO1xufVxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qIGVzbGludC1kaXNhYmxlIHJ1bGVzZGlyL3B1cmUtcmVuZGVyICovIFxuZnVuY3Rpb24gJDVhMzg3Y2M0OTM1MGU2ZGIkZXhwb3J0JDcyMmRlYmMwZTU2ZmVhMzkodmFsdWUsIGlzRXF1YWwpIHtcbiAgICAvLyBVc2luZyBhIHJlZiBkdXJpbmcgcmVuZGVyIGlzIG9rIGhlcmUgYmVjYXVzZSBpdCdzIG9ubHkgYW4gb3B0aW1pemF0aW9uIOKAkyBib3RoIHZhbHVlcyBhcmUgZXF1aXZhbGVudC5cbiAgICAvLyBJZiBhIHJlbmRlciBpcyB0aHJvd24gYXdheSwgaXQnbGwgc3RpbGwgd29yayB0aGUgc2FtZSBubyBtYXR0ZXIgaWYgdGhlIG5leHQgcmVuZGVyIGlzIHRoZSBzYW1lIG9yIG5vdC5cbiAgICBsZXQgbGFzdFZhbHVlID0gKDAsICQxMnVHcCR1c2VSZWYpKG51bGwpO1xuICAgIGlmICh2YWx1ZSAmJiBsYXN0VmFsdWUuY3VycmVudCAmJiBpc0VxdWFsKHZhbHVlLCBsYXN0VmFsdWUuY3VycmVudCkpIHZhbHVlID0gbGFzdFZhbHVlLmN1cnJlbnQ7XG4gICAgbGFzdFZhbHVlLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5mdW5jdGlvbiAkOTlmYWNhYjczMjY2ZjY2MiRleHBvcnQkNWFkZDFkMDA2MjkzZDEzNihyZWYsIGluaXRpYWxWYWx1ZSwgb25SZXNldCkge1xuICAgIGxldCByZXNldFZhbHVlID0gKDAsICQxMnVHcCR1c2VSZWYpKGluaXRpYWxWYWx1ZSk7XG4gICAgbGV0IGhhbmRsZVJlc2V0ID0gKDAsICQ4YWUwNWVhYTVjMTE0ZTljJGV4cG9ydCQ3ZjU0ZmMzMTgwNTA4YTUyKSgoKT0+e1xuICAgICAgICBpZiAob25SZXNldCkgb25SZXNldChyZXNldFZhbHVlLmN1cnJlbnQpO1xuICAgIH0pO1xuICAgICgwLCAkMTJ1R3AkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICB2YXIgX3JlZl9jdXJyZW50O1xuICAgICAgICBsZXQgZm9ybSA9IHJlZiA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfcmVmX2N1cnJlbnQgPSByZWYuY3VycmVudCkgPT09IG51bGwgfHwgX3JlZl9jdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVmX2N1cnJlbnQuZm9ybTtcbiAgICAgICAgZm9ybSA9PT0gbnVsbCB8fCBmb3JtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldFwiLCBoYW5kbGVSZXNldCk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgZm9ybSA9PT0gbnVsbCB8fCBmb3JtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNldFwiLCBoYW5kbGVSZXNldCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICByZWYsXG4gICAgICAgIGhhbmRsZVJlc2V0XG4gICAgXSk7XG59XG5cblxuXG5cbmV4cG9ydCB7JGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGY2ODA4NzdhMzQ3MTFlMzcgYXMgdXNlSWQsICRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRjZDhjOWNiNjhmODQyNjI5IGFzIG1lcmdlSWRzLCAkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkYjRjYzA5YzU5MmU4ZmRiOCBhcyB1c2VTbG90SWQsICRmZjU5NjNlYjFmY2NmNTUyJGV4cG9ydCRlMDhlM2I2N2UzOTIxMDFlIGFzIGNoYWluLCAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkYjIwNGFmMTU4MDQyZmJhYyBhcyBnZXRPd25lckRvY3VtZW50LCAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkZjIxYTFmZmFlMjYwMTQ1YSBhcyBnZXRPd25lcldpbmRvdywgJDNlZjQyNTc1ZGY4NGIzMGIkZXhwb3J0JDlkMTYxMWM3N2MyZmU5MjggYXMgbWVyZ2VQcm9wcywgJDVkYzk1ODk5YjMwNmY2MzAkZXhwb3J0JGM5MDU4MzE2NzY0YzE0MGUgYXMgbWVyZ2VSZWZzLCAkNjU0ODRkMDJkY2I3ZWIzZSRleHBvcnQkNDU3YzNkNjUxOGRkNGM2ZiBhcyBmaWx0ZXJET01Qcm9wcywgJDcyMTVhZmM2ZGU2MDZkNmIkZXhwb3J0JGRlNzllMmM2OTVlMDUyZjMgYXMgZm9jdXNXaXRob3V0U2Nyb2xsaW5nLCAkYWI3MWRhZGIwM2E2ZmIyZSRleHBvcnQkNjIyY2VhNDQ1YTFjNWI3ZCBhcyBnZXRPZmZzZXQsICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5NTE4NWQ2OTllMDVkNGQ3IGFzIG9wZW5MaW5rLCAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkNTE0MzdkNTAzMzczZDIyMyBhcyBnZXRTeW50aGV0aWNMaW5rUHJvcHMsICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQzMjNlNGZjMmZhNDc1M2ZiIGFzIFJvdXRlclByb3ZpZGVyLCAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkZWZhOGM5MDk5ZTUzMDIzNSBhcyBzaG91bGRDbGllbnROYXZpZ2F0ZSwgJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDlhMzAyYTQ1ZjY1ZDA1NzIgYXMgdXNlUm91dGVyLCAkYmJlZDhiNDFmODU3YmNjMCRleHBvcnQkMjQ0OTAzMTZmNzY0YzQzMCBhcyBydW5BZnRlclRyYW5zaXRpb24sICQ5Y2MwOWRmOWZkNzY3NmJlJGV4cG9ydCQ3YmJlZDc1ZmViYTM5NzA2IGFzIHVzZURyYWcxRCwgJDAzZGViMjNmZjE0OTIwYzQkZXhwb3J0JDRlYWYwNGU1NGFhOGVlZDYgYXMgdXNlR2xvYmFsTGlzdGVuZXJzLCAkMzEzYjk4ODYxZWU1ZGQ2YyRleHBvcnQkZDY4NzUxMjIxOTRjN2I0NCBhcyB1c2VMYWJlbHMsICRkZjU2MTY0ZGZmNTc4NWUyJGV4cG9ydCQ0MzM4YjUzMzE1YWJmNjY2IGFzIHVzZU9iamVjdFJlZiwgJDRmNThjNWY3MmJjZjc5ZjckZXhwb3J0JDQ5NjMxNWExNjA4ZDk2MDIgYXMgdXNlVXBkYXRlRWZmZWN0LCAkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYyBhcyB1c2VMYXlvdXRFZmZlY3QsICQ5ZGFhYjAyZDQ2MTgwOWRiJGV4cG9ydCQ2ODM0ODBmMTkxYzBlM2VhIGFzIHVzZVJlc2l6ZU9ic2VydmVyLCAkZTc4MDFiZTgyYjRiMmE1MyRleHBvcnQkNGRlYmRiMWEzZjBmYTc5ZSBhcyB1c2VTeW5jUmVmLCAkNjJkOGRlZDkyOTZmMzg3MiRleHBvcnQkY2ZhMjIyNWU4NzkzODc4MSBhcyBnZXRTY3JvbGxQYXJlbnQsICQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCQyYmI3NDc0MGM0ZTE5ZGVmIGFzIGlzU2Nyb2xsYWJsZSwgJDVkZjY0YjM4MDdkYzE1ZWUkZXhwb3J0JGQ2OTk5MDVkZDU3YzczY2EgYXMgdXNlVmlld3BvcnRTaXplLCAkZWYwNjI1NjA3OTY4NmJhMCRleHBvcnQkZjhhZWRhN2IxMDc1M2ZhMSBhcyB1c2VEZXNjcmlwdGlvbiwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTAgYXMgaXNNYWMsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQxODZjNjk2NGNhMTdkOTkgYXMgaXNJUGhvbmUsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3YmVmMDQ5Y2U5MmU0MjI0IGFzIGlzSVBhZCwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGZlZGIzNjljYjcwMjA3ZjEgYXMgaXNJT1MsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRlMTg2NWMzYmVkY2Q4MjJiIGFzIGlzQXBwbGVEZXZpY2UsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3ODU1MTA0MzU4MmE2YTk4IGFzIGlzV2ViS2l0LCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkNjQ0NmExODZkMDllMzc5ZSBhcyBpc0Nocm9tZSwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGExMWIwMDU5OTAwY2VlYzggYXMgaXNBbmRyb2lkLCAkZTlmYWFmYjY0MWUxNjdkYiRleHBvcnQkOTBmYzNhMTdkOTNmNzA0YyBhcyB1c2VFdmVudCwgJDFkYmVjYmUyN2EwNGY5YWYkZXhwb3J0JDE0ZDIzOGYzNDI3MjNmMjUgYXMgdXNlVmFsdWVFZmZlY3QsICQyZjA0Y2JjNDRlZTMwY2UwJGV4cG9ydCQ1M2EwOTEwZjAzODMzN2JkIGFzIHNjcm9sbEludG9WaWV3LCAkMmYwNGNiYzQ0ZWUzMGNlMCRleHBvcnQkYzgyNjg2MDc5NjMwOWQxYiBhcyBzY3JvbGxJbnRvVmlld3BvcnQsICQ0NTA3NDYxYTFiODcwMTIzJHJlX2V4cG9ydCRjbGFtcCBhcyBjbGFtcCwgJDQ1MDc0NjFhMWI4NzAxMjMkcmVfZXhwb3J0JHNuYXBWYWx1ZVRvU3RlcCBhcyBzbmFwVmFsdWVUb1N0ZXAsICQ2YTdkYjg1NDMyNDQ4ZjdmJGV4cG9ydCQ2MDI3ODg3MTQ1NzYyMmRlIGFzIGlzVmlydHVhbENsaWNrLCAkNmE3ZGI4NTQzMjQ0OGY3ZiRleHBvcnQkMjliZjFiNWYyYzU2Y2Y2MyBhcyBpc1ZpcnR1YWxQb2ludGVyRXZlbnQsICQ4YWUwNWVhYTVjMTE0ZTljJGV4cG9ydCQ3ZjU0ZmMzMTgwNTA4YTUyIGFzIHVzZUVmZmVjdEV2ZW50LCAkNWEzODdjYzQ5MzUwZTZkYiRleHBvcnQkNzIyZGViYzBlNTZmZWEzOSBhcyB1c2VEZWVwTWVtbywgJDk5ZmFjYWI3MzI2NmY2NjIkZXhwb3J0JDVhZGQxZDAwNjI5M2QxMzYgYXMgdXNlRm9ybVJlc2V0fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@react-aria/utils/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@react-aria/visually-hidden/dist/import.mjs":
/*!**********************************************************************!*\
  !*** ../../node_modules/@react-aria/visually-hidden/dist/import.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VisuallyHidden: () => (/* binding */ $5c3e21d68f1c4674$export$439d29a4e110a164),\n/* harmony export */   useVisuallyHidden: () => (/* binding */ $5c3e21d68f1c4674$export$a966af930f325cab)\n/* harmony export */ });\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/../../node_modules/@react-aria/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_interactions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/interactions */ \"(ssr)/../../node_modules/@react-aria/interactions/dist/import.mjs\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nconst $5c3e21d68f1c4674$var$styles = {\n    border: 0,\n    clip: \"rect(0 0 0 0)\",\n    clipPath: \"inset(50%)\",\n    height: \"1px\",\n    margin: \"-1px\",\n    overflow: \"hidden\",\n    padding: 0,\n    position: \"absolute\",\n    width: \"1px\",\n    whiteSpace: \"nowrap\"\n};\nfunction $5c3e21d68f1c4674$export$a966af930f325cab(props = {}) {\n    let { style: style, isFocusable: isFocusable } = props;\n    let [isFocused, setFocused] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let { focusWithinProps: focusWithinProps } = (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_1__.useFocusWithin)({\n        isDisabled: !isFocusable,\n        onFocusWithinChange: (val)=>setFocused(val)\n    });\n    // If focused, don't hide the element.\n    let combinedStyles = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (isFocused) return style;\n        else if (style) return {\n            ...$5c3e21d68f1c4674$var$styles,\n            ...style\n        };\n        else return $5c3e21d68f1c4674$var$styles;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isFocused\n    ]);\n    return {\n        visuallyHiddenProps: {\n            ...focusWithinProps,\n            style: combinedStyles\n        }\n    };\n}\nfunction $5c3e21d68f1c4674$export$439d29a4e110a164(props) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    let { children: children, elementType: Element = \"div\", isFocusable: isFocusable, style: style, ...otherProps } = props;\n    let { visuallyHiddenProps: visuallyHiddenProps } = $5c3e21d68f1c4674$export$a966af930f325cab(props);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement(Element, (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.mergeProps)(otherProps, visuallyHiddenProps), children);\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL3Zpc3VhbGx5LWhpZGRlbi9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBa0U7QUFDeUI7QUFDVjs7QUFFakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsVUFBVSx5Q0FBeUM7QUFDbkQsc0NBQXNDLDJDQUFlO0FBQ3JELFVBQVUscUNBQXFDLE1BQU0sb0VBQXFCO0FBQzFFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2QkFBNkIsMENBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMEdBQTBHO0FBQ3BILFVBQVUsMkNBQTJDO0FBQ3JELDZCQUE2QixrQ0FBWSw2QkFBNkIseURBQWlCO0FBQ3ZGOzs7OztBQUtxSTtBQUNySSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AcmVhY3QtYXJpYS92aXN1YWxseS1oaWRkZW4vZGlzdC9pbXBvcnQubWpzPzIzNjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHttZXJnZVByb3BzIGFzICQ5QnhuRSRtZXJnZVByb3BzfSBmcm9tIFwiQHJlYWN0LWFyaWEvdXRpbHNcIjtcbmltcG9ydCAkOUJ4bkUkcmVhY3QsIHt1c2VTdGF0ZSBhcyAkOUJ4bkUkdXNlU3RhdGUsIHVzZU1lbW8gYXMgJDlCeG5FJHVzZU1lbW99IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHt1c2VGb2N1c1dpdGhpbiBhcyAkOUJ4bkUkdXNlRm9jdXNXaXRoaW59IGZyb20gXCJAcmVhY3QtYXJpYS9pbnRlcmFjdGlvbnNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5jb25zdCAkNWMzZTIxZDY4ZjFjNDY3NCR2YXIkc3R5bGVzID0ge1xuICAgIGJvcmRlcjogMCxcbiAgICBjbGlwOiBcInJlY3QoMCAwIDAgMClcIixcbiAgICBjbGlwUGF0aDogXCJpbnNldCg1MCUpXCIsXG4gICAgaGVpZ2h0OiBcIjFweFwiLFxuICAgIG1hcmdpbjogXCItMXB4XCIsXG4gICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIHdpZHRoOiBcIjFweFwiLFxuICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCJcbn07XG5mdW5jdGlvbiAkNWMzZTIxZDY4ZjFjNDY3NCRleHBvcnQkYTk2NmFmOTMwZjMyNWNhYihwcm9wcyA9IHt9KSB7XG4gICAgbGV0IHsgc3R5bGU6IHN0eWxlLCBpc0ZvY3VzYWJsZTogaXNGb2N1c2FibGUgfSA9IHByb3BzO1xuICAgIGxldCBbaXNGb2N1c2VkLCBzZXRGb2N1c2VkXSA9ICgwLCAkOUJ4bkUkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgeyBmb2N1c1dpdGhpblByb3BzOiBmb2N1c1dpdGhpblByb3BzIH0gPSAoMCwgJDlCeG5FJHVzZUZvY3VzV2l0aGluKSh7XG4gICAgICAgIGlzRGlzYWJsZWQ6ICFpc0ZvY3VzYWJsZSxcbiAgICAgICAgb25Gb2N1c1dpdGhpbkNoYW5nZTogKHZhbCk9PnNldEZvY3VzZWQodmFsKVxuICAgIH0pO1xuICAgIC8vIElmIGZvY3VzZWQsIGRvbid0IGhpZGUgdGhlIGVsZW1lbnQuXG4gICAgbGV0IGNvbWJpbmVkU3R5bGVzID0gKDAsICQ5QnhuRSR1c2VNZW1vKSgoKT0+e1xuICAgICAgICBpZiAoaXNGb2N1c2VkKSByZXR1cm4gc3R5bGU7XG4gICAgICAgIGVsc2UgaWYgKHN0eWxlKSByZXR1cm4ge1xuICAgICAgICAgICAgLi4uJDVjM2UyMWQ2OGYxYzQ2NzQkdmFyJHN0eWxlcyxcbiAgICAgICAgICAgIC4uLnN0eWxlXG4gICAgICAgIH07XG4gICAgICAgIGVsc2UgcmV0dXJuICQ1YzNlMjFkNjhmMWM0Njc0JHZhciRzdHlsZXM7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtcbiAgICAgICAgaXNGb2N1c2VkXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmlzdWFsbHlIaWRkZW5Qcm9wczoge1xuICAgICAgICAgICAgLi4uZm9jdXNXaXRoaW5Qcm9wcyxcbiAgICAgICAgICAgIHN0eWxlOiBjb21iaW5lZFN0eWxlc1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uICQ1YzNlMjFkNjhmMWM0Njc0JGV4cG9ydCQ0MzlkMjlhNGUxMTBhMTY0KHByb3BzKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgZWxlbWVudFR5cGU6IEVsZW1lbnQgPSBcImRpdlwiLCBpc0ZvY3VzYWJsZTogaXNGb2N1c2FibGUsIHN0eWxlOiBzdHlsZSwgLi4ub3RoZXJQcm9wcyB9ID0gcHJvcHM7XG4gICAgbGV0IHsgdmlzdWFsbHlIaWRkZW5Qcm9wczogdmlzdWFsbHlIaWRkZW5Qcm9wcyB9ID0gJDVjM2UyMWQ2OGYxYzQ2NzQkZXhwb3J0JGE5NjZhZjkzMGYzMjVjYWIocHJvcHMpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkOUJ4bkUkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoRWxlbWVudCwgKDAsICQ5QnhuRSRtZXJnZVByb3BzKShvdGhlclByb3BzLCB2aXN1YWxseUhpZGRlblByb3BzKSwgY2hpbGRyZW4pO1xufVxuXG5cblxuXG5leHBvcnQgeyQ1YzNlMjFkNjhmMWM0Njc0JGV4cG9ydCRhOTY2YWY5MzBmMzI1Y2FiIGFzIHVzZVZpc3VhbGx5SGlkZGVuLCAkNWMzZTIxZDY4ZjFjNDY3NCRleHBvcnQkNDM5ZDI5YTRlMTEwYTE2NCBhcyBWaXN1YWxseUhpZGRlbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@react-aria/visually-hidden/dist/import.mjs\n");

/***/ })

};
;